üìÇ Estructura del Proyecto
=========================
.
‚îú‚îÄ‚îÄ README.dev.md
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ Whatsapp-Conversation-Flow.md
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ admin
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channels
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ embeddings
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotels
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prompts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ roles
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ send-verification
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-toast
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ upload
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ users
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ delete
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ get
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ list
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ manage
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ [userId]
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ new
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ update
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ verification
‚îÇ¬†¬† ‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chat
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts:Zone.Identifier
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ add
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mode
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ toggle
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ debug
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hotelPhoneMap
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email 
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel-documents
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotels
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ create
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ delete
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ delete-version
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ get
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list-versions
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rollback-version
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ update
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ upload-docs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logout
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ me
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ change-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ messages
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ by-conversation
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ refresh
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ list-users
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ users
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ change-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ create
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ delete
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ get
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotels-for-user
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ send-recovery-email
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ send-verification-email
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ update
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ validate-reset-token
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ verify-account
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsapp
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ change-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgot-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ verify-account
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ generatePDF.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ globals.css
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lib
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Hotel_Demo.pdf
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ translation.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ taildocs.txt
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test-dnd
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ page.tsx
‚îú‚îÄ‚îÄ arbol.txt
‚îú‚îÄ‚îÄ arquitectura.txt
‚îú‚îÄ‚îÄ aux.json
‚îú‚îÄ‚îÄ cache_para_hotel_phone_map.md
‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ UsertStatus.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ admin
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChannelMessages.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChannelsClient.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ HotelDocumentUploader.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ui
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BegasistTable.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DarkCard.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Input.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SidebarGroup.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SidebarLink.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SidebarLogout.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ThemeToggle.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ badge.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ button.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ card.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dropdown-menu.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ table.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ toaster.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ ApplyThemeClass.tsx
‚îú‚îÄ‚îÄ components.json
‚îú‚îÄ‚îÄ constants
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ roles.ts
‚îú‚îÄ‚îÄ context
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ThemeContext.tsx
‚îú‚îÄ‚îÄ convertir_pdf_a_txt.sh
‚îú‚îÄ‚îÄ convertir_txt_a_pdf.sh
‚îú‚îÄ‚îÄ deprecated
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ addChannelToHotelConfig.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ toggle
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îú‚îÄ‚îÄ dnd-test.html
‚îú‚îÄ‚îÄ docs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Arquitectura_segura_gestion_de_usuarios.png
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Arquitectura_segura_gestion_de_usuarios.png:Zone.Identifier
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChatGPT Image 23 may 2025, 05_30_52.png
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChatGPT Image 23 may 2025, 05_30_52.png:Zone.Identifier
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChatGPT Plus ¬°Perfecto! Aqu√≠ tienes un documento en formato Markdown que resume y documenta claramente c√≥mo funciona el manejo_centralizado_del_mapping_iso3to1.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Checklist_de_Verificaci√≥n_para_Desarrollo_Multihotel.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Esquema_l√≥gico_de_la_arquitectura_SaaS_Multihotel.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Estructura_coleccion_base_conocimiento.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ contexto-chatgpt.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ esquema-roles.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ estructura_coleccion_base_de_conocimiento.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gestion_de_idiomas_en_hotel_assistant.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ guia_de_helpers_de_roles_y_accesos.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mapa_seguro_de_rutas_de_usuarios
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ navegacion_y_apis_en_nextjs.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ seguridad_manejo_de_cookies.md
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ userstatus-test-doc.md
‚îú‚îÄ‚îÄ ecosystem.config.js
‚îú‚îÄ‚îÄ eslint.config.mjs
‚îú‚îÄ‚îÄ estructura_del_proyecto.txt
‚îú‚îÄ‚îÄ generate_architecture.sh
‚îú‚îÄ‚îÄ google-chrome-stable_current_amd64.deb
‚îú‚îÄ‚îÄ hotel999_backup.json
‚îú‚îÄ‚îÄ index.modified.ts:Zone.Identifier
‚îú‚îÄ‚îÄ info.txt
‚îú‚îÄ‚îÄ knowledge_docs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel-demo-en-textonly.pdf
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel-demo-en-textonly_copy.pdf
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hotel-demo-en-textonly_copy.txt
‚îú‚îÄ‚îÄ lib
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ agents
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billing.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ defaultResponse.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ internal_support.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reservations.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ retrieval_based.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ services.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ fetchWithAuth.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ astra
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ connection.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ load_from_pdf.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ findUserByEmail.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getCurrentUserEmail.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ jwt.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ roles.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ sendVerificationEmail.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tokenUtils.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ verifyUserAccount.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ classifier
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ categoryAliases.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ client
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ fetchWithAuth.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getInitialHotelConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfig.server.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelLanguage.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelPhoneMap.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ initHotelConfig.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ constants
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ adminMenu.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ context
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ UserContext.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ db
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getHotelsForUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ messages.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ sendEmail.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sendRecoveryEmail.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entrypoints
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ all.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsapp.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ useCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useSession.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ middleware
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pms
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prompts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ promptMetadata.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ retrieval
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ deleteVersionForHotel.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getHotelChunks.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ listVersionsForHotel.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rollbackVersionForHotel.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validateClassification.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channelHandlers.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channelManager.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channelManagerMemory.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channelMemory.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ emailMemory.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ messages
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ webMemory.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ whatsapp.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ whatsappClient.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsappMemory.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ buildVerificationUrl.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ debugLog.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lang.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ language.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ parseChannel.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ roles.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ similarity.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ time.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.ts
‚îú‚îÄ‚îÄ middleware.ts
‚îú‚îÄ‚îÄ next
‚îú‚îÄ‚îÄ next-env.d.ts
‚îú‚îÄ‚îÄ next.config.ts
‚îú‚îÄ‚îÄ output_cleaned.txt
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ pages
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ api
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ upload-hotel-document.ts
‚îú‚îÄ‚îÄ parsed-completo.json
‚îú‚îÄ‚îÄ pnpm-lock.yaml
‚îú‚îÄ‚îÄ postcss.config.mjs
‚îú‚îÄ‚îÄ prompt-clasificador.txt
‚îú‚îÄ‚îÄ public
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ file.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fonts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-latin-ext.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-latin.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-mono-latin-ext.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ geist-mono-latin.woff2
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ globe.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ next.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ vercel.svg
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ window.svg
‚îú‚îÄ‚îÄ scripts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ add-userid-to-user.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ backup-hotel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cleanup-test-messages.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ clone-hotel-collection.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fix-channel-modes.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fix-missing-verification-base.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fix-rolelevel-zero.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fix-users-add-userId.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ generate-hotel-demo-pdf.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ generate-new-token.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ init-admin.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ init-config.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ init-new-hotel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ insert-test-message.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list-users-by-email.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list-users-in-hotel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ list-users.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ migrate-hotel123-to-hotel999.ts.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ migrate-id-to-messageId.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ normalize AstraResultas
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ patch-chunks-add-version.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ patch-messages-add-fields.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ removeVerificationBaseUrl.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ set-password.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ set-smtp.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setupHotel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ show-system-iso3to1.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-astra.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-retrievalBased.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-search-wifi.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-upload-hotel-doc.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ testClassifier.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_search.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ update-hotelId.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ update-system-iso3to1.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ update-user-in-hotel.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ update-user-password.ts
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel_agent_uml.uml
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ test
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ChannelMessages.test.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 05-versions-space.pdf
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 05-versions-space.pdf.txt
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ integration
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ UserStatus.test.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getAllHotelConfigs.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ getMessagesFromAstra.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfig.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfigDynamicChannel.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfigExtend.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ messagesByConversation.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ persistApprovedResponse.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ roundTripMessages.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ saveMessageToAstra.email.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ saveMessageToAstra.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ updateMessageInAstra.test.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ channelMemory.test.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ setup,ts
‚îú‚îÄ‚îÄ test-bcrypt.ts
‚îú‚îÄ‚îÄ test-imap-connection.ts
‚îú‚îÄ‚îÄ test-imap-simple.ts
‚îú‚îÄ‚îÄ testAstraConnection.ts
‚îú‚îÄ‚îÄ texto.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ tsconfig.tsbuildinfo
‚îú‚îÄ‚îÄ types
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chunk.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mailparser.d.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rehype-raw.d.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ roles.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ user.ts
‚îú‚îÄ‚îÄ vector_cache
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ rooms_vectorstore.json
‚îú‚îÄ‚îÄ vitest.config.ts
‚îú‚îÄ‚îÄ vitest.setup.ts
‚îî‚îÄ‚îÄ zzaux.aux

117 directories, 297 files

=========================

üìú Scripts Claves
=================

üîπ Archivo: ./lib/services/channelHandlers.ts
---------------------------------
// /root/begasist/lib/services/channelHandlers.ts

import { ChannelMessage } from "@/types/channel";

// üîß Define la interfaz que deben implementar todos los handlers
export interface ChannelHandler {
  process: (msg: ChannelMessage) => Promise<void>;
}

// üß© Handler para canal Web
const webHandler: ChannelHandler = {
  async process(msg) {
    console.log("üåê [webHandler] Procesando mensaje:", msg.messageId);
    // Aqu√≠ podr√≠as guardar el mensaje, actualizar estado, etc.
    // Ejemplo:
    // await saveMessageToAstra(msg);
  },
};

// üì© Handler para canal Email
const emailHandler: ChannelHandler = {
  async process(msg) {
    console.log("üìß [emailHandler] Procesando mensaje:", msg.messageId);
    // L√≥gica propia del canal email
  },
};

// üí¨ Handler para canal WhatsApp
const whatsappHandler: ChannelHandler = {
  async process(msg) {
    console.log("üì± [whatsappHandler] Procesando mensaje:", msg.messageId);
    // L√≥gica espec√≠fica para WhatsApp
  },
};

// üõ∞Ô∏è Handler para Channel Manager
const channelManagerHandler: ChannelHandler = {
  async process(msg) {
    console.log("üì° [channelManagerHandler] Procesando mensaje:", msg.messageId);
    // Procesamiento de reservas u otros eventos desde el channel manager
  },
};

// üß≠ Registro global de handlers (üí° extensible)
export const channelHandlers = {
  web: webHandler,
  email: emailHandler,
  whatsapp: whatsappHandler,
  channelManager: channelManagerHandler,
} as const;

// üè∑Ô∏è Tipo derivado de los canales registrados
export type Channel = keyof typeof channelHandlers;

---------------------------------


üîπ Archivo: ./lib/services/channelManager.ts
---------------------------------
// lib/services/channelManager.ts
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";

const simulatedReservations = [
  "Quiero reservar una habitaci√≥n doble para el 10 de junio al 12 de junio.",
  "¬øTienen disponibilidad para una suite del 5 al 7 de mayo?",
  "Necesito una habitaci√≥n individual para esta noche.",
];

export async function startChannelManagerBot() {
  console.log("üõ∞Ô∏è [channelManager] Iniciado. Simulando reservas cada 15s...");

  setInterval(async () => {
    try {
      const randomMessage =
        simulatedReservations[Math.floor(Math.random() * simulatedReservations.length)];

      console.log("üì• [channelManager] Reserva simulada:", randomMessage);

      const response = await agentGraph.invoke({
        messages: [new HumanMessage(randomMessage)],
      });

      const reply = response.messages.at(-1)?.content;

      if (reply) {
        console.log("üì§ [channelManager] Respuesta del asistente:", reply);
      }
    } catch (err) {
      console.error("‚õî [channelManager] Error procesando reserva:", err);
    }
  }, 15000);
}

---------------------------------


üîπ Archivo: ./lib/services/channelMemory.ts
---------------------------------
// /lib/services/channelMemory.ts

import { Channel, ChannelMessage } from "@/types/channel";

type InMemoryChannelStore = {
  [channel in Channel]?: ChannelMessage[];
};

const store: InMemoryChannelStore = {};

export const channelMemory = {
  getMessages(channel: Channel): ChannelMessage[] {
    console.log("üß† store actual:", store);
    return store[channel] ?? [];
  },

  addMessage(msg: ChannelMessage) {
    console.log("üß†üß†Mensage que llegab a ChannelMessage", msg)
    if (!store[msg.channel]) store[msg.channel] = [];
    store[msg.channel]!.unshift(msg);
  },

  updateMessage(
    channel: Channel,
    messageId: string,
    changes: Partial<ChannelMessage>
  ): boolean {
    const msgs = store[channel];
    if (!msgs) return false;
    const idx = msgs.findIndex((m) => m.messageId === messageId);
    if (idx >= 0) {
      msgs[idx] = { ...msgs[idx], ...changes };
      return true;
    }
    return false;
  },
};

---------------------------------


üîπ Archivo: ./lib/services/email.ts
---------------------------------
// /lib/services/email.ts
import { simpleParser } from "mailparser";
import imaps from "imap-simple";
import nodemailer from "nodemailer";
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";
import dotenv from "dotenv";

dotenv.config();

export async function startEmailBot() {
  console.log("üì• [email] Iniciando bot de correo...");

  try {
    const {
      EMAIL_USER,
      EMAIL_PASS,
      IMAP_HOST,
      IMAP_PORT,
      SMTP_HOST,
      SMTP_PORT,
      EMAIL_SECURE,
    } = process.env;

    if (!EMAIL_USER || !EMAIL_PASS || !IMAP_HOST || !SMTP_HOST) {
      throw new Error("‚ùå Faltan variables de entorno cr√≠ticas (EMAIL_USER, EMAIL_PASS, IMAP_HOST, SMTP_HOST)");
    }

    const imapConfig = {
      imap: {
        user: EMAIL_USER,
        password: EMAIL_PASS,
        host: IMAP_HOST,
        port: Number(IMAP_PORT) || 993,
        tls: true,
        tlsOptions: { rejectUnauthorized: false }, // ‚¨ÖÔ∏è Clave para evitar errores SSL locales
        authTimeout: 10000,
      },
    };

    const transporter = nodemailer.createTransport({
      host: SMTP_HOST,
      port: Number(SMTP_PORT) || 587,
      secure: false, // usar STARTTLS (para puerto 587)
      auth: {
        user: EMAIL_USER,
        pass: EMAIL_PASS,
      },
    });

    const connection = await imaps.connect(imapConfig);
    await connection.openBox("INBOX");
    console.log("‚úÖ [email] Conectado a IMAP. Escuchando correos cada 15s...");

    setInterval(async () => {
      try {
        const messages = await connection.search(["UNSEEN"], {
          bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE)", "TEXT"],
          struct: true,
        });

        if (!messages.length) return;

        console.log(`üì¨ [email] Correos no le√≠dos: ${messages.length}`);

        for (const message of messages) {
          const parts = imaps.getParts(message.attributes.struct);
          const part = parts.find((p: any) => p.type === "text");
          if (!part) continue;
        
          const raw = await connection.getPartData(message, part);
          const parsed = await simpleParser(raw);
        
          const htmlRaw =
            typeof parsed.html === "string"
              ? parsed.html
              : Buffer.isBuffer(parsed.html)
              ? parsed.html.toString("utf-8")
              : "";
        
          const cleanText =
            parsed.text?.trim() ||
            htmlRaw.replace(/<[^>]+>/g, "").trim() ||
            parsed.headerLines?.map((h: { key: string; line: string }) => h.line).join("\n").trim();
        
          const headerPart = message.parts.find((p: any) => p.which?.toLowerCase().includes("header"));
          const rawFrom = Array.isArray(headerPart?.body?.from) ? headerPart.body.from[0] : undefined;
        
          const from =
            parsed.from?.text ||
            rawFrom ||
            parsed.headerLines?.find((h: { key: string; line: string }) => h.line.includes("@"))?.line;
        
          if (!cleanText || !from) {
            console.warn("‚ö†Ô∏è [email] Email ignorado: sin texto o remitente v√°lido.", {
              fromFallback: rawFrom,
              parsedFrom: parsed.from?.text,
              parsedText: parsed.text,
              parsedHTML: parsed.html,
              headerLines: parsed.headerLines,
            });
            continue;
          }
        
          console.log(`üìß [email] Procesando email de ${from}`);
        
          const response = await agentGraph.invoke({
            messages: [new HumanMessage(cleanText)],
          });
        
          const reply = response.messages.at(-1)?.content;
          if (typeof reply === "string") {
            await transporter.sendMail({
              from: EMAIL_USER,
              to: from,
              subject: "Re: " + (parsed.subject || "Consulta recibida"),
              text: reply,
            });
        
            console.log(`üì§ [email] Respuesta enviada a ${from}`);
          }
        }
        
      } catch (err) {
        console.error("‚õî [email] Error procesando correos:", err);
      }
    }, 15000);
  } catch (startupErr) {
    console.error("üí• [email] Error cr√≠tico al iniciar el bot:", startupErr);
    throw startupErr;
  }
}

---------------------------------


üîπ Archivo: ./lib/services/whatsappMemory.ts
---------------------------------
// /lib/services/whatsappMemory.ts

type Message = {
    id: string;
    sender: string;
    timestamp: string;
    content: string;
    suggestion: string;
    approvedResponse?: string;
    status: "pending" | "sent" | "rejected";
    edited?: boolean;
    respondedBy?: string;
  };
  
  const memory: Message[] = [
    {
      id: "whatsapp-msg-1",
      sender: "+5491123456789",
      timestamp: new Date().toISOString(),
      content: "¬øTienen desayuno incluido?",
      suggestion: "S√≠, el desayuno est√° incluido en todas las tarifas.",
      status: "pending",
    },
  ];
  
  export const whatsappMemory = {
    getMessages: () => memory,
    updateMessage: (id: string, changes: Partial<Message>) => {
      const msg = memory.find((m) => m.id === id);
      if (!msg) return false;
      Object.assign(msg, changes);
      return true;
    },
  };
  
---------------------------------


üîπ Archivo: ./lib/services/hotel.ts
---------------------------------
// /lib/services/hotel.ts

import { collection } from "@/lib/config/hotelConfig.server";
import { randomUUID } from "crypto";
import { sendVerificationEmail } from "@/lib/auth/sendVerificationEmail"; // üëà Import

/**
 * Crea un nuevo hotel y usuario administrador inicial, enviando email de verificaci√≥n.
 * Devuelve: { ok: true, hotelId }
 */
export async function createHotelWithAdmin({
  hotelId,
  hotelName,
  timezone,
  defaultLanguage = "spa",
  adminEmail,
  adminPassword,
  adminRoleLevel = 10,
  emailSettings, // üëà Agreg√° este campo
}: {
  hotelId: string;
  hotelName: string;
  timezone: string;
  defaultLanguage?: string;
  adminEmail: string;
  adminPassword: string;
  adminRoleLevel?: number;
  emailSettings: { // ‚¨ÖÔ∏è asegurate de tipar igual que tu definici√≥n
    emailAddress: string;
    password: string;
    imapHost: string;
    imapPort: number;
    smtpHost: string;
    smtpPort: number;
    secure?: boolean;
    checkInterval?: number;
  };
}) {
  if (!hotelId || !hotelName || !timezone || !adminEmail || !adminPassword || !emailSettings) {
    throw new Error("Faltan datos obligatorios");
  }

  // Chequeo de duplicados
  const existing = await collection.findOne({ hotelId });
  if (existing) throw new Error("Ya existe un hotel con ese ID");

  // Restricci√≥n: solo el hotel system puede tener SuperAdmin (roleLevel 0)
  if (hotelId !== "system" && adminRoleLevel === 0) {
    throw new Error("No se puede asignar roleLevel 0 fuera del hotel system");
  }

  // Hasheo de contrase√±a
  const bcrypt = await import("bcryptjs");
  const passwordHash = await bcrypt.hash(adminPassword, 10);

  // üö© Token de verificaci√≥n
  const verificationToken = randomUUID();

  // Configuraci√≥n m√≠nima del hotel
  const hotelConfig = {
    hotelId,
    hotelName,
    timezone,
    defaultLanguage,
    channelConfigs: {},
    emailSettings, // üëà Guard√° directamente la config de mail que recibiste
    users: [
      {
        userId: randomUUID(),
        email: adminEmail,
        passwordHash,
        roleLevel: adminRoleLevel,
        active: false, // ‚ö†Ô∏è Inactivo hasta verificar email
        verificationToken,
        createdAt: new Date().toISOString(),
      },
    ],
    lastUpdated: new Date().toISOString(),
  };

  await collection.insertOne(hotelConfig);

  // üöÄ Env√≠a el email de verificaci√≥n usando la config reci√©n cargada
  try {
    await sendVerificationEmail({
      email: adminEmail,
      verificationToken,
      hotelId,
      emailSettings, // <-- No hay que buscarla, la recib√≠s y reenvi√°s
    });

  } catch (err) {
    console.error("Error enviando email de verificaci√≥n al admin:", err);
    throw new Error("Error enviando email de verificaci√≥n al admin.");
  }

  return { ok: true, hotelId, verificationEmailSent: true };

}

---------------------------------


üîπ Archivo: ./lib/services/messages/index.ts
---------------------------------
// /lib/services/messages/index.ts
import {
  getMessagesFromAstra,
  updateMessageInAstra,
  getMessagesFromAstraByConversation, // üëà agregalo
} from "@/lib/db/messages";

import { channelMemory } from "@/lib/services/channelMemory";
import type { Channel, ChannelMessage } from "@/types/channel";


export async function getMessagesFromChannel(
  hotelId: string,
  channel: Channel,
  conversationId?: string
) {
  if (process.env.NODE_ENV === "development") {
    const msgs = channelMemory.getMessages(channel);
    return conversationId ? msgs.filter(m => m.conversationId === conversationId) : msgs;
  }

  const parsedLimit = conversationId ? parseInt(conversationId, 10) : undefined;
  return await getMessagesFromAstra(hotelId, channel, parsedLimit);
}


export async function updateMessageInChannel(
  hotelId: string,
  channel: Channel,
  messageId: string,
  changes: Partial<ChannelMessage>
) {
  if (process.env.NODE_ENV === "development") {
    return channelMemory.updateMessage(channel, messageId, changes);
  }

  return await updateMessageInAstra(hotelId, messageId, changes); // üëà importante
}

export async function getMessagesByConversation(
  hotelId: string,
  channel: Channel,
  conversationId: string
) {
  if (process.env.NODE_ENV === "development") {
    const all = channelMemory.getMessages(channel);
    return all.filter((msg) => msg.conversationId === conversationId);
  }

  return await getMessagesFromAstraByConversation(hotelId, channel, conversationId);
}



---------------------------------


üîπ Archivo: ./lib/services/whatsapp.ts
---------------------------------
// /lib/services/whatsapp.ts

import { Message } from "whatsapp-web.js";
import { whatsappClient as client } from "./whatsappClient";
import { agentGraph } from "@/lib/agents";
import { HumanMessage } from "@langchain/core/messages";
import { v4 as uuidv4 } from "uuid";
import { channelMemory } from "@/lib/services/channelMemory";
import { getLocalTime } from "@/lib/utils/time";
import { getHotelIdByPhone } from "@/lib/config/hotelPhoneMap";
import { saveMessageToAstra } from "@/lib/db/messages";
import { getHotelConfig } from "@/lib/config/hotelConfig.server"; // üî• agregado
import qrcode from "qrcode-terminal";

export function startWhatsAppBot() {
  client.on("qr", (qr) => {
    console.log("‚ö° [whatsapp] Escane√° este c√≥digo QR para conectar:");
    qrcode.generate(qr, { small: true });
  });

  client.on("ready", () => {
    console.log("‚úÖ [whatsapp] Bot de WhatsApp listo para recibir mensajes.");
  });

  client.on("message", async (message: Message) => {
    try {
      console.log(`üì© [whatsapp] Mensaje recibido de ${message.from}: ${message.body}`);

      const hotelPhone = message.to ?? "default";
      const hotelId = await getHotelIdByPhone(hotelPhone);

      if (!hotelId) {
        console.warn(`‚ö†Ô∏è [whatsapp] N√∫mero destino ${hotelPhone} no asociado a ning√∫n hotel.`);
        return;
      }

      const senderPhone = message.from;
      const conversationId = `${hotelId}-whatsapp-${senderPhone}`;
      const timestamp = new Date().toISOString();

      const incoming = {
        messageId: uuidv4(),
        conversationId,
        hotelId,
        channel: "whatsapp" as const,
        sender: senderPhone,
        content: message.body,
        timestamp,
        time: await getLocalTime(hotelId, timestamp),
        suggestion: "",
        status: "pending" as const,
      };

      // üß† Guardamos el mensaje entrante
      channelMemory.addMessage(incoming);

      if (process.env.NODE_ENV !== "development") {
        await saveMessageToAstra(incoming);
      }

      // üî• Consultamos la configuraci√≥n real del hotel
      const hotelConfig = await getHotelConfig(hotelId);
      const mode = hotelConfig?.channelConfigs?.whatsapp?.mode ?? "automatic"; // fallback autom√°tico si falta config

      console.log(`‚öôÔ∏è [whatsapp] Modo de canal detectado: ${mode}`);

      // üîµ Invocamos el grafo
      const response = await agentGraph.invoke({
        hotelId,
        conversationId,
        messages: [new HumanMessage(message.body)],
      });

      const reply = response.messages.at(-1)?.content;

      if (typeof reply === "string" && reply.trim()) {
        if (mode === "automatic") {
          // üöÄ Responder directamente
          await message.reply(reply);
          console.log(`üì§ [whatsapp] Respuesta enviada a ${senderPhone}`);

          channelMemory.updateMessage("whatsapp", incoming.messageId, {
            suggestion: reply,
            status: "sent",
          });

          if (process.env.NODE_ENV !== "development") {
            await saveMessageToAstra({
              ...incoming,
              suggestion: reply,
              status: "sent",
            });
          }
        } else {
          // ‚úçÔ∏è Supervisado: Guardar sugerencia, pero NO responder todav√≠a
          channelMemory.updateMessage("whatsapp", incoming.messageId, {
            suggestion: reply,
            status: "pending",
          });

          if (process.env.NODE_ENV !== "development") {
            await saveMessageToAstra({
              ...incoming,
              suggestion: reply,
              status: "pending",
            });
          }

          console.log("üßç [whatsapp] Mensaje en modo supervisado. Pendiente de aprobaci√≥n.");
        }
      } else {
        console.warn("‚ö†Ô∏è [whatsapp] Respuesta vac√≠a o malformada.");
      }
    } catch (error) {
      console.error("‚õî [whatsapp] Error procesando mensaje:", error);
      await message.reply("‚ö†Ô∏è Hubo un error procesando tu solicitud.");
    }
  });

  client.initialize();
}

---------------------------------


üîπ Archivo: ./lib/services/webMemory.ts
---------------------------------
// /lib/services/webMemory.ts
import dotenv from "dotenv";
import type { Channel } from "@/types/channel";
dotenv.config();
const MAX_MESSAGES = process.env.MAX_MESSAGES || 100;
export type WebMessage = {
  id: string;
  sender: string;
  time: string;
  timestamp: string;
  content: string;
  suggestion: string;
  approvedResponse?: string;
  status?: "pending" | "approved" | "rejected" | "sent";
  edited?: boolean;
  respondedBy?: string; // üÜï email del asistente o recepcionista
  channel: Channel;
};




// ‚õëÔ∏è Aseguramos una √∫nica instancia viva durante dev (para mantener memoria compartida)
const globalKey = "__web_memory__";

if (!(globalThis as any)[globalKey]) {
  (globalThis as any)[globalKey] = {
    messages: [] as WebMessage[],
  };
}

const memory = (globalThis as any)[globalKey];

export const webMemory = {
  getMessages: (): WebMessage[] => {
    return memory.messages;
  },

  addMessage: (msg: WebMessage) => {
    memory.messages.push(msg);
    if (memory.messages.length > MAX_MESSAGES) {
      memory.messages = memory.messages.slice(-MAX_MESSAGES);
    }
  },

  updateMessage: (id: string, updates: Partial<WebMessage>): boolean => {
    const index = memory.messages.findIndex((m: WebMessage) => m.id === id);
    if (index !== -1) {
      memory.messages[index] = { ...memory.messages[index], ...updates };
      return true;
    }
    return false;
  },

  clearMessages: () => {
    memory.messages = [];
  },
};

---------------------------------


üîπ Archivo: ./lib/services/channelManagerMemory.ts
---------------------------------
// /lib/services/channelManagerMemory.ts

type Message = {
    id: string;
    sender: string;
    timestamp: string;
    content: string;
    suggestion: string;
    approvedResponse?: string;
    status: "pending" | "sent" | "rejected";
    edited?: boolean;
    respondedBy?: string;
  };
  
  const memory: Message[] = [
    {
      id: "cm-msg-1",
      sender: "Booking.com",
      timestamp: new Date().toISOString(),
      content: "¬øLa habitaci√≥n doble incluye estacionamiento?",
      suggestion: "S√≠, incluye estacionamiento gratuito para 1 veh√≠culo.",
      status: "pending",
    },
  ];
  
  export const channelManagerMemory = {
    getMessages: () => memory,
    updateMessage: (id: string, changes: Partial<Message>) => {
      const msg = memory.find((m) => m.id === id);
      if (!msg) return false;
      Object.assign(msg, changes);
      return true;
    },
  };
  
---------------------------------


üîπ Archivo: ./lib/services/whatsappClient.ts
---------------------------------
import { Client } from "whatsapp-web.js";
import puppeteer from "puppeteer";

export const whatsappClient = new Client({
  puppeteer: {
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    executablePath: puppeteer.executablePath(), // üëà Esto es lo clave
  },
});

---------------------------------


üîπ Archivo: ./lib/services/emailMemory.ts
---------------------------------
// /lib/services/emailMemory.ts

type Message = {
    id: string;
    sender: string;
    timestamp: string;
    content: string;
    suggestion: string;
    approvedResponse?: string;
    status: "pending" | "sent" | "rejected";
    edited?: boolean;
    respondedBy?: string;
  };
  
  const memory: Message[] = [
    {
      id: "email-msg-1",
      sender: "cliente@correo.com",
      timestamp: new Date().toISOString(),
      content: "¬øPuedo hacer check-in a las 10am?",
      suggestion: "Claro, el check-in temprano est√° sujeto a disponibilidad.",
      status: "pending",
    },
  ];
  
  export const emailMemory = {
    getMessages: () => memory,
    updateMessage: (id: string, changes: Partial<Message>) => {
      const msg = memory.find((m) => m.id === id);
      if (!msg) return false;
      Object.assign(msg, changes);
      return true;
    },
  };
  
---------------------------------


üîπ Archivo: ./lib/auth/findUserByEmail.ts
---------------------------------
// /lib/auth/findUserByEmail.ts

import { collection } from "@/lib/config/hotelConfig.server";
import { HotelUser } from "@/types/user";

/**
 * Busca TODOS los usuarios activos con login local por email,
 * en todos los hoteles, y retorna un array con hotelId.
 */
export async function findUserByEmail(email: string): Promise<(HotelUser & { hotelId: string })[]> {
  // Tra√© TODOS los hoteles (sin filtro por email)
  const cursor = await collection.find({});
  const docs = await cursor.toArray();

  const users: (HotelUser & { hotelId: string })[] = [];

  for (const doc of docs) {
    for (const u of doc.users ?? []) {
      if (
        u.email === email &&      // email exacto
        u.active === true &&      // solo activos
        !!u.passwordHash          // solo login local
      ) {
        users.push({ ...u, hotelId: doc.hotelId });
      }
    }
  }

  return users;
}

---------------------------------


üîπ Archivo: ./lib/auth/getCurrentUserEmail.ts
---------------------------------
// /lib/auth/getCurrentUserEmail.ts

export function getCurrentUserEmail(): string {
    // üß™ Simulaci√≥n actual para desarrollo
    return "recepcion@demo.com";
  
    // ‚úÖ En el futuro, podr√≠as reemplazar por:
    // return session?.user?.email ?? "asistente@hotel.com";
  }
  
---------------------------------


üîπ Archivo: ./lib/auth/jwt.ts
---------------------------------
// /root/begasist/lib/auth/jwt.ts
import { SignJWT, jwtVerify } from "jose";
import { NextRequest } from "next/server";

const secret = process.env.JWT_SECRET!;
const key = new TextEncoder().encode(secret);

export interface JWTPayload {
  email: string;
  hotelId: string;
  roleLevel: number;
  userId: string;
  exp?: number;
}

// Firmar un JWT v√°lido por 1 hora
export async function signJWT(payload: JWTPayload) {
  return new SignJWT(payload as JWTPayload & { [key: string]: unknown })
    .setProtectedHeader({ alg: "HS256" })
    .setExpirationTime("1h")
    .sign(key);
}

// Firmar un refresh token v√°lido por 7 d√≠as
export async function signRefreshToken(payload: JWTPayload) {
  return new SignJWT(payload as JWTPayload & { [key: string]: unknown })
    .setProtectedHeader({ alg: "HS256" })
    .setExpirationTime("7d")
    .sign(key);
}

// Verificar JWT (compatible con Edge Runtime)
export async function verifyJWT(token: string): Promise<JWTPayload | null> {
  try {
    const { payload } = await jwtVerify(token, key);
    return payload as unknown as JWTPayload;
  } catch (err) {
    console.warn("üîê JWT inv√°lido o expirado:", err);
    return null;
  }
}

// Verificar refresh token
export async function verifyRefreshToken(token: string): Promise<JWTPayload | null> {
  try {
    const { payload } = await jwtVerify(token, key);
    return payload as unknown as JWTPayload;
  } catch (err) {
    console.warn("üîÑ Refresh token inv√°lido o expirado:", err);
    return null;
  }
}

// ‚úÖ Nuevo: Verificar token + nivel de rol requerido (m√≠nimo o rango opcional)
export async function requireRoleLevel(req: NextRequest, minRoleLevel: number, maxRoleLevel?: number): Promise<JWTPayload> {
  const token = req.cookies.get("token")?.value;
  if (!token) {
    throw new Error("Token no encontrado");
  }

  const payload = await verifyJWT(token);
  if (!payload) {
    throw new Error("Token inv√°lido o expirado");
  }

  if (payload.roleLevel < minRoleLevel) {
    throw new Error("Permisos insuficientes");
  }

  if (maxRoleLevel !== undefined && payload.roleLevel > maxRoleLevel) {
    throw new Error("Permisos insuficientes (por nivel m√°ximo)");
  }

  return payload;
}

---------------------------------


üîπ Archivo: ./lib/auth/tokenUtils.ts
---------------------------------
// /root/begasist/lib/auth/tokenUtils.ts
import { randomBytes } from "crypto";

/**
 * Genera un token seguro en formato hexadecimal.
 */
export function generateToken(): string {
  return randomBytes(32).toString("hex");
}

---------------------------------


üîπ Archivo: ./lib/auth/getCurrentUser.ts
---------------------------------
// /lib/auth/getCurrentUser.ts
import { cookies } from "next/headers";
import { verifyJWT } from "@/lib/auth/jwt";
import { collection } from "@/lib/config/hotelConfig.server";
import type { CurrentUser } from "@/lib/context/UserContext";

export async function getCurrentUser(): Promise<CurrentUser | null> {
  const cookieStore = await cookies(); // ‚¨ÖÔ∏è Await cookies() since it returns a Promise
  const token = cookieStore.get("token")?.value;
  if (!token) return null;

  const payload = await verifyJWT(token);
  if (!payload) return null;

  const config = await collection.findOne({ hotelId: payload.hotelId });
  const hotelName = config?.hotelName || payload.hotelId;

  return {
    email: payload.email,
    hotelId: payload.hotelId,
    hotelName,
    roleLevel: payload.roleLevel,
    userId: payload.userId,
  };
}

---------------------------------


üîπ Archivo: ./lib/auth/verifyUserAccount.ts
---------------------------------
// /lib/auth/verifyUserAccount.ts
import { getAllHotelConfigs, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export type VerifyResult =
  | { ok: true; email: string; hotelId: string; roleLevel: number }
  | { ok: false; error: string };

export async function verifyUserAccount(token: string): Promise<VerifyResult> {
  const allConfigs = await getAllHotelConfigs();

  const hotel = allConfigs.find((cfg) =>
    cfg.users?.some((u) => u.verificationToken === token)
  );

  if (!hotel) {
    return { ok: false, error: "Token inv√°lido o expirado" };
  }

  const user = hotel.users!.find((u) => u.verificationToken === token);
  if (!user) {
    return { ok: false, error: "Token no v√°lido" };
  }

  user.active = true;
  delete user.verificationToken;

  await updateHotelConfig(hotel.hotelId, { users: hotel.users });

  return {
    ok: true,
    email: user.email,
    hotelId: hotel.hotelId,
    roleLevel: user.roleLevel,
  };
}

---------------------------------


üîπ Archivo: ./lib/auth/sendVerificationEmail.ts
---------------------------------
// /lib/auth/sendVerificationEmail.ts

import { buildVerificationUrl } from "@/lib/utils/buildVerificationUrl";
import nodemailer from "nodemailer";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";
import type { EmailSettings } from "@/types/channel";
export async function sendVerificationEmail({
  email,
  verificationToken,
  hotelId,
  emailSettings,
}: {
  email: string;
  verificationToken: string;
  hotelId: string;
  emailSettings: EmailSettings;
}) {
  // 1. Construir URL de verificaci√≥n (usando el helper ya existente)
  const verificationUrl = await buildVerificationUrl("verify-account", verificationToken, hotelId);

  
  if (!emailSettings) {
    throw new Error(`No hay configuraci√≥n de email para el hotel ${hotelId}`);
  }

  // 3. Configurar nodemailer con los datos del hotel
  const transporter = nodemailer.createTransport({
    host: emailSettings.smtpHost,
    port: emailSettings.smtpPort,
    secure: !!emailSettings.secure,
    auth: {
      user: emailSettings.emailAddress,
      pass: emailSettings.password,
    },
  });

  // 4. Enviar el email
  await transporter.sendMail({
    from: emailSettings.emailAddress,
    to: email,
    subject: "Activa tu cuenta de administrador",
    text: `Bienvenido/a, activa tu cuenta usando el siguiente enlace: ${verificationUrl}`,
    html: `<p>Bienvenido/a,<br>Para activar tu cuenta de administrador, haz clic aqu√≠:</p>
           <p><a href="${verificationUrl}">${verificationUrl}</a></p>`,
  });
}

---------------------------------


üîπ Archivo: ./lib/auth/roles.ts
---------------------------------
// /lib/auth/roles.ts

export enum RoleLevel {
  SuperAdmin = 0,        // Acceso total solo para hotelId 'system'
  SysAdmin = 0.1,        // Acceso admin a hoteles globales
  SysSupport = 0.2,      // Soporte hoteles globales
  HotelTechMin = 1,      // T√©cnicos hotel (sin acceso a hoteles globales)
  HotelTechMax = 9.99,
  HotelAdmin = 10,
  Reception = 20,
  Guest = 30,
}

/**
 * Solo hotelId === "system" puede tener usuarios con roleLevel 0.
 */
export function isRoleLevelZeroAllowed(hotelId: string, roleLevel: number): boolean {
  return !(roleLevel === 0 && hotelId !== "system");
}

// Usuarios de sistema (0, 0.1, 0.2)
export function isSystemUser(roleLevel: number): boolean {
  return roleLevel >= RoleLevel.SuperAdmin && roleLevel < RoleLevel.HotelTechMin;
}

// T√©cnicos de hotel (1 <= roleLevel < 10)
export function isHotelTech(roleLevel: number): boolean {
  return roleLevel >= RoleLevel.HotelTechMin && roleLevel < RoleLevel.HotelAdmin;
}

// Admins y superiores (10 <= roleLevel < 20)
export function isHotelAdmin(roleLevel: number): boolean {
  return roleLevel >= RoleLevel.HotelAdmin && roleLevel < RoleLevel.Reception;
}

// Recepcionistas (20)
export function isReception(roleLevel: number): boolean {
  return roleLevel === RoleLevel.Reception;
}

// Guest (30)
export function isGuest(roleLevel: number): boolean {
  return roleLevel === RoleLevel.Guest;
}

// --- CARD HELPERS ---
// Helpers para mostrar/ocultar tarjetas del dashboard
export function canSeeHotelsDashboard(roleLevel: number) {
  return isSystemUser(roleLevel);
}

export function canSeeUploadDashboard(roleLevel: number) {
  return !isReception(roleLevel) && !isGuest(roleLevel);
}

export function canSeeEmbeddingsDashboard(roleLevel: number) {
  return !isReception(roleLevel) && !isGuest(roleLevel);
}

export function canSeePromptsDashboard(roleLevel: number) {
  return isSystemUser(roleLevel);
}

export function canSeeChannelsDashboard(roleLevel: number) {
  return true; // Todos los usuarios pueden ver canales
}

export function canSeeLogsDashboard(roleLevel: number) {
  return isSystemUser(roleLevel);
}

export function canSeeUsersDashboard(roleLevel: number) {
  return !isReception(roleLevel) || isSystemUser(roleLevel);
}

// --- RUTA HELPERS (SIDEBAR, ETC) ---
export function canAccessHotelsSection(roleLevel: number) {
  return isSystemUser(roleLevel);
}
export function canAccessUploadSection(roleLevel: number) {
  return !isReception(roleLevel) && !isGuest(roleLevel);
}
export function canAccessEmbeddingsSection(roleLevel: number) {
  return !isReception(roleLevel) && !isGuest(roleLevel);
}
export function canAccessPromptsSection(roleLevel: number) {
  return isSystemUser(roleLevel);
}
export function canAccessChannelsSection(roleLevel: number) {
  return true;
}
export function canAccessLogsSection(roleLevel: number) {
  return isSystemUser(roleLevel);
}
export function canAccessUsersSection(roleLevel: number) {
  return !isReception(roleLevel) || isSystemUser(roleLevel);
}
export function canAccessChangePasswordSection(roleLevel: number) {
  return true;
}

// Solo usuarios de sistema (0), t√©cnicos (<10), admins (10-19) pueden acceder a rutas admin generales
export function canAccessAdminRoute(roleLevel: number, pathname: string) {
  if (roleLevel < RoleLevel.Reception) return true; // Admins, t√©cnicos, gerentes pueden acceder a todo
  // Solo canales y cambio de password para recepcionistas
  if (
    pathname.startsWith("/admin/channels") ||
    pathname.startsWith("/auth/change-password") ||
    pathname === "/admin"
  ) {
    return true;
  }
  return false;
}

---------------------------------


üîπ Archivo: ./lib/classifier/categoryAliases.ts
---------------------------------
// /lib/classifier/categoryAliases.ts
const CATEGORY_ALIASES: Record<string, string> = {
    cancellation: "reservation",
    // futuros alias
    checkin: "reservation",
    checkout: "reservation",
    modification: "reservation",
  };
  
  export function normalizeCategory(category: string): string {
    return CATEGORY_ALIASES[category] ?? category;
  }
  
---------------------------------


üîπ Archivo: ./lib/classifier/index.ts
---------------------------------
import { ChatOpenAI } from "@langchain/openai";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";
import { normalizeCategory } from "./categoryAliases";
export type Classification = {
  category: string;
  promptKey?: string | null;
};
process.env.OPENAI_LOG = "off";

const classifierModel = new ChatOpenAI({
  modelName: "gpt-3.5-turbo",
  temperature: 0,
});

export async function classifyQuery(question: string): Promise<Classification> {
  const allowedCategories = Object.keys(promptMetadata).join(", ");
  const allPromptKeys = Object.entries(promptMetadata)
    .flatMap(([_, keys]) => keys)
    .filter(Boolean);

  const prompt = `
Dada la siguiente consulta del usuario, responde solo con un JSON v√°lido con dos campos:

- "category": una de las siguientes: ${allowedCategories}
- "promptKey": si la categor√≠a necesita un prompt curado especial, elige una de: [${allPromptKeys.join(", ")}]; si no, pon null.

Ejemplo de respuesta:
{
  "category": "retrieval_based",
  "promptKey": "room_info"
}

Consulta:
"${question}"
`.trim();

  const res = await classifierModel.invoke([{ role: "user", content: prompt }]);

  try {
    const parsed = JSON.parse(res.content as string);
    let { category, promptKey } = parsed;
      // üîÑ Normalizar la categor√≠a
    category = normalizeCategory(category);
    if (!promptMetadata[category]) {
      throw new Error(`‚ùå Categor√≠a inv√°lida detectada: ${category}`);
    }

    const isValidPrompt = promptKey === null || promptMetadata[category].includes(promptKey);
    if (!isValidPrompt) {
      throw new Error(`‚ùå Prompt key inv√°lido: ${promptKey} para categor√≠a: ${category}`);
    }

    debugLog("üß† Clasificaci√≥n final:", { category, promptKey });
    return { category, promptKey };
  } catch (e) {
    console.error("‚ùå Error al parsear o validar respuesta del clasificador:", res.content);
    return { category: "retrieval_based", promptKey: null };
  }
}

---------------------------------


üîπ Archivo: ./lib/pms/index.ts
---------------------------------
export type ReservationStatus = "confirmed" | "cancelled";

export interface Reservation {
  guest: string;
  roomType: string;
  checkIn: string;
  checkOut: string;
  status: ReservationStatus;
}

export class PMS {
  private reservations: Record<string, Reservation> = {}; // üî• Reemplazamos `any` por `Reservation`

  createReservation(guest: string, roomType: string, checkIn: string, checkOut: string): Reservation & { id: string } {
    const id = `res-${Date.now()}`;
    this.reservations[id] = { guest, roomType, checkIn, checkOut, status: "confirmed" };
    return { id, ...this.reservations[id] };
  }

  getReservation(id: string): Reservation | null {
    return this.reservations[id] || null;
  }

  cancelReservation(id: string): Reservation | null {
    if (this.reservations[id]) {
      this.reservations[id].status = "cancelled";
      return this.reservations[id];
    }
    return null;
  }
}

export const pms = new PMS();

---------------------------------


üîπ Archivo: ./lib/email/sendRecoveryEmail.ts
---------------------------------
// /lib/email/sendRecoveryEmail.ts
import { buildVerificationUrl } from "@/lib/utils/buildVerificationUrl";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";
import { sendEmail } from "@/lib/email/sendEmail";

/**
 * Env√≠a email de recuperaci√≥n de contrase√±a.
 */
export async function sendRecoveryEmail(options: { email: string; token: string; hotelId: string }) {
  const { email, token, hotelId } = options;

  const recoveryUrl = await buildVerificationUrl("reset-password", token, hotelId);

  const config = await getHotelConfig(hotelId);
  if (!config?.emailSettings) {
    throw new Error(`Configuraci√≥n de email no encontrada para hotel ${hotelId}`);
  }

  const subject = `üîë Recuperaci√≥n de contrase√±a - ${config.hotelName || "Hotel Assistant"}`;
  const html = `
    <p>Hola,</p>
    <p>Has solicitado restablecer tu contrase√±a.</p>
    <p>Haz clic en el siguiente enlace para continuar:</p>
    <p><a href="${recoveryUrl}" target="_blank">${recoveryUrl}</a></p>
    <p>Este enlace expirar√° en 2 horas.</p>
    <p>Si no solicitaste esta acci√≥n, puedes ignorar este mensaje.</p>
    <br>
    <p>‚Äî El equipo de soporte</p>
  `;

  await sendEmail(
    {
      host: config.emailSettings.smtpHost,
      port: config.emailSettings.smtpPort,
      user: config.emailSettings.emailAddress,
      pass: config.emailSettings.password,
      secure: config.emailSettings.secure ?? false,
    },
    email,
    subject,
    html
  );
}

---------------------------------


üîπ Archivo: ./lib/email/sendEmail.ts
---------------------------------
// /lib/email/sendEmail.ts
import nodemailer from "nodemailer";

type SMTPConfig = {
  host: string;
  port: number;
  user: string;
  pass: string;
  secure?: boolean;
};

export async function sendEmail(
  smtp: SMTPConfig,
  to: string,
  subject: string,
  html: string
) {
  const transporter = nodemailer.createTransport({
    host: smtp.host,
    port: smtp.port,
    secure: smtp.secure ?? false,
    auth: {
      user: smtp.user,
      pass: smtp.pass,
    },
  });

  await transporter.sendMail({
    from: `"Hotel Assistant" <${smtp.user}>`,
    to,
    subject,
    html,
  });
}

---------------------------------


üîπ Archivo: ./lib/prompts/promptMetadata.ts
---------------------------------
// lib/prompts/promptMetadata.ts

/**
 * Define qu√© promptKeys son v√°lidas para cada categor√≠a.
 * Esto evita que el clasificador invente claves y permite escalar de forma controlada.
 */
export const promptMetadata: Record<string, string[]> = {
    retrieval_based: ["room_info"],
    reservation: [],
    amenities: [],
    billing: [],
    support: [],
  };
  
  
---------------------------------


üîπ Archivo: ./lib/prompts/index.ts
---------------------------------
// lib/prompts/index.ts

// üß† Prompt gen√©rico
export const defaultPrompt = `
Responde la siguiente consulta usando exclusivamente la informaci√≥n proporcionada.

- S√© claro y profesional.
- Si no hay suficiente informaci√≥n, responde con cortes√≠a sin inventar.

Informaci√≥n disponible:

{{retrieved}}

Consulta del usuario: "{{query}}"
`.trim();

// üè® Prompts curados por clave
export const curatedPrompts: Record<string, string> = {
  room_info: `
Usa la siguiente informaci√≥n del hotel para responder de manera clara y bien estructurada.

**Formato requerido:**
- Usa **Markdown** con listas y tablas para alineaci√≥n.
- La tabla **sin l√≠neas de separaci√≥n entre filas**.
- Usa t√≠tulos en **negrita** con el emoji üè® antes del nombre de la habitaci√≥n.
- **A√±ade un doble salto de l√≠nea entre cada tipo de habitaci√≥n.**
- **Finaliza con una invitaci√≥n a reservar.**

Ejemplo de formato esperado:
\`\`\`md
**üè® Habitaci√≥n Doble**  

| üõèÔ∏è  1 cama doble      | üìè √Årea de 17 metros cuadrados |  
| üöø Ba√±o privado       | üìû Tel√©fono                    |  
| üì∫ TV LCD             | üíá‚Äç‚ôÄÔ∏è Secador de pelo             |  
| ‚ùÑÔ∏è Aire acondicionado | üì∂ WiFi gratis                 |  
| üîí Caja fuerte        | üö≠ No fumadores                |  
| üõÅ Toallas            | üî• Calefacci√≥n                 |  

<br><br>

**üè® Habitaci√≥n Triple**  

| üõèÔ∏è  1 cama doble y 1 simple   | üìè √Årea de 23 metros cuadrados |  
| üöø Ba√±o privado               | üìû Tel√©fono                    |  
| üì∫ TV LCD                     | üíá‚Äç‚ôÄÔ∏è Secador de pelo             |  
| ‚ùÑÔ∏è Aire acondicionado         | üì∂ WiFi gratis                 |  
| üîí Caja fuerte                | üö≠ No fumadores                |  
| üõÅ Toallas                    | üî• Calefacci√≥n                 |  

<br><br>

üìÖ **¬°Reserva ahora para obtener el mejor precio!** üí∞  
üîó [Haz clic aqu√≠ para reservar](https://booking.bedzzle.com/desktop/?&apikey=6177b98dc5c442893dd76be7da149008&lang=es)
\`\`\`

**Aqu√≠ est√° la informaci√≥n relevante del hotel:**  

{{retrieved}}

**Aseg√∫rate de seguir estrictamente este formato.**
`, 
};

---------------------------------


üîπ Archivo: ./lib/retrieval/getHotelChunks.ts
---------------------------------
// /lib/retrieval/getHotelChunks.ts
import { getHotelAstraCollection } from "../astra/connection";

/**
 * Devuelve todos los chunks vectorizados para un hotel.
 * Se puede agregar paginaci√≥n/l√≠mites.
 */
export async function getHotelChunks(hotelId: string, opts: { limit?: number } = {}) {
  const collection = getHotelAstraCollection(hotelId);
  // Pod√©s limitar la cantidad si te preocupa el volumen
  const cursor = await collection.find({ hotelId }, { limit: opts.limit ?? 1000 });
  const docs = await cursor.toArray();
  return docs;
}

---------------------------------


üîπ Archivo: ./lib/retrieval/deleteVersionForHotel.ts
---------------------------------
// /lib/retrieval/deleteVersionForHotel.ts
import { DataAPIClient } from "@datastax/astra-db-ts";
import { getCollectionName } from "./index";
import dotenv from "dotenv";
dotenv.config();

export async function deleteVersionForHotel(hotelId: string, version: string) {
  const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
  const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
  const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN!);
  const db = client.db(ASTRA_DB_URL!, { keyspace: ASTRA_DB_KEYSPACE! });
  const collectionName = getCollectionName(hotelId);
  const collection = await db.collection(collectionName);

  const result = await collection.deleteMany({ hotelId, version });
  return { deletedCount: result.deletedCount, version };
}

---------------------------------


üîπ Archivo: ./lib/retrieval/listVersionsForHotel.ts
---------------------------------
// /lib/retrieval/listVersionsForHotel.ts

import { DataAPIClient } from "@datastax/astra-db-ts";
import dotenv from "dotenv";
dotenv.config();

export async function listVersionsForHotel(hotelId: string) {
  const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
  const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
  const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;

  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
  const collectionName = `${hotelId}_collection`;
  const collection = await db.collection(collectionName);

  // 1. Traer solo los campos version y uploadedAt
  const cursor = await collection.find(
    { hotelId },
    { projection: { version: 1, uploadedAt: 1 } }
  );
  const allDocs = await cursor.toArray();

  // 2. Agrupar por versi√≥n en memoria
  const versionsMap: Record<string, { count: number; latestUploadedAt: string }> = {};
  for (const doc of allDocs) {
    const v = doc.version || "sin_version";
    if (!versionsMap[v]) {
      versionsMap[v] = { count: 1, latestUploadedAt: doc.uploadedAt };
    } else {
      versionsMap[v].count += 1;
      // Guardamos la fecha m√°s nueva
      if (doc.uploadedAt && doc.uploadedAt > versionsMap[v].latestUploadedAt) {
        versionsMap[v].latestUploadedAt = doc.uploadedAt;
      }
    }
  }

  // 3. Devuelve como array ordenado descendente por fecha
  return Object.entries(versionsMap)
    .map(([version, data]) => ({
      version,
      numChunks: data.count,
      latestUploadedAt: data.latestUploadedAt,
    }))
    .sort((a, b) => b.latestUploadedAt.localeCompare(a.latestUploadedAt));
}

---------------------------------


üîπ Archivo: ./lib/retrieval/rollbackVersionForHotel.ts
---------------------------------
// /lib/retrieval/rollbackVersionForHotel.ts

import { DataAPIClient } from "@datastax/astra-db-ts";
import dotenv from "dotenv";
dotenv.config();

export async function rollbackVersionForHotel(
  hotelId: string,
  sourceVersion: string,
  targetVersion?: string,   // opcional, si quer√©s customizar el nombre
  restoredBy: string = "system"
) {
  const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
  const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
  const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;

  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
  const collectionName = `${hotelId}_collection`;
  const collection = await db.collection(collectionName);

  // 1. Traer los chunks originales de la versi√≥n fuente
  const docs = await collection.find({ hotelId, version: sourceVersion }).toArray();
  if (!docs.length) throw new Error(`No hay chunks para version: ${sourceVersion}`);

  // 2. Definir nueva versi√≥n
  const now = new Date().toISOString();
  const newVersion =
    targetVersion ||
    "rollback-" + sourceVersion + "-" + now.slice(0, 10) + "-" + now.slice(11, 19).replace(/:/g, "");

  // 3. Clonar los chunks con nueva versi√≥n y nueva marca de fecha
  let inserted = 0;
  for (const doc of docs) {
    const {
      _id,    // nunca copiar _id
      ...rest
    } = doc;
    await collection.insertOne({
      ...rest,
      version: newVersion,
      uploadedAt: now,
      restoredFrom: sourceVersion,
      restoredBy,
    });
    inserted++;
  }

  return {
    ok: true,
     restoredChunks: inserted,
    newVersion,
  };
}

---------------------------------


üîπ Archivo: ./lib/retrieval/validateClassification.ts
---------------------------------
type Classification = {
    category: string;
    promptKey: string | null;
  };
  
  const validCategories = [
    "reservation",
    "billing",
    "support",
    "amenities",
    "retrieval_based",
  ];
  
  export function validateClassification(item: any): Classification {
    const fallback: Classification = {
      category: "retrieval_based",
      promptKey: null,
    };
  
    if (!item || typeof item !== "object") return fallback;
  
    const { category, promptKey } = item;
  
    const isValidCategory = validCategories.includes(category);
    const isValidPromptKey =
      promptKey === null || typeof promptKey === "string";
  
    return {
      category: isValidCategory ? category : fallback.category,
      promptKey: isValidPromptKey ? promptKey : fallback.promptKey,
    };
  }
  
---------------------------------


üîπ Archivo: ./lib/retrieval/index.ts
---------------------------------
// /root/begasist/lib/retrieval/index.ts
import puppeteer from "puppeteer-extra";
import { Document } from "@langchain/core/documents";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import { OpenAIEmbeddings } from "@langchain/openai";
import { translationModel } from "../../app/lib/translation";
import { debugLog } from "../utils/debugLog";
import { ChatOpenAI } from "@langchain/openai";
import { validateClassification } from "./validateClassification";
import fs from "fs";
import { cosineSimilarity } from "../utils/similarity";
import type { ChunkResult, InsertableChunk, SearchFilters } from "../../types/chunk";
import pdfParse from "pdf-parse";
import dotenv from "dotenv";
import { getHotelAstraCollection } from "../astra/connection";
import { getHotelConfig } from "../config/hotelConfig.server";
import { franc } from "franc";
import { iso3To1 } from "@/lib/utils/lang";
import { Collection, FoundDoc } from "@datastax/astra-db-ts";
dotenv.config();

const urls = ["https://www.hoteldemo.com/en/index.php"];
export function getCollectionName(hotelId: string) {
  return `${hotelId}_collection`;
}
const curationAssistant = new ChatOpenAI({
  modelName: "gpt-4",
  temperature: 0,
});

const classificationPrompt = `
Eres un experto en hospitalidad. Vas a clasificar fragmentos de texto provenientes de documentos de hoteles en una de las siguientes categor√≠as:

- reservation
- billing
- support
- amenities
- retrieval_based

Adem√°s, si corresponde, asignar√°s una clave de prompt especializada (promptKey) como por ejemplo: room_info, cancellation_policy, breakfast_details, etc. Si no hay un promptKey aplicable, devu√©lvelo como null.

Devuelve **exclusivamente** un JSON v√°lido con esta estructura (una lista con un objeto por fragmento):

[
  {
    "category": "reservation",
    "promptKey": "cancellation_policy"
  },
  ...
]

Ahora analiza los siguientes fragmentos:

{fragments}
`;

// Traducci√≥n robusta a cualquier idioma destino (usada abajo)
async function translateTextToLang(text: string, lang: string) {
  try {
    const translated = await translationModel(text, lang);
    if (typeof translated.content === "string") {
      return translated.content;
    }
    return JSON.stringify(translated.content);
  } catch (err) {
    debugLog("‚ùå Error en traducci√≥n:", err);
    return text; // fallback al texto original
  }
}

/**
 * Calcula la pr√≥xima versi√≥n ("v1", "v2", ...) seg√∫n los documentos ya presentes
 * Ahora: busca la versi√≥n m√°xima en TODA la colecci√≥n, no solo por originalName
 */
async function getNextVersionForCollection(collection: any, hotelId: string) {
  const docs = await collection.find({ hotelId }).toArray();
  let maxVersion = 0;
  for (const doc of docs) {
    const m = (doc.version || "").match(/^v(\d+)$/);
    if (m) {
      const n = parseInt(m[1], 10);
      if (n > maxVersion) maxVersion = n;
    }
  }
  return `v${maxVersion + 1}`;
}

export async function loadDocumentFileForHotel({
  hotelId,
  filePath,
  originalName,
  uploader,
  mimeType,
  metadata = {},
}: {
  hotelId: string;
  filePath: string;
  originalName: string;
  uploader: string;
  mimeType?: string;
  metadata?: Record<string, any>;
}) {
  // 1. Leer y extraer texto (PDF o TXT)
  let text = "";
  if (mimeType?.includes("pdf") || filePath.endsWith(".pdf")) {
    const buffer = fs.readFileSync(filePath);
    const pdfData = await pdfParse(buffer);
    text = pdfData.text;
  } else if (mimeType?.includes("text") || filePath.endsWith(".txt")) {
    text = fs.readFileSync(filePath, "utf8");
  } else {
    throw new Error("Formato no soportado. Solo PDF/TXT por ahora.");
  }

  // 2. Detecci√≥n y normalizaci√≥n de idioma (usa franc ‚Üí iso3 ‚Üí iso1)
  let translatedText = text;
  let detectedLang3 = "und";
  let detectedIso1 = "und";
  let targetLang = "es";
  try {
    const config = await getHotelConfig(hotelId);
    targetLang = config?.defaultLanguage || "es";
    detectedLang3 = franc(text); // ej: "spa"
    detectedIso1 = await iso3To1(detectedLang3); // ej: "es"

    debugLog(`[Vectorizaci√≥n] Idioma detectado (franc/iso3): ${detectedLang3}, iso1: ${detectedIso1}, destino: ${targetLang}`);
    // Si el idioma detectado es distinto al objetivo, traducir
    if (targetLang && detectedIso1 !== "und" && detectedIso1 !== targetLang) {
      debugLog("[Vectorizaci√≥n] Traduciendo texto al idioma destino‚Ä¶");
      translatedText = await translateTextToLang(text, targetLang);
    } else {
      debugLog("[Vectorizaci√≥n] No es necesario traducir.");
    }
  } catch (err) {
    debugLog("‚ö†Ô∏è No se pudo obtener idioma destino desde config o traducir:", err);
  }

  // 3. Chunking
  const splitter = new RecursiveCharacterTextSplitter({ chunkSize: 1500, chunkOverlap: 200 });
  const chunks = await splitter.createDocuments([translatedText]);

  // 4. Vectorizaci√≥n y guardado
  const embedder = new OpenAIEmbeddings();
  const collection = getHotelAstraCollection<InsertableChunk>(hotelId);

  const now = new Date().toISOString();

  // ‚≠êÔ∏è Obt√©n autom√°ticamente la siguiente versi√≥n
  const versionTag = await getNextVersionForCollection(collection, hotelId);

  for (const [i, doc] of chunks.entries()) {
    const embedding = await embedder.embedQuery(doc.pageContent);
    const record = {
      hotelId,
      category: doc.metadata.category || metadata.category || "retrieval_based",
      promptKey: doc.metadata.promptKey ?? metadata.promptKey ?? null,
      version: versionTag,
      author: metadata.author ?? null,
      uploader,
      text: doc.pageContent,
      $vector: embedding,
      uploadedAt: now,
      doc_json: JSON.stringify({
        ...doc,
        ...metadata,
        chunkIndex: i,
        originalName,
        uploader,
        mimeType,
        uploadedAt: now,
        version: versionTag,
        detectedLang: detectedIso1,   // ‚Üê ISO 639-1
        targetLang,
      }),
      originalName,
      detectedLang: detectedIso1,     // ‚Üê ISO 639-1
      targetLang,
    };
    await collection.insertOne(record);
  }

  return { ok: true, count: chunks.length, version: versionTag };
}

// --- El resto de helpers y retrieval (sin cambios importantes) ---

async function classifyFragmentsWithCurationAssistant(documents: Document[]): Promise<Document[]> {
  const inputChunks = documents.map((doc) => doc.pageContent);
  const promptText = classificationPrompt.replace(
    "{fragments}",
    inputChunks.map((t, i) => `Fragmento ${i + 1}: """${t}"""`).join("\n\n")
  );
  fs.writeFileSync("prompt-clasificador.txt", promptText, "utf8");
  console.log("üß† Prompt guardado en prompt-clasificador.txt");

  const response = await curationAssistant.invoke([{ role: "user", content: promptText }]);

  function extractTextContent(content: any): string {
    if (typeof content === "string") return content;
    if (Array.isArray(content)) {
      return content.map((c) => c?.text || "").join("\n");
    }
    return JSON.stringify(content);
  }

  let parsed: any[] = [];
  try {
    parsed = JSON.parse(extractTextContent(response.content) || "[]");
  } catch (e) {
    debugLog("‚õî Error al parsear JSON del clasificador:", e);
  }
  fs.writeFileSync("parsed-completo.json", JSON.stringify(parsed, null, 2));

  return documents.map((doc, i) => {
    const classification = validateClassification(parsed[i] || {});
    return new Document({
      pageContent: doc.pageContent,
      metadata: {
        ...doc.metadata,
        category: classification.category,
        promptKey: classification.promptKey,
      },
    });
  });
}

async function fetchPageWithPuppeteer(url: string): Promise<string | null> {
  debugLog("üåê Cargando p√°gina con Puppeteer:", url);
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  const page = await browser.newPage();
  try {
    await page.goto(url, { waitUntil: "networkidle2", timeout: 120000 });
    await page.waitForSelector("body", { timeout: 120000 });
    return await page.evaluate(() => document.body.innerText);
  } catch (error) {
    debugLog("‚ùå Error en Puppeteer:", error);
    return null;
  } finally {
    await browser.close();
  }
}

export async function translateText(text: string) {
  try {
    const lang = process.env.SYSTEM_NATIVE_LANGUAGE;
    if (!lang) throw new Error("SYSTEM_NATIVE_LANGUAGE is not defined in .env");
    const translated = await translationModel(text, lang);
    return typeof translated.content === "string"
      ? translated.content
      : JSON.stringify(translated.content);
  } catch (error) {
    debugLog("‚õî Error en traducci√≥n:", error);
    return text;
  }
}

export async function loadDocuments(
  hotelId: string,
  opts: { version?: string } = {}
) {
  debugLog(`üì¶ Cargando documentos para hotel ${hotelId}`);

  const version = opts.version ?? "v1";

  const docs = await Promise.all(
    urls.map(async (url) => {
      const html = await fetchPageWithPuppeteer(url);
      if (!html) return null;
      const translated = await translateText(html);
      return new Document<{ source: string; hotelId: string }>({
        pageContent: translated,
        metadata: { source: url, hotelId },
      });
    })
  );

  const validDocs = docs.filter((d): d is Document<{ source: string; hotelId: string }> => d !== null);

  const splitter = new RecursiveCharacterTextSplitter({ chunkSize: 1500, chunkOverlap: 200 });
  const chunks = await splitter.splitDocuments(validDocs);

  const enrichedChunks = await classifyFragmentsWithCurationAssistant(chunks);

  const embedder = new OpenAIEmbeddings();
  const collection = getHotelAstraCollection<InsertableChunk>(hotelId);

  for (const doc of enrichedChunks) {
    const embedding = await embedder.embedQuery(doc.pageContent);
    if (!doc.metadata.hotelId || !doc.metadata.category) {
      throw new Error("Faltan hotelId o category en el metadata del chunk.");
    }
    await collection.insertOne({
      hotelId,
      category: doc.metadata.category || "retrieval_based",
      promptKey: doc.metadata.promptKey ?? null,
      text: doc.pageContent,
      $vector: embedding,
      version,
      ...doc.metadata,
    });
  }

  debugLog(`‚úÖ Insertados ${enrichedChunks.length} chunks en colecci√≥n ${hotelId}_collection`);
}

async function getLatestVersionForHotel(collection: any, hotelId: string) {
  const docs = await collection.find({ hotelId }).toArray();
  const byVersion = new Map<string, { version: string, uploadedAt: string }>();
  for (const doc of docs) {
    if (
      !byVersion.has(doc.version) ||
      new Date(doc.uploadedAt) > new Date(byVersion.get(doc.version)!.uploadedAt)
    ) {
      byVersion.set(doc.version, { version: doc.version, uploadedAt: doc.uploadedAt });
    }
  }
  const grouped = Array.from(byVersion.values()).sort(
    (a, b) => new Date(b.uploadedAt).getTime() - new Date(a.uploadedAt).getTime()
  );
  return grouped[0]?.version;
}

export async function searchFromAstra(
  query: string,
  hotelId: string = "hotel123",
  filters: SearchFilters = {}
) {
  if (!hotelId || hotelId === "hotel123") {
    console.warn("‚ö†Ô∏è [searchFromAstra] hotelId no proporcionado, usando fallback: 'hotel123'");
  }
  const embedder = new OpenAIEmbeddings();
  const queryVector = await embedder.embedQuery(query);

  const collection = getHotelAstraCollection<ChunkResult>(hotelId);

  // üëâ Nueva l√≥gica de versi√≥n
  let version = filters.version;
  if (!version) {
    version = await getLatestVersionForHotel(collection, hotelId);
    debugLog("üîÑ Usando versi√≥n m√°s reciente:", version);
  }
  const baseFilter: Record<string, any> = { hotelId };
  if (version) baseFilter.version = version;

  // üß† Primer intento: por promptKey (si est√°)
  if (filters.promptKey) {
    const promptKeyFilter = {
      ...baseFilter,
      promptKey: filters.promptKey,
    };
    debugLog("üîç Filtro por promptKey:", promptKeyFilter);

    const cursor = await collection.find(promptKeyFilter, {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    });
    const results = await cursor.toArray();
    if (results.length > 0) {
      return results.map((r: any) => r.text);
    }
  }

  // üåÄ No hubo resultados ‚Üí intentar por category si existe
  if (filters.category) {
    const categoryFilter = {
      ...baseFilter,
      category: filters.category,
    };
    debugLog("üîÅ Fallback por category:", categoryFilter);

    const fallbackCursor = await collection.find(categoryFilter, {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    });

    type WithSim<T> = {
      document: T;
      similarity: number;
    };

    type FoundDoc<T> = {
      document: T;
    };

    type ChunkResult = {
      _id: string;
      text: string;
      $vector: number[];
      $similarity?: number;
      [key: string]: any;
    };

    const rawFallbackResults = await fallbackCursor.toArray() as unknown as WithSim<FoundDoc<ChunkResult>>[];

    const fallbackResults: ChunkResult[] = rawFallbackResults
      .filter(r => r?.document?.document)
      .map(r => ({
        ...r.document.document,
        $similarity: r.similarity,
      }));

    debugLog("üîÅ FallbackResults por category:", fallbackResults);

    for (const r of fallbackResults) {
      if (!Array.isArray(r.$vector)) {
        console.warn("‚ö†Ô∏è Chunk con vector inv√°lido:", r);
      }
    }

    const SIMILARITY_THRESHOLD = 0.95;

    const relevantResults = fallbackResults
      .filter((r) => Array.isArray(r.$vector) && r.$vector.length === queryVector.length)
      .map((r) => ({
        ...r,
        semanticRelevance: cosineSimilarity(queryVector, r.$vector),
      }))
      .filter((r) => r.semanticRelevance > SIMILARITY_THRESHOLD)
      .sort((a, b) => b.semanticRelevance - a.semanticRelevance);

    if (relevantResults.length > 0) {
      debugLog("‚úÖ Resultados relevantes por similitud sem√°ntica:", relevantResults);
      return relevantResults.map((r) => r.text);
    }

    console.warn("‚ö†Ô∏è Ning√∫n resultado con buena similitud. Reintentando sin filtros...");
  }

  // üîö Sin promptKey ni category ‚Üí buscar solo por hotelId y version
  debugLog("üîç B√∫squeda sin filtro adicional (hotelId + version):", baseFilter);
  const fallbackCursor = await collection.find(
    baseFilter,
    {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    }
  );
  const fallbackResults = await fallbackCursor.toArray();

  return fallbackResults.map((r: any) => r.text);
}

---------------------------------


üîπ Archivo: ./lib/db/messages.ts
---------------------------------
// /lib/db/messages.ts (refactorizado con tipado fuerte)

import { DataAPIClient } from "@datastax/astra-db-ts";
import * as dotenv from "dotenv";

import type { Channel } from "@/types/channel";
import type { ChannelMessage, MessageStatus } from "@/types/channel";
dotenv.config();

const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
const MESSAGES_COLLECTION = "messages";

export const getCollection = () => {
  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
  return db.collection<ChannelMessage>(MESSAGES_COLLECTION);
};

export async function saveMessageToAstra(message: ChannelMessage) {
  try {
    const collection = getCollection();
    await collection.insertOne(message);
    console.log("‚úÖ Mensaje guardado en Astra DB:", message.messageId);
  } catch (err) {
    console.error("‚ùå Error guardando el mensaje en Astra DB:", err);
    throw err;
  }
}

export async function getMessagesFromAstra(hotelId: string, channel: Channel, limit = 100) {
  try {
    const collection = getCollection();
    const cursor = await collection.find(
      { hotelId, channel },
      { sort: { timestamp: -1 }, limit }
    );
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes desde AstraDB:", err);
    throw err;
  }
}

export async function updateMessageInAstra(
  hotelId: string,
  messageId: string,
  changes: Partial<ChannelMessage>
) {
  try {
    const collection = getCollection();
    const result = await collection.updateOne(
      { hotelId, messageId }, // ‚úÖ se asegura que el mensaje pertenece a ese hotel
      { $set: changes }
    );

    if (result.matchedCount === 0) {
      console.warn(`‚ö†Ô∏è No se encontr√≥ el mensaje ${messageId} para hotel ${hotelId}`);
      return false;
    }

    console.log("üîÅ Mensaje actualizado en Astra DB:", messageId);
    return true;
  } catch (err) {
    console.error("‚ùå Error actualizando el mensaje en Astra DB:", err);
    throw err;
  }
}


export async function deleteMessageFromAstra(messageId: string) {
  try {
    const collection = getCollection();
    await collection.deleteOne({ messageId });
    console.log("üóëÔ∏è Mensaje eliminado de Astra DB:", messageId);
  } catch (err) {
    console.error("‚ùå Error eliminando el mensaje de Astra DB:", err);
    throw err;
  }
}

export async function getMessagesFromAstraByHotelId(hotelId: string) {
  try {
    const collection = getCollection();
    const cursor = await collection.find({ hotelId });
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes desde AstraDB:", err);
    throw err;
  }
}

export async function getMessagesFromAstraByHotelIdAndChannel(hotelId: string, channel: Channel) {
  try {
    const collection = getCollection();
    const cursor = await collection.find({ hotelId, channel });
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes desde AstraDB:", err);
    throw err;
  }
}

export async function deleteTestMessagesFromAstra() {
  try {
    const collection = getCollection();
    const cursor = await collection.find({});
    const allMessages = await cursor.toArray();

    const messageIdsToDelete = allMessages
      .filter((msg) => msg.messageId?.startsWith("test-") || msg.messageId?.startsWith("msg-"))
      .map((msg) => msg.messageId);

    if (messageIdsToDelete.length === 0) {
      console.log("‚ÑπÔ∏è No hay mensajes de prueba para eliminar.");
      return { deletedCount: 0 };
    }

    const result = await collection.deleteMany({ messageId: { $in: messageIdsToDelete } });
    console.log(`üßπ Mensajes de prueba eliminados: ${result.deletedCount}`);
    return result;
  } catch (err) {
    console.error("‚ùå Error al eliminar mensajes de prueba de Astra DB:", err);
    throw err;
  }
}

export async function getMessagesFromAstraByHotelIdAndChannelAndStatus(
  hotelId: string,
  channel: Channel,
  status: MessageStatus
) {
  try {
    const collection = getCollection();
    const cursor = await collection.find({ hotelId, channel, status });
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes desde AstraDB:", err);
    throw err;
  }
}

export async function getMessagesFromAstraByHotelIdAndChannelAndSender(
  hotelId: string,
  channel: Channel,
  sender: string
) {
  try {
    const collection = getCollection();
    const cursor = await collection.find({ hotelId, channel, sender });
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes desde AstraDB:", err);
    throw err;
  }
}
export async function getMessagesFromAstraByConversation(
  hotelId: string,
  channel: Channel,
  conversationId: string
) {
  try {
    const collection = getCollection();
    const cursor = await collection.find({ hotelId, channel, conversationId });
    return await cursor.toArray();
  } catch (err) {
    console.error("‚ùå Error al obtener mensajes por conversaci√≥n desde Astra DB:", err);
    throw err;
  }
}

---------------------------------


üîπ Archivo: ./lib/db/getHotelsForUser.ts
---------------------------------
// /lib/db/getHotelsForUser.ts

import { collection } from "@/lib/config/hotelConfig.server";

/**
 * Devuelve todos los hoteles donde el userId existe y est√° activo.
 */
export async function getHotelsForUser(
  userId: string
): Promise<{ hotelId: string; name: string }[]> {
  const results = await collection
    .find({ "users.userId": userId })
    .toArray();

  // Solo hoteles donde el user est√° activo
  return results
    .filter((doc: any) =>
      Array.isArray(doc.users) &&
      doc.users.some((u: any) => u.userId === userId && u.active === true)
    )
    .map((doc: any) => ({
      hotelId: doc.hotelId!,
      name: doc.hotelName ?? "(Sin nombre)",
    }));
}

---------------------------------


üîπ Archivo: ./lib/config/hotelPhoneMap.ts
---------------------------------
import { getAllHotelConfigs } from "@/lib/config/hotelConfig.server"; // ‚úÖ corregimos import

type HotelPhoneCache = Record<string, string>; // phone -> hotelId

async function initHotelPhoneCache(): Promise<void> {
  if (globalThis.__hotel_phone_map__) return;

  const allHotels = await getAllHotelConfigs(); // ‚úÖ ahora s√≠, obtener todos los hoteles

  const phoneMap: HotelPhoneCache = {};

  for (const hotel of allHotels) {
    if (hotel.whatsappSettings?.number) {
      const normalized = normalizePhone(hotel.whatsappSettings.number);
      phoneMap[normalized] = hotel.hotelId;
    }
  }

  globalThis.__hotel_phone_map__ = phoneMap;
  console.log(`üìû HotelPhoneCache inicializado con ${Object.keys(phoneMap).length} tel√©fonos.`);
}

export async function getHotelIdByPhone(phone: string): Promise<string | undefined> {
  if (!globalThis.__hotel_phone_map__) {
    await initHotelPhoneCache();
  }

  const normalized = normalizePhone(phone);
  return globalThis.__hotel_phone_map__?.[normalized];
}

export async function refreshHotelPhoneCache(): Promise<void> {
  delete globalThis.__hotel_phone_map__;
  await initHotelPhoneCache();
}

function normalizePhone(phone: string): string {
  return phone.replace(/\D/g, "") + "@c.us";
}

declare global {
  var __hotel_phone_map__: HotelPhoneCache | undefined;
}

export function debugHotelPhoneMap() {
  if (!globalThis.__hotel_phone_map__) {
    console.log("üìû HotelPhoneCache a√∫n no inicializado.");
    return;
  }

  console.log("üìû HotelPhoneCache actual:");
  for (const [phone, hotelId] of Object.entries(globalThis.__hotel_phone_map__)) {
    console.log(`  üìç ${phone} ‚ûî ${hotelId}`);
  }
}

---------------------------------


üîπ Archivo: ./lib/config/getInitialHotelConfig.ts
---------------------------------
// /lib/config/getInitialHotelConfig.ts

import { randomUUID } from "crypto";
import type { HotelConfig } from "@/types/channel";
import type { HotelUser } from "@/types/user";

export function getInitialHotelConfig(params: {
  hotelId: string;
  hotelName: string;
  timezone: string;
  defaultLanguage?: string;
  adminEmail: string;
  adminPasswordHash: string;
  adminRoleLevel?: number;
}): HotelConfig {
  const {
    hotelId,
    hotelName,
    timezone,
    defaultLanguage = "es",
    adminEmail,
    adminPasswordHash,
    adminRoleLevel = 10,
  } = params;

  const now = new Date().toISOString();

  const adminUser: HotelUser = {
    userId: randomUUID(),
    email: adminEmail,
    passwordHash: adminPasswordHash,
    roleLevel: adminRoleLevel,
    active: true,
    createdAt: now,
    name: "Administrador",
    position: "Administrador",
  };

  return {
    hotelId,
    hotelName,
    timezone,
    defaultLanguage,
    channelConfigs: {}, // vac√≠a, puede completarse luego
    users: [adminUser],
    lastUpdated: now,
  };
}

---------------------------------


üîπ Archivo: ./lib/config/hotelLanguage.ts
---------------------------------
// /lib/config/hotelLanguage.ts
import { getHotelConfig } from "./hotelConfig.server";

/**
 * Devuelve el idioma nativo configurado para el hotel (formato ISO 639-3, ej: "spa", "eng").
 * Si no est√° definido, retorna "spa" como fallback.
 */
export async function getHotelLanguage(hotelId: string): Promise<string> {
  try {
    const config = await getHotelConfig(hotelId);
    const lang = config?.defaultLanguage;

    // Solo aceptamos formatos ISO 639-3
    const iso639_3 = /^[a-z]{3}$/;
    if (lang && iso639_3.test(lang)) {
      return lang;
    }
    return "spa"; // fallback
  } catch (err) {
    console.error("‚ùå Error obteniendo idioma del hotel:", err);
    return "spa";
  }
}

/**
 * Devuelve el timezone configurado para el hotel.
 * Si no est√° definido, retorna "UTC" como fallback.
 */
export async function getHotelTimezone(hotelId: string): Promise<string> {
  try {
    const config = await getHotelConfig(hotelId);
    return config?.timezone || "UTC";
  } catch (err) {
    console.error("‚ùå Error obteniendo timezone del hotel:", err);
    return "UTC";
  }
}

---------------------------------


üîπ Archivo: ./lib/config/initHotelConfig.ts
---------------------------------
// /lib/config/initHotelConfig.ts
import { collection } from "./hotelConfig.server";
import type { HotelConfig } from "@/types/channel";

export async function initHotelConfig(hotelId: string) {
  const existing = await collection.findOne({ hotelId });

  if (existing) {
    console.log(`‚ÑπÔ∏è Configuraci√≥n ya existente para ${hotelId}`);
    return;
  }

  const mockConfig: HotelConfig = {
    hotelId,
    hotelName: "Hotel de Prueba",
    defaultLanguage: "spa",
    timezone: "America/Montevideo",
    channelConfigs: {
      email: {
        enabled: true,
        mode: "supervised",
        dirEmail: "hotel@example.com",
        imapHost: "imap.gmail.com",
        smtpHost: "smtp.gmail.com",
        imapPort: 993,
        smtpPort: 587,
      },
      whatsapp: {
        enabled: true,
        mode: "supervised",
        celNumber: "+34123456789",
        apiKey: "api-key-opcional",
      },
      channelManager: {
        enabled: true,
        mode: "supervised",
        pollingInterval: 15000, // ‚úÖ ¬°Ahora es v√°lido!
      },
      
    },
    lastUpdated: new Date().toISOString(),
  };
  // üõ°Ô∏è Validaci√≥n de pollingInterval en channelManager
  if (mockConfig.channelConfigs.channelManager && "pollingInterval" in mockConfig.channelConfigs.channelManager) {
    const polling = mockConfig.channelConfigs.channelManager.pollingInterval;
    if (typeof polling !== "number" || polling < 5000) {
      console.warn(`‚ö†Ô∏è pollingInterval demasiado bajo (${polling} ms). Se ajusta a 15000 ms.`);
      mockConfig.channelConfigs.channelManager.pollingInterval = 15000;
    }
  }


  await collection.insertOne(mockConfig);
  console.log(`‚úÖ Configuraci√≥n inicial creada para ${hotelId}`);
}

---------------------------------


üîπ Archivo: ./lib/config/hotelConfig.server.ts
---------------------------------
// /root/begasist/lib/config/hotelConfig.server.ts

import { DataAPIClient } from "@datastax/astra-db-ts";
import { ChannelMode } from "@/types/channel";
import type { HotelConfig } from "@/types/channel";
import dotenv from "dotenv";
dotenv.config();

const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
export const collection = db.collection("hotel_config");

export type HotelChannelConfig = {
  mode: ChannelMode;
  enabled: boolean;
  [key: string]: any;
};

/**
 * Obtiene la configuraci√≥n de un hotel por su ID.
 */
export async function getHotelConfig(hotelId: string): Promise<HotelConfig | null> {
  const result = await collection.findOne({ hotelId });
  // ‚ö†Ô∏è fallback para iso3to1 si es system
  if (result && hotelId === "system" && !result.iso3to1) {
    result.iso3to1 = {
      spa: "es",
      eng: "en",
      fra: "fr",
      por: "pt",
      ita: "it",
      deu: "de",
      rus: "ru",
      nld: "nl",
      // Agreg√° los que uses
    };
  }
  return result as HotelConfig | null;
}

/**
 * Obtiene la lista completa de hoteles.
 */
export async function getAllHotelConfigs(): Promise<HotelConfig[]> {
  const result = await collection.find({}).toArray();

  // Mapeamos y filtramos documentos v√°lidos
  const configs: HotelConfig[] = result
    .filter(doc => doc.hotelId && doc.channelConfigs)
    .map(doc => ({
      hotelId: doc.hotelId,
      hotelName: doc.hotelName || "Unnamed Hotel",
      defaultLanguage: doc.defaultLanguage || "es",
      timezone: doc.timezone || "UTC",
      channelConfigs: doc.channelConfigs || {},
      users: doc.users || [],
      lastUpdated: doc.lastUpdated || new Date().toISOString(),
      emailSettings: doc.emailSettings || undefined,
      iso3to1: doc.iso3to1 || undefined, // Soport√° mapping centralizado
    }));

  return configs;
}

/**
 * Actualiza (mergea) la configuraci√≥n de un hotel por su ID.
 * Fusiona channelConfigs en profundidad y preserva lastUpdated.
 */
export async function updateHotelConfig(hotelId: string, updates: Partial<HotelConfig>) {
  const current = await collection.findOne({ hotelId });

  const merged = {
    ...current,
    ...updates,
    channelConfigs: {
      ...current?.channelConfigs,
      ...updates.channelConfigs,
    },
    lastUpdated: new Date().toISOString(),
  };

  // ‚ùå remover _id antes de hacer $set para evitar conflictos en AstraDB/Mongo
  delete (merged as any)._id;

  await collection.updateOne({ hotelId }, { $set: merged }, { upsert: true });

  return merged;
}

---------------------------------


üîπ Archivo: ./lib/entrypoints/all.ts
---------------------------------
process.on("uncaughtException", (err) => {
    console.error("üí• Excepci√≥n no capturada:", err);
  });
  
  process.on("unhandledRejection", (reason) => {
    console.error("üí• Promesa rechazada sin catch:", reason);
  });
  
  console.log("üü¢ Iniciando entrypoint all.ts...");
  
  import { startEmailBot } from "../services/email";
  import { startWhatsAppBot } from "../services/whatsapp";
  import { startChannelManagerBot } from "../services/channelManager";
  import { webMemory } from "@/lib/services/webMemory";
  
  async function startAll() {
    try {
      await Promise.all([
        startEmailBot(),
        startWhatsAppBot(),
        startChannelManagerBot(),
      ]);
      webMemory.clearMessages();
      console.log("üßπ Memoria web limpia");
      console.log("‚úÖ Todos los canales iniciados correctamente.");
    } catch (err) {
      console.error("‚ùå Error al iniciar uno o m√°s canales:", err);
    }
  }
  
  startAll();
  
---------------------------------


üîπ Archivo: ./lib/entrypoints/email.ts
---------------------------------

console.log("üü¢ Entrando a email.ts");

process.on("uncaughtException", (err) => {
  console.error("üí• Excepci√≥n no capturada:");
  console.error("Tipo:", typeof err);
  console.error("Contenido:", err);
  console.error("Inspecci√≥n profunda:", require("util").inspect(err, { depth: null, colors: true }));
});

process.on("unhandledRejection", (reason) => {
  console.error("üí• Promesa rechazada sin catch:");
  console.error("Tipo:", typeof reason);
  console.error("Contenido:", reason);
  console.error("Inspecci√≥n profunda:", require("util").inspect(reason, { depth: null, colors: true }));
});

console.log("üõ†Ô∏è Iniciando entrypoint email.ts");

import { startEmailBot } from "../../lib/services/email";

console.log("üì• startEmailBot importado");
(async () => {
  try {
    console.log("üöÄ Iniciando bot de email...");
    await startEmailBot();
  } catch (error) {
    console.error("‚õî Error en el bot de email:", error instanceof Error ? error.message : error);
    console.error(error); // üëà esto imprime el stack completo
  }
})();
---------------------------------


üîπ Archivo: ./lib/entrypoints/whatsapp.ts
---------------------------------
// lib/entrypoints/whatsapp.ts
import dotenv from "dotenv";
dotenv.config();

import { startWhatsAppBot } from "../services/whatsapp";

console.log("üöÄ Iniciando bot de WhatsApp...");
startWhatsAppBot();

---------------------------------


üîπ Archivo: ./lib/astra/connection.ts
---------------------------------
// /root/begasist/lib/astra/connection.ts

import { DataAPIClient } from "@datastax/astra-db-ts";
import dotenv from "dotenv";
dotenv.config();

const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);

/**
 * Devuelve la instancia de db con el keyspace configurado.
 */
export function getAstraDB() {
  return client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
}

/**
 * Retorna una colecci√≥n AstraDB para el hotel indicado.
 * @param hotelId - El ID l√≥gico del hotel
 * @param suffix - (opcional) Sufijo para el nombre de la colecci√≥n (por defecto: "_collection")
 * @returns La colecci√≥n tipada (o any si no se provee tipo)
 */
export function getHotelAstraCollection<T extends Record<string, any> = any>(
  hotelId: string,
  suffix = "_collection"
) {
  const collectionName = `${hotelId}${suffix}`;
  return getAstraDB().collection<T>(collectionName);
}

---------------------------------


üîπ Archivo: ./lib/astra/index.ts
---------------------------------
// /root/begasist/lib/astra/index.ts
import { DataAPIClient } from "@datastax/astra-db-ts";
import * as dotenv from "dotenv";
dotenv.config();

const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
const ASTRA_DB_COLLECTION_NAME = "begaia";

  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });


export async function searchAstraDB(query: string) {
  try {
    // const collection = db.collection(ASTRA_DB_COLLECTION_NAME); // Esta l√≠nea va abajo
    // Generar embedding de la consulta con OpenAI
    const response = await fetch("https://api.openai.com/v1/embeddings", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: "text-embedding-ada-002",
        input: query,
      }),
    });

    const { data } = await response.json();
    let queryVector = data[0].embedding;

    if (queryVector.length !== 1536) {
      console.warn("‚ö† ADVERTENCIA: El embedding de la consulta no tiene 1536 dimensiones.");
    }

    // üî• Esta es la forma correcta: us√° el keyspace y la URL desde variables de entorno
    const collection = db.collection(ASTRA_DB_COLLECTION_NAME);
    if (!collection) {
      throw new Error(`No se encontr√≥ la colecci√≥n: ${ASTRA_DB_COLLECTION_NAME}`);
    }

    // Verificar la configuraci√≥n de la colecci√≥n en AstraDB
    const collectionInfo = await collection.options();
    console.log("üìå Configuraci√≥n de la colecci√≥n en AstraDB:", JSON.stringify(collectionInfo, null, 2));

    // Realizar b√∫squeda vectorial
    console.log("üîç Ejecutando b√∫squeda vectorial...");
    const cursor = await collection.find({}, {
      sort: { $vector: queryVector },
      limit: 10,
      includeSimilarity: true,
    });

    const results = await cursor.toArray();
    console.log("üìÑ Documentos obtenidos:", JSON.stringify(results, null, 2));

    return results;
  } catch (error) {
    console.error("‚ùå Error en searchAstraDB:", error);
    throw error;
  }
}

---------------------------------


üîπ Archivo: ./lib/astra/load_from_pdf.ts
---------------------------------
import { DataAPIClient } from "@datastax/astra-db-ts";
import OpenAI from "openai";
import fs from "fs";
import pdf from "pdf-parse";
import path from "path";
import dotenv from "dotenv";
dotenv.config();

const ASTRA_DB_APPLICATION_TOKEN: string = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_COLLECTION_NAME: string = "begaia";
const OPENAI_API_KEY: string = process.env.OPENAI_API_KEY!;
const PDF_FILE_PATH = path.resolve("app/lib/hotel_demo.pdf");
const JSON_OUTPUT_PATH = path.resolve("hotel_data.json");

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
const db = client.db("https://bd3a9cf5-660d-4c90-ad58-39a03af1fed2-us-east-2.apps.astra.datastax.com");
const collection = db.collection(ASTRA_DB_COLLECTION_NAME);
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

// Funci√≥n para generar embeddings con OpenAI sin reducci√≥n
async function generateEmbeddings(text: string): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: "text-embedding-ada-002", // Usa 1536 dimensiones
    input: text,
  });
  return response.data[0].embedding;
}

// Funci√≥n para verificar la configuraci√≥n de la colecci√≥n en AstraDB
async function checkCollectionConfig() {
  const collectionInfo = await collection.options();
  console.log("üìå Configuraci√≥n REAL de la colecci√≥n en AstraDB:", JSON.stringify(collectionInfo, null, 2));

  if (collectionInfo.vector?.dimension !== 1536) {
    console.warn("‚ö† ADVERTENCIA: La colecci√≥n no est√° configurada para embeddings de 1536 dimensiones.");
  }
}

// Carga de datos en AstraDB y guardado en JSON
async function loadHotelData(): Promise<void> {
  try {
    // Verificar la configuraci√≥n de la colecci√≥n antes de cargar datos
    await checkCollectionConfig();

    const pdfBuffer: Buffer = fs.readFileSync(PDF_FILE_PATH);
    const pdfData = await pdf(pdfBuffer);
    const hotelData: string = pdfData.text;

    console.log("üîç Generando embedding para el texto completo...");
    const embedding: number[] = await generateEmbeddings(hotelData);
    console.log("üí™ Dimensi√≥n del embedding generado:", embedding.length);

    if (embedding.length !== 1536) {
      console.warn("‚ö† ADVERTENCIA: El embedding generado no tiene 1536 dimensiones.");
    }

    const document = {
      idea: hotelData, // Se usa 'idea' como campo de texto
      $vector: embedding, // Usa el campo correcto para AstraDB
      metadata: {
        source: "Hotel Demo Punta del Este",
        createdAt: new Date().toISOString(),
      },
    };

    // Guardar en archivo JSON
    fs.writeFileSync(JSON_OUTPUT_PATH, JSON.stringify(document, null, 2));
    console.log("‚úÖ Documento guardado en hotel_data.json");

    // Insertar en AstraDB
    await collection.insertOne(document);
    console.log("‚úÖ Documento insertado en AstraDB con √©xito.");

  } catch (error) {
    console.error("‚ùå Error cargando datos en AstraDB:", error);
  }
}

// Ejecutar la carga de datos
loadHotelData();

---------------------------------


üîπ Archivo: ./lib/hooks/useSession.ts
---------------------------------
// /lib/hooks/useSession.ts
"use client";

import { useState, useEffect } from "react";
import { jwtDecode } from "jwt-decode";


interface JWTPayload {
  email: string;
  hotelId: string;
  roleLevel: number;
  userId: string;
  exp?: number;
}

export function useSession(): JWTPayload | null {
  const [session, setSession] = useState<JWTPayload | null>(null);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const token = localStorage.getItem("accessToken");
    if (!token) return;

    try {
      const payload = jwtDecode<JWTPayload>(token);
      setSession(payload);
    } catch (err) {
      console.warn("‚ùå Token de acceso inv√°lido o corrupto", err);
      setSession(null);
    }
  }, []);

  return session;
}

---------------------------------


üîπ Archivo: ./lib/hooks/useCurrentUser.ts
---------------------------------
"use client";

import { useEffect, useState } from "react";
import { fetchWithAuth } from "@/lib/client/fetchWithAuth";

export type CurrentUser = {
  email: string;
  hotelId: string;
  roleLevel: number;
  userId: string;
};

export function useCurrentUser() {
  const [user, setUser] = useState<CurrentUser | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadUser() {
      try {
        const res = await fetchWithAuth("/api/me");
        if (!res.ok) {
          setUser(null);
        } else {
          const data = await res.json();
          setUser(data);
        }
      } catch (err) {
        setUser(null);
      } finally {
        setLoading(false);
      }
    }

    loadUser();
  }, []);

  return { user, loading };
}

---------------------------------


üîπ Archivo: ./lib/client/fetchWithAuth.ts
---------------------------------
// /lib/client/fetchWithAuth.ts
export async function fetchWithAuth(
    input: RequestInfo | URL,
    init: RequestInit = {},
    retry = true
  ): Promise<Response> {
    const res = await fetch(input, init);
  
    if (res.status !== 401 || !retry) {
      return res;
    }
  
    // üîÅ Intentar renovar token usando refreshToken
    const refreshRes = await fetch("/api/refresh");
  
    if (refreshRes.ok) {
      // Reintentar la solicitud original (solo una vez)
      return fetchWithAuth(input, init, false);
    }
  
    // ‚ùå Si la renovaci√≥n tambi√©n fall√≥ ‚Üí redirigir al login
    if (typeof window !== "undefined") {
      window.location.href = "/auth/login";
    }
  
    return res; // por si es usado en l√≥gica que espera una Response
  }
  
---------------------------------


üîπ Archivo: ./lib/agents/retrieval_based.ts
---------------------------------
import { ChatOpenAI } from "@langchain/openai";
import { GraphState} from "./index";
import { AIMessage, HumanMessage } from "@langchain/core/messages";
import { defaultPrompt, curatedPrompts } from "../prompts";
import { debugLog } from "../utils/debugLog";
import { searchFromAstra } from "../retrieval";

let localModel: ChatOpenAI | null = null;

export function setRetrievalModel(model: ChatOpenAI) {
  localModel = model;
}

// ‚úÖ Seteo por defecto
setRetrievalModel(new ChatOpenAI({ modelName: "gpt-4o", temperature: 0 }));

process.env.OPENAI_LOG = "off";

const translationModel = new ChatOpenAI({ model: "gpt-4o" });

async function translateResponseBack(originalLang: string, content: string): Promise<string> {
  if (originalLang === process.env.SYSTEM_NATIVE_LANGUAGE) return content;

  const translated = await translationModel.invoke([
    {
      role: "system",
      content: `Traduce el siguiente contenido al idioma '${originalLang}' manteniendo emojis y formato Markdown.`,
    },
    { role: "user", content },
  ]);

  return typeof translated.content === "string" ? translated.content : content;
}

export async function retrieve_hotel_info(
  query: string,
  lang: string,
  hotelId: string,
  category?: string,
  promptKey?: string | null
) {
  const translated = lang === process.env.SYSTEM_NATIVE_LANGUAGE
    ? { content: query }
    : await translationModel.invoke([
        {
          role: "system",
          content: `Solo responde con la traducci√≥n literal de la siguiente consulta al idioma '${process.env.SYSTEM_NATIVE_LANGUAGE}'.`,
        },
        { role: "user", content: query },
      ]);

  const searchQuery = typeof translated.content === "string"
    ? translated.content
    : JSON.stringify(translated.content);

  const docs = await searchFromAstra(searchQuery, hotelId, {
    category,
    promptKey: promptKey ?? undefined,
  });

  return docs.join("\n\n");
}

export async function retrievalBased(state: typeof GraphState.State) {
  const lastMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const userQuery = typeof lastMessage?.content === "string" ? lastMessage.content.trim() : "";
  const lang = state.detectedLanguage ?? process.env.SYSTEM_NATIVE_LANGUAGE;
  const promptKey = state.promptKey;
  const hotelId = (state as any).hotelId ?? "defaultHotelId"; // fallback por si no viene

  if (!userQuery) {
    return { messages: [new AIMessage("Consulta vac√≠a o inv√°lida.")] };
  }

  const retrievedInfo = await retrieve_hotel_info(userQuery, lang, hotelId, state.category, promptKey);

  if (!retrievedInfo) {
    debugLog("‚ö†Ô∏è No se encontr√≥ informaci√≥n relevante en los documentos.");
    if (!localModel) {
      throw new Error("localModel is not initialized.");
    }
    const response = await localModel.invoke(state.messages);
    const responseText = typeof response.content === "string" ? response.content.trim() : "";
    return {
      messages: [new AIMessage(responseText || "Lo siento, no encontr√© informaci√≥n.")],
    };
  }

  const promptTemplate = (promptKey && curatedPrompts[promptKey]) || defaultPrompt;
  const finalPrompt = promptTemplate
    .replace("{{retrieved}}", retrievedInfo)
    .replace("{{query}}", userQuery);

  if (!localModel) {
    throw new Error("localModel is not initialized.");
  }
  const response = await localModel.invoke([
    { role: "system", content: finalPrompt },
    { role: "user", content: userQuery },
  ]);

  const responseText = typeof response.content === "string" ? response.content.trim() : "";
  const finalResponse = lang === process.env.SYSTEM_NATIVE_LANGUAGE
    ? responseText
    : await translateResponseBack(lang, responseText);

  return {
    ...state,
    messages: [...state.messages, new AIMessage(finalResponse || "Lo siento, no encontr√© informaci√≥n.")],
  };
}

---------------------------------


üîπ Archivo: ./lib/agents/billing.ts
---------------------------------
// app/agents/billings.ts
import { AIMessage } from "@langchain/core/messages";
export function handleBilling() {
    return { messages: [new AIMessage("Handling billings query")] };
}

---------------------------------


üîπ Archivo: ./lib/agents/defaultResponse.ts
---------------------------------
// app/agents/defaultResponse.ts
import { AIMessage } from "@langchain/core/messages";
export function defaultResponse() {
    return { messages: [new AIMessage("Handling default respponse query")] };
}

---------------------------------


üîπ Archivo: ./lib/agents/reservations.ts
---------------------------------
import { pms } from "lib/pms";

export async function handleReservation(state: { messages: { content: string }[] }) {
  const userMessage = state.messages[0].content; // Extraer el mensaje del usuario
  console.log(`User request: ${userMessage}`); // Se usa para evitar el error de variable no utilizada

  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [`Reservation confirmed: ${response.id}`] };
}

---------------------------------


üîπ Archivo: ./lib/agents/services.ts
---------------------------------
// app/agents/services.ts
import { AIMessage } from "@langchain/core/messages";
export function handleServices() {
    return { messages: [new AIMessage("Handling services query")] };
}
---------------------------------


üîπ Archivo: ./lib/agents/internal_support.ts
---------------------------------
// app/agents/internal_support.ts
import { AIMessage } from "@langchain/core/messages";
export function handleSupport() {
    return { messages: [new AIMessage("Handling support query")] };
}


---------------------------------


üîπ Archivo: ./lib/agents/index.ts
---------------------------------
import { StateGraph } from "@langchain/langgraph";
import { classifyQuery } from "../classifier";
import { AIMessage, HumanMessage, BaseMessage } from "@langchain/core/messages";
import { pms } from "../pms";
import { ChatOpenAI } from "@langchain/openai";
import { createRetrieverTool } from "langchain/tools/retriever";
import { Annotation } from "@langchain/langgraph";
import { retrievalBased } from "./retrieval_based";
import { franc } from "franc";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";
import { searchFromAstra } from "../retrieval";
import { detectLanguage } from "../utils/language";


process.env.OPENAI_LOG = "off";
debugLog("üîß Compilando grafo conversacional...");

// ----------------------------
// Estado del grafo
export const GraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),
    default: () => [] as BaseMessage[],
  }),
  category: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "other",
  }),
  detectedLanguage: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "en",
  }),
  promptKey: Annotation<string | null>({
    reducer: (x, y) => y,
    default: () => null,
  }),
  hotelId: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "hotel123",
  }),
  conversationId: Annotation<string | null>({        // üî• agregar esto
    reducer: (x, y) => y,
    default: () => null,
  }),
});

// ----------------------------
// Vector store y modelo (usado por retrievalBased)
export let vectorStore: any;
let retriever: any;
export let model: any;

export async function initializeVectorStore() {
  if (!vectorStore) {
    // Simula un retriever a partir de AstraDB
    vectorStore = {
      asRetriever: () => ({
        getRelevantDocuments: async (query: string) => {
          const results = await searchFromAstra(query, "hotel123");
          return results.map((text) => ({
            pageContent: text,
            metadata: {},
          }));
        },
      }),
    };

    retriever = createRetrieverTool(vectorStore.asRetriever(), {
      name: "retrieve_hotel_info",
      description: "Search hotel FAQs and policies.",
    });

    model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 }).bindTools([retriever]);
    debugLog("‚úÖ Vector store inicializado desde AstraDB (sin Puppeteer)");
  }
}

// ----------------------------
// Nodo de clasificaci√≥n
export async function classifyNode(state: typeof GraphState.State) {
  const lastUserMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const question = typeof lastUserMessage?.content === "string" ? lastUserMessage.content.trim() : "";

  if (!question) {
    return {
      ...state,
      category: "retrieval_based",
      promptKey: null,
      messages: [
        ...state.messages,
        new AIMessage("Consulta vac√≠a o no v√°lida. Intenta reformular tu pregunta."),
      ],
    };
  }

  const detectedLang = await detectLanguage(question, state.hotelId);



  let classification;
  try {
    classification = await classifyQuery(question);
    debugLog("üîÄ Clasificaci√≥n detectada:", classification);
  } catch (e) {
    console.error("‚ùå Error clasificando la consulta:", e);
    classification = { category: "retrieval_based", promptKey: null };
  }

  const { category, promptKey } = classification;
  const validPromptKeys = promptMetadata[category] || [];
  const finalPromptKey = validPromptKeys.includes(promptKey || "") ? promptKey : null;

  debugLog("üß† Clasificaci√≥n final:", { category, promptKey: finalPromptKey });

  return {
    ...state,
    category,
    promptKey: finalPromptKey,
    detectedLanguage: detectedLang || process.env.SYSTEM_NATIVE_LANGUAGE,
    messages: [
      ...state.messages,
      new AIMessage(`Consulta clasificada como: ${category}${finalPromptKey ? ` (üß† promptKey: ${finalPromptKey})` : ""}`),
    ],
  };
}

// ----------------------------
// Nodos funcionales del grafo
async function handleReservationNode() {
  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [new AIMessage(`Reserva confirmada: ${response.id}`)] };
}
async function handleAmenitiesionNode() {
  return { messages: [new AIMessage("Aqu√≠ est√°n los detalles de amenities.")] };
}
async function handleBillingNode() {
  return { messages: [new AIMessage("Aqu√≠ est√°n los detalles de facturaci√≥n.")] };
}
async function handleSupportNode() {
  return { messages: [new AIMessage("¬øEn qu√© puedo ayudarte? Nuestro equipo est√° disponible para asistirte.")] };
}
async function retrievalBasedNode(state: typeof GraphState.State) {
  return await retrievalBased(state);
}

// ----------------------------
// Definici√≥n del grafo
const graph = new StateGraph(GraphState)
  .addNode("classify", classifyNode)
  .addNode("handle_reservation", handleReservationNode)
  .addNode("handle_amenities", handleAmenitiesionNode)
  .addNode("handle_billing", handleBillingNode)
  .addNode("handle_support", handleSupportNode)
  .addNode("handle_retrieval_based", retrievalBasedNode)
  .addEdge("__start__", "classify")
  .addConditionalEdges("classify", (state) => state.category, {
    reservation: "handle_reservation",
    amenities: "handle_amenities",
    billing: "handle_billing",
    support: "handle_support",
    retrieval_based: "handle_retrieval_based",
  })
  .addEdge("handle_reservation", "__end__")
  .addEdge("handle_amenities", "__end__")
  .addEdge("handle_billing", "__end__")
  .addEdge("handle_support", "__end__")
  .addEdge("handle_retrieval_based", "__end__");

debugLog("‚úÖ Grafo compilado con √©xito.");
export const agentGraph = graph.compile();

---------------------------------


üîπ Archivo: ./lib/utils/debugLog.ts
---------------------------------
// lib/utils/debugLog.ts

export function debugLog(...args: any[]) {
  if (process.env.DEBUG === "true") {
    console.log("üêû DEBUG:", ...args);
  }
}

  
---------------------------------


üîπ Archivo: ./lib/utils/lang.ts
---------------------------------
// /lib/utils/lang.ts

import { getHotelConfig } from "@/lib/config/hotelConfig.server";

/**
 * Devuelve el mapping ISO 639-3 ‚Üí ISO 639-1 centralizado.
 * Busca en la config del hotelId 'system'.
 * Si no existe, retorna un mapping m√≠nimo de ejemplo como fallback.
 */
export async function getIso3to1Map(): Promise<Record<string, string>> {
  const config = await getHotelConfig("system");
  return config?.iso3to1 || {
    spa: "es",
    eng: "en",
    fra: "fr",
    por: "pt",
    ita: "it",
    deu: "de",
    rus: "ru",
    nld: "nl",
    // Agreg√° m√°s si us√°s otros idiomas
  };
}

/**
 * Convierte un c√≥digo ISO 639-3 (ej: 'spa') a ISO 639-1 ('es').
 * Si no encuentra mapping, retorna "es" como fallback.
 */
export async function iso3To1(code3: string): Promise<string> {
  const map = await getIso3to1Map();
  return map[code3] || "es";
}

---------------------------------


üîπ Archivo: ./lib/utils/parseChannel.ts
---------------------------------
// /lib/utils/parseChannel.ts
import { ALL_CHANNELS, type Channel } from "@/types/channel";

/**
 * Valida y convierte un string a tipo Channel si es v√°lido.
 * @param channel Texto recibido
 * @returns Channel v√°lido o null si no es permitido
 */
export function parseChannel(channel: string | null): Channel | null {
  if (channel && ALL_CHANNELS.includes(channel as Channel)) {
    return channel as Channel;
  }
  return null;
}

---------------------------------


üîπ Archivo: ./lib/utils/time.ts
---------------------------------
// /lib/utils/time.ts

import { getHotelTimezone } from "@/lib/config/hotelLanguage";
import { DateTime } from "luxon";

/**
 * Convierte un timestamp ISO UTC a la hora local del hotel.
 */
export async function getLocalTime(hotelId: string, timestamp: string): Promise<string> {
  try {
    const timezone = await getHotelTimezone(hotelId);
    const localTime = DateTime.fromISO(timestamp, { zone: "utc" })
      .setZone(timezone)
      .toLocaleString(DateTime.TIME_24_SIMPLE); // ej: 14:23

    return localTime;
  } catch (error) {
    console.error("‚ùå Error convirtiendo hora local:", error);
    return timestamp;
  }
}

---------------------------------


üîπ Archivo: ./lib/utils/buildVerificationUrl.ts
---------------------------------
// /root/begasist/lib/utils/buildVerificationUrl.ts
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function buildVerificationUrl(path: string, token: string, hotelId: string): Promise<string> {
  const config = await getHotelConfig(hotelId);
  if (!config) {
    throw new Error(`‚ùå Configuraci√≥n del hotel no encontrada para hotelId: ${hotelId}`);
  }
  const base = config.verification?.baseUrl || process.env.DEFAULT_VERIFICATION_URL_BASE;
  if (!base) {
    throw new Error("‚ùå No se defini√≥ ninguna base URL para verificaci√≥n.");
  }
  return `${base.replace(/\/$/, "")}/${path}?token=${token}`;
}

---------------------------------


üîπ Archivo: ./lib/utils/language.ts
---------------------------------
import { franc } from "franc";
import { getHotelLanguage } from "@/lib/config/hotelLanguage";

const supportedLanguages = new Set(["spa", "eng", "ita", "fra", "por"]);

export async function detectLanguage(text: string, hotelId: string): Promise<string> {
  if (!text || text.trim().length < 10) {
    return await getHotelLanguage(hotelId); // ‚úÖ usa config real
  }

  const lang = franc(text.trim(), { minLength: 3 });

  return supportedLanguages.has(lang) ? lang : await getHotelLanguage(hotelId);
}

---------------------------------


üîπ Archivo: ./lib/utils/roles.ts
---------------------------------
import type { RoleLevel } from "@/types/roles";

export function isTechnical(level: RoleLevel): boolean {
  return level >= 0 && level < 10;
}

export function isManager(level: RoleLevel): boolean {
  return level >= 10 && level < 20;
}

export function isStandard(level: RoleLevel): boolean {
  return level >= 20 && level < 30;
}

---------------------------------


üîπ Archivo: ./lib/utils/similarity.ts
---------------------------------
export function cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (normA * normB);
  }
  
---------------------------------


üîπ Archivo: ./lib/utils.ts
---------------------------------
// /root/begasist/lib/utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

---------------------------------


üîπ Archivo: ./lib/context/UserContext.tsx
---------------------------------
// /lib/context/UserContext.tsx
"use client";

import { createContext, useContext, useEffect, useState } from "react";
import { fetchWithAuth } from "@/lib/client/fetchWithAuth";

export type CurrentUser = {
  email: string;
  hotelId: string;
  hotelName: string; // üëà agregamos esto
  roleLevel: number;
  userId: string;
};

type UserContextType = {
  user: CurrentUser | null;
  loading: boolean;
  refreshUser: () => Promise<void>;
};

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<CurrentUser | null>(null);
  const [loading, setLoading] = useState(true);

  const loadUser = async () => {
    setLoading(true);
    try {
      const res = await fetchWithAuth("/api/me");
      if (!res.ok) {
        setUser(null);
      } else {
        const data = await res.json();
        setUser(data);
      }
    } catch {
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadUser();
  }, []);

  return (
    <UserContext.Provider value={{ user, loading, refreshUser: loadUser }}>
      {children}
    </UserContext.Provider>
  );
}

export function useCurrentUser() {
  const context = useContext(UserContext);
  if (!context) throw new Error("useCurrentUser debe usarse dentro de <UserProvider>");
  return context;
}

---------------------------------


üîπ Archivo: ./lib/api/fetchWithAuth.ts
---------------------------------
// /lib/api/fetchWithAuth.ts

export async function fetchWithAuth(url: string, options: RequestInit = {}) {
    const token = localStorage.getItem("token");
  
    const headers = {
      ...(options.headers || {}),
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    };
  
    let res = await fetch(url, {
      ...options,
      headers,
    });
  
    // Si el token expir√≥, intentamos refrescarlo una sola vez
    if (res.status === 401) {
      const refreshRes = await fetch("/api/refresh");
      if (refreshRes.ok) {
        const data = await refreshRes.json();
        localStorage.setItem("token", data.token);
  
        // Reintentamos el request original con el nuevo token
        const retryHeaders = {
          ...headers,
          Authorization: `Bearer ${data.token}`,
        };
  
        res = await fetch(url, {
          ...options,
          headers: retryHeaders,
        });
      }
    }
  
    return res;
  }
  
---------------------------------


üîπ Archivo: ./lib/constants/adminMenu.ts
---------------------------------
// /lib/constants/adminMenu.ts
import { Home, Hotel, Upload, Brain, FileText, Users, KeyRound } from "lucide-react";

export const ADMIN_MENU_ITEMS = [
  {
    label: "Inicio",
    href: "/admin",
    icon:  Home,
    minRole: 0,
  },
  {
    label: "Hoteles",
    href: "/admin/hotels",
    icon:  Hotel,
    minRole: 0,
    maxRole: 0,
  },
  {
    label: "Carga de datos",
    href: "/admin/upload",
    icon:  Upload,
    minRole: 0,
    maxRole: 19,
  },
  {
    label: "Prompts",
    href: "/admin/prompts",
    icon:  Brain,
    minRole: 0,
    maxRole: 19,
  },
  {
    label: "Logs",
    href: "/admin/logs",
    icon:  FileText,
    minRole: 0,
    maxRole: 19,
  },
];

---------------------------------


üîπ Archivo: ./test/services/channelMemory.test.ts
---------------------------------
// /test/services/webMemory.test.ts
import { describe, it, expect, beforeEach } from "vitest";
import { channelMemory } from "@/lib/services/channelMemory";
import type { ChannelMessage } from "@/types/channel";

describe("channelMemory (web)", () => {
  const baseMessage: Omit<ChannelMessage, "messageId"> = {
    hotelId: "hotel123",
    channel: "web",
    sender: "Test",
    content: "Mensaje de prueba",
    timestamp: new Date().toISOString(),
    time: "10:00",
    suggestion: "Sugerencia de prueba",
    status: "pending",
  };

  beforeEach(() => {
    // üîÅ Reset del almacenamiento en memoria para pruebas
    // @ts-ignore
    globalThis.__channel_memory__ = {};
  });

  it("debe mantener solo los √∫ltimos 100 mensajes", () => {
    for (let i = 0; i < 110; i++) {
      const msg: ChannelMessage = {
        ...baseMessage,
        messageId: `msg-${i}`,
      };
      channelMemory.addMessage(msg);
    }

    const messages = channelMemory.getMessages("web");
    expect(messages.length).toBe(100);
    expect(messages[0].messageId).toBe("msg-10");
    expect(messages[99].messageId).toBe("msg-109");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/updateMessageInAstra.test.ts
---------------------------------
// /test/integration/updateMessageInAstra.test.ts

import { describe, it, expect } from "vitest";
import {
  saveMessageToAstra,
  updateMessageInAstra,
  getMessagesFromAstra,
  deleteMessageFromAstra,
} from "@/lib/db/messages";
import { randomUUID } from "crypto";
import type { Channel } from "@/types/channel";
import type { ChannelMessage, MessageStatus } from "@/types/channel";

describe("üîÅ updateMessageInAstra", () => {
  const messageId = `test-update-${randomUUID()}`;
  const hotelId = "hotel123";
  const channel: Channel = "web";
  const status: MessageStatus = "pending";

  it("actualiza el estado y el respondedBy de un mensaje guardado", async () => {
    await deleteMessageFromAstra(messageId); // üßπ limpieza inicial

    const originalMessage: ChannelMessage = {
      messageId,
      hotelId,
      channel,
      sender: "usuario-web",
      timestamp: new Date().toISOString(),
      time: "12:00",
      content: "¬øPuedo dejar el equipaje antes del check-in?",
      suggestion: "S√≠, podemos guardarlo en recepci√≥n sin costo.",
      respondedBy: undefined,
      approvedResponse: undefined,
      status,
      conversationId: `conv-${randomUUID()}`,
    };

    await saveMessageToAstra(originalMessage);

    const changes: Partial<ChannelMessage> = {
      status: "sent",
      respondedBy: "recepcionista@hotel.com",
      approvedResponse: "S√≠, puede dejarlo desde las 9 am.",
    };

    await updateMessageInAstra(hotelId, messageId, changes);

    const results = await getMessagesFromAstra(hotelId, channel);
    const updated = results.find((msg) => msg.messageId === messageId);

    expect(updated).toBeDefined();
    expect(updated?.status).toBe("sent");
    expect(updated?.respondedBy).toBe("recepcionista@hotel.com");
    expect(updated?.approvedResponse).toBe("S√≠, puede dejarlo desde las 9 am.");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/roundTripMessages.test.ts
---------------------------------
// /test/integration/roundTripMessages.test.ts

import { describe, it, expect } from "vitest";
import { saveMessageToAstra, getMessagesFromAstra } from "@/lib/db/messages";
import { randomUUID } from "crypto";
import type { ChannelMessage } from "@/types/channel";
import type { Channel } from "@/types/channel";

describe("üîÅ Round-trip de persistencia de mensajes", () => {
  const messageId = `test-msg-${randomUUID()}`;
  const hotelId = "hotel123";
  const channel: Channel = "web";

  it("guarda y recupera un mensaje completo correctamente", async () => {
    const msg: ChannelMessage = {
      messageId,
      conversationId: `conv-${randomUUID()}`,
      hotelId,
      channel,
      sender: "Usuario Web",
      timestamp: new Date().toISOString(),
      time: "13:30",
      content: "¬øTienen habitaciones con vista al mar?",
      suggestion: "S√≠, tenemos habitaciones con vista al mar disponibles.",
      approvedResponse: "S√≠, disponibles. ¬øLe gustar√≠a reservar?",
      status: "sent",
      respondedBy: "sofia@hotel.com",
    };

    await saveMessageToAstra(msg);

    const results = await getMessagesFromAstra(hotelId, channel);
    const saved = results.find((m) => m.messageId === messageId);

    expect(saved).toBeDefined();
    expect(saved?.content).toBe(msg.content);
    expect(saved?.approvedResponse).toBe(msg.approvedResponse);
    expect(saved?.respondedBy).toBe(msg.respondedBy);
    expect(saved?.status).toBe(msg.status);
  });
});

---------------------------------


üîπ Archivo: ./test/integration/hotelConfigExtend.test.ts
---------------------------------
// /test/integration/hotelConfigExtend.test.ts

import { describe, it, expect } from "vitest";
import {
  getHotelConfig,
  updateHotelConfig,
} from "@/lib/config/hotelConfig.server"

const hotelId = "hotel123";

describe("üß© Hotel Config Extend (Astra DB)", () => {
  it("agrega un nuevo canal (email) y valida todos los canales", async () => {
    await updateHotelConfig(hotelId, {
      channelConfigs: {
        email: {
          enabled: true,
          mode: "automatic",
          dirEmail: "hotel@example.com",
          imapHost: "imap.example.com",
          smtpHost: "smtp.example.com",
          imapPort: 993,
          smtpPort: 587,
        },
      },
    });

    const config = await getHotelConfig(hotelId);
    expect(config).not.toBeNull();
    expect(config?.channelConfigs.email?.enabled).toBe(true);
    expect(config?.channelConfigs.email?.mode).toBe("automatic");
    expect(config?.channelConfigs.email?.dirEmail).toBe("hotel@example.com");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/persistApprovedResponse.test.ts
---------------------------------
// /test/integration/persistApprovedResponse.test.ts

import { describe, it, expect, beforeAll } from "vitest";
import {
  saveMessageToAstra,
  updateMessageInAstra,
  getMessagesFromAstra,
  deleteTestMessagesFromAstra,
} from "@/lib/db/messages";
import { randomUUID } from "crypto";
import type { Channel, ChannelMessage, MessageStatus } from "@/types/channel";

describe("üß™ Persistencia de approvedResponse y respondedBy", () => {
  const messageId = `test-msg-${randomUUID()}`;
  const hotelId = "hotel123";
  const channel: Channel = "web";
  const status: MessageStatus = "pending";

  beforeAll(async () => {
    await deleteTestMessagesFromAstra();
  });

  it("deber√≠a guardar y luego actualizar un mensaje con approvedResponse", async () => {
    const initialMessage: ChannelMessage = {
      messageId,
      hotelId,
      channel,
      conversationId: `conv-${randomUUID()}`,
      sender: "Usuario Web",
      content: "¬øSe puede hacer check-in temprano?",
      timestamp: new Date().toISOString(),
      time: "10:15",
      suggestion: "S√≠, a partir de las 11 am sujeto a disponibilidad.",
      approvedResponse: undefined,
      respondedBy: undefined,
      status,
    };

    await saveMessageToAstra(initialMessage);

    const changes: Partial<ChannelMessage> = {
      approvedResponse: "S√≠, se puede hacer check-in a las 11 am.",
      respondedBy: "sofia@hotel.com",
      status: "sent",
    };

    await updateMessageInAstra(hotelId, messageId, changes);

    const results = await getMessagesFromAstra(hotelId, channel);
    const updated = results.find((msg) => msg.messageId === messageId);

    expect(updated).toBeDefined();
    expect(updated?.approvedResponse).toBe("S√≠, se puede hacer check-in a las 11 am.");
    expect(updated?.respondedBy).toBe("sofia@hotel.com");
    expect(updated?.status).toBe("sent");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/hotelConfigDynamicChannel.test.ts
---------------------------------
// /test/integration/hotelConfigDynamicChannel.test.ts
import { describe, it, expect } from "vitest";
import { updateHotelConfig, getHotelConfig } from "@/lib/config/hotelConfig.server";
import type { HotelConfig } from "@/types/channel";

describe("üß™ Configuraci√≥n din√°mica de canales", () => {
  it("permite agregar un canal din√°mico como 'tiktok'", async () => {
    const hotelId = "hotel123";

    // üëá Forzamos tipado relajado para canales no predefinidos
    const configUpdate: Partial<HotelConfig> = {
      channelConfigs: {
        ...( {
          tiktok: { enabled: true, mode: "supervised" }
        } as any )
      }
    };

    await updateHotelConfig(hotelId, configUpdate);
    const config = await getHotelConfig(hotelId);

    const tiktok = (config?.channelConfigs as any)?.tiktok;
    expect(tiktok).toBeDefined();
    expect(tiktok.enabled).toBe(true);
    expect(tiktok.mode).toBe("supervised");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/messagesByConversation.test.ts
---------------------------------
// /test/integration/messagesByConversation.test.ts
import { describe, it, expect } from "vitest";
import { getMessagesFromAstraByConversation } from "@/lib/db/messages";

// Par√°metros de prueba (us√° valores v√°lidos de tu entorno)
const TEST_HOTEL_ID = "hotel123";
const TEST_CONVERSATION_ID = "test-convo-001";
const TEST_CHANNEL = "web";

describe("üîç Mensajes por conversaci√≥n", () => {
  it("deber√≠a devolver los mensajes de una conversaci√≥n espec√≠fica y del hotel correcto", async () => {
    const messages = await getMessagesFromAstraByConversation(
      TEST_HOTEL_ID,
      TEST_CHANNEL,
      TEST_CONVERSATION_ID
    );

    expect(Array.isArray(messages)).toBe(true);
    expect(messages.length).toBeGreaterThanOrEqual(0); // puede no haber mensajes

    for (const msg of messages) {
      expect(msg.hotelId).toBe(TEST_HOTEL_ID);
      expect(msg.conversationId).toBe(TEST_CONVERSATION_ID);
      expect(msg.channel).toBe(TEST_CHANNEL);
    }
  });
});

---------------------------------


üîπ Archivo: ./test/integration/hotelConfig.test.ts
---------------------------------
// /root/begasist/test/integration/hotelConfig.test.ts
import { describe, it, expect } from "vitest";
import { updateHotelConfig, getHotelConfig } from "@/lib/config/hotelConfig.server";
import type { HotelConfig } from "@/types/channel";

describe("üß™ Configuraci√≥n din√°mica de canales", () => {
  it("permite agregar un canal din√°mico como 'tiktok' sin romper la estructura", async () => {
    const hotelId = "hotel123";

    const configUpdate: Partial<HotelConfig> = {
      channelConfigs: {
        tiktok: { enabled: true, mode: "supervised" }
      } as Record<string, any> // üëà esto permite propiedades din√°micas
    };

    await updateHotelConfig(hotelId, configUpdate);

    const config = await getHotelConfig(hotelId);
    const tiktokConfig = (config?.channelConfigs as Record<string, any>)["tiktok"];

    expect(tiktokConfig).toBeDefined();
    expect(tiktokConfig.enabled).toBe(true);
    expect(tiktokConfig.mode).toBe("supervised");
  });
});

---------------------------------


üîπ Archivo: ./test/integration/saveMessageToAstra.test.ts
---------------------------------
// /test/integration/saveMessageToAstra.email.test.ts

import { describe, it, expect } from "vitest";
import { saveMessageToAstra, getMessagesFromAstra } from "@/lib/db/messages";
import { randomUUID } from "crypto";
import type { ChannelMessage } from "@/types/channel";
import type { Channel } from "@/types/channel";
import type { MessageStatus } from "@/types/channel";

describe("üíæ Guardar mensaje del canal email en AstraDB", () => {
  const messageId = `test-email-${randomUUID()}`;
  const hotelId = "hotel123";
  const channel: Channel = "email";
  const status: MessageStatus = "pending";

  it("guarda un mensaje correctamente en la colecci√≥n global", async () => {
    const message: ChannelMessage = {
      messageId,
      hotelId,
      channel,
      sender: "cliente@email.com",
      content: "¬øHay habitaciones disponibles?",
      timestamp: new Date().toISOString(),
      status,
      respondedBy: undefined,
      approvedResponse: undefined,
      suggestion: "S√≠, tenemos habitaciones disponibles para hoy.",
      time: "12:00", // si es requerido por el tipo
      conversationId: "test-conv-1", // si es requerido por el tipo
    };

    await saveMessageToAstra(message);

    const results = await getMessagesFromAstra(hotelId, channel);
    const saved = results.find((m) => m.messageId === messageId);

    expect(saved).toBeDefined();
    expect(saved?.hotelId).toBe(hotelId);
    expect(saved?.channel).toBe(channel);
    expect(saved?.sender).toBe(message.sender);
    expect(saved?.content).toBe(message.content);
    expect(saved?.status).toBe(status);
  });
});

---------------------------------


üîπ Archivo: ./test/integration/getAllHotelConfigs.test.ts
---------------------------------
// /test/integration/getAllHotelConfigs.test.ts

import { describe, it, expect } from "vitest";
import { getAllHotelConfigs } from "@/lib/config/hotelConfig.server";
import dotenv from "dotenv";
dotenv.config(); // üß™ cargar .env antes de hacer cualquier otra cosa


describe("getAllHotelConfigs()", () => {
  it("deber√≠a devolver una lista de configuraciones de hotel v√°lidas", async () => {
    const hotels = await getAllHotelConfigs();

    expect(Array.isArray(hotels)).toBe(true);
    for (const hotel of hotels) {
      expect(typeof hotel.hotelId).toBe("string");
      expect(typeof hotel.hotelName).toBe("string");
      expect(typeof hotel.defaultLanguage).toBe("string");
      expect(typeof hotel.timezone).toBe("string");
      expect(typeof hotel.channelConfigs).toBe("object");
      expect(hotel.channelConfigs).not.toBeNull();
    }
  });
});

---------------------------------


üîπ Archivo: ./test/integration/getMessagesFromAstra.test.ts
---------------------------------
// /test/integration/getMessagesFromAstra.test.ts

import { describe, it, expect } from "vitest";
import { getMessagesFromAstra } from "@/lib/db/messages";

describe("üß™ getMessagesFromAstra", () => {
  it("recupera mensajes reales del canal web", async () => {
    const hotelId = "hotel123";
    const channel = "web";

    const messages = await getMessagesFromAstra(hotelId, channel);

    expect(Array.isArray(messages)).toBe(true);
    expect(messages.length).toBeGreaterThan(0);

    const msg = messages[0];
    expect(msg).toHaveProperty("messageId");
    expect(msg).toHaveProperty("hotelId", hotelId);
    expect(msg).toHaveProperty("channel", channel);
    expect(msg).toHaveProperty("sender");
    expect(msg).toHaveProperty("content");
    expect(msg).toHaveProperty("timestamp");
    expect(msg).toHaveProperty("time");
    expect(msg).toHaveProperty("status");
    expect(msg).toHaveProperty("suggestion");

    // Campos opcionales, si existen, se validan
    if (msg.conversationId) {
      expect(typeof msg.conversationId).toBe("string");
    }
    if (msg.approvedResponse) {
      expect(typeof msg.approvedResponse).toBe("string");
    }
    if (msg.respondedBy) {
      expect(typeof msg.respondedBy).toBe("string");
    }

    expect(["sent", "pending", "rejected", "expired"]).toContain(msg.status);
  });
});

---------------------------------


üîπ Archivo: ./test/integration/saveMessageToAstra.email.test.ts
---------------------------------
// /test/integration/saveMessageToAstra.email.test.ts

import { describe, it, expect } from "vitest";
import { saveMessageToAstra, getMessagesFromAstra } from "@/lib/db/messages";
import { randomUUID } from "crypto";
import type { ChannelMessage } from "@/types/channel";
import type { Channel } from "@/types/channel";
import type { MessageStatus } from "@/types/channel";

describe("üíæ Guardar mensaje del canal email en AstraDB", () => {
  const messageId = `test-email-${randomUUID()}`;
  const hotelId = "hotel123";
  const channel: Channel = "email";
  const status: MessageStatus = "pending";

  it("guarda un mensaje correctamente en la colecci√≥n global", async () => {
    const message: ChannelMessage = {
      messageId,
      conversationId: `conv-${randomUUID()}`,
      hotelId,
      channel,
      sender: "cliente@email.com",
      content: "¬øHay habitaciones disponibles?",
      timestamp: new Date().toISOString(),
      time: "13:22",
      status,
      suggestion: "S√≠, tenemos habitaciones disponibles para hoy.",
      approvedResponse: "Perfecto, ya le confirmo la reserva.",
      respondedBy: "recepcionista@hotel.com"
    };
    await saveMessageToAstra(message);

    const results = await getMessagesFromAstra(hotelId, channel);
    const saved = results.find((m) => m.messageId === messageId);

    

    expect(saved).toBeDefined();
    expect(saved?.hotelId).toBe(hotelId);
    expect(saved?.channel).toBe(channel);
    expect(saved?.sender).toBe(message.sender);
    expect(saved?.content).toBe(message.content);
    expect(saved?.status).toBe(status);
  });
});

---------------------------------


üîπ Archivo: ./test/integration/resetPassword.test.ts
---------------------------------
// /test/integration/resetPassword.test.ts
import { test, expect } from "vitest";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { randomUUID } from "crypto";
import { hash, compare } from "bcryptjs";

const TEST_EMAIL = "marcelomst1@gmail.com";
const HOTEL_ID = "hotel999";

// Utilidad para simular el token de recuperaci√≥n
async function prepareUserWithResetToken() {
  const config = await getHotelConfig(HOTEL_ID);
  if (!config?.users) throw new Error("Hotel o usuarios no encontrados");

  const user = config.users.find((u) => u.email === TEST_EMAIL);
  if (!user) throw new Error("Usuario de test no encontrado");

  const token = randomUUID();
  user.resetToken = token;
  user.resetTokenExpires = new Date(Date.now() + 60 * 60 * 1000).toISOString();

  const oldPassword = user.passwordHash;
  await updateHotelConfig(HOTEL_ID, { users: config.users });

  return { token, oldPassword };
}

test("reset-password actualiza la contrase√±a correctamente", async () => {
  const { token, oldPassword } = await prepareUserWithResetToken();

  const newPassword = "Nueva123!";

  const res = await fetch("http://localhost:3000/api/reset-password", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ token, newPassword })
  });

  expect(res.status).toBe(200);
  const data = await res.json();
  expect(data.ok).toBe(true);

  // Verificamos que el hash haya cambiado y que coincida con el nuevo password
  const updated = await getHotelConfig(HOTEL_ID);
  const user = updated?.users?.find((u) => u.email === TEST_EMAIL);
  expect(user).toBeDefined();
  expect(user?.resetToken).toBeUndefined();
  expect(user?.resetTokenExpires).toBeUndefined();
  expect(user?.passwordHash).not.toBe(oldPassword);
  const match = await compare(newPassword, user!.passwordHash!);
  expect(match).toBe(true);
});

---------------------------------


üîπ Archivo: ./test/integration/UserStatus.test.tsx
---------------------------------
// /root/begasist/test/integration/UserStatus.test.tsx
import React, { useState, useEffect, createContext, useContext } from "react";
import { describe, it, expect, beforeEach } from "vitest";
import { vi, Mock } from "vitest";
import "@testing-library/jest-dom";


import { render, screen, waitFor, fireEvent } from "@testing-library/react";
import UserStatus from "@/components/UsertStatus.tsx";
import { UserProvider } from "@/lib/context/UserContext";

// üîß Mock de fetchWithAuth
vi.mock("@/lib/client/fetchWithAuth", () => ({
  fetchWithAuth: vi.fn(),
}));

import { fetchWithAuth as fetchWithAuthOriginal } from "@/lib/client/fetchWithAuth";
const fetchWithAuth = fetchWithAuthOriginal as unknown as Mock;


describe("<UserStatus />", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("muestra datos del usuario despu√©s de cargar", async () => {
    
    fetchWithAuth.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        email: "admin@hotel.com",
        hotelId: "hotel123",
        roleLevel: 0,
        userId: "abc123",
      }),
    } as Response);
    

    render(
      <UserProvider>
        <UserStatus />
      </UserProvider>
    );

    expect(screen.getByText(/Cargando usuario/i)).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.getByText(/admin@hotel\.com/i)).toBeInTheDocument();
      expect(screen.getByText((t) => t.includes("hotel123"))).toBeInTheDocument();
      expect(screen.getByText(/0/)).toBeInTheDocument(); // roleLevel
    });
  });

  it("refresca usuario al hacer clic en el bot√≥n", async () => {
    fetchWithAuth
      // primer loadUser
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          email: "admin@hotel.com",
          hotelId: "hotel123",
          roleLevel: 0,
          userId: "abc123",
        }),
      })
      // segundo loadUser (tras refresh)
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          email: "admin@hotel.com",
          hotelId: "hotel123",
          roleLevel: 1,
          userId: "abc123",
        }),
      });

    render(
      <UserProvider>
        <UserStatus />
      </UserProvider>
    );

    await screen.findByText((t) => t.includes("admin@hotel.com"));


    const btn = screen.getByRole("button", { name: /refrescar/i });
    fireEvent.click(btn);

    await waitFor(() => {
      expect(
        screen.getByText((t) => t.includes("Rol") && t.includes("1"))
      ).toBeInTheDocument();
       // nuevo roleLevel
    });
  });
  it("muestra error si el usuario no est√° autenticado (401)", async () => {
    fetchWithAuth.mockResolvedValueOnce({
      ok: false,
      status: 401,
      json: async () => ({ error: "No autorizado" }),
    } as Response);
  
    render(
      <UserProvider>
        <UserStatus />
      </UserProvider>
    );
  
    await waitFor(() => {
      expect(
        screen.getByText((text) => text.toLowerCase().includes("no autorizado"))
      ).toBeInTheDocument();
      
    });
  });
});


---------------------------------


üîπ Archivo: ./test/components/ChannelMessages.test.tsx
---------------------------------
// /test/components/ChannelMessages.test.tsx

import React from "react";
import { describe, it, expect, beforeEach, vi } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import ChannelMessages from "@/components/admin/ChannelMessages";
import type { ChannelMessage, Channel } from "@/types/channel";

function mockFetchResponse(messages: ChannelMessage[]) {
  vi.stubGlobal("fetch", vi.fn(async () => ({
    ok: true,
    json: async () => ({ messages }),
  })));
}

const baseMessage = {
  sender: "Usuario Web",
  hotelId: "hotel123",
  channel: "web" as Channel,
  approvedResponse: undefined,
  respondedBy: "sofia@hotel.com",
};

vi.mock("@/lib/services/webMemory", () => ({
  webMemory: {
    getMessages: () => [
      {
        messageId: "msg-1",
        ...baseMessage,
        timestamp: new Date("2025-04-17T18:39:58.000Z").toISOString(),
        content: "¬øHasta qu√© hora es el check-in?",
        suggestion: "El check-in es hasta la 1 pm.",
        status: "pending",
      },
    ],
    updateMessage: vi.fn(() => true),
  },
}));

beforeEach(() => {
  vi.resetAllMocks();
  mockFetchResponse([
    {
      messageId: "msg-1",
      ...baseMessage,
      timestamp: new Date("2025-04-17T18:39:58.000Z").toISOString(),
      content: "¬øHasta qu√© hora es el check-in?",
      suggestion: "El check-in es hasta la 1 pm.",
      status: "pending",
      time: "",
    },
  ]);
});

describe("<ChannelMessages />", () => {
  const channelId: Channel = "web";
  const userEmail = "sofia@hotel.com";

  it("renderiza los mensajes correctamente", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    expect(await screen.findByText(/¬øHasta qu√© hora es el check-in/i)).toBeInTheDocument();
    expect(await screen.findByText(/Sugerencia del asistente/i)).toBeInTheDocument();
  });

  it("permite editar un mensaje y guardar", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    await screen.findByText(/¬øHasta qu√© hora es el check-in/i);
    fireEvent.click(screen.getByText("‚úèÔ∏è Editar"));
    const textarea = screen.getByRole("textbox");
    fireEvent.change(textarea, { target: { value: "Nuevo texto editado" } });
    fireEvent.click(screen.getByText("‚úÖ Guardar"));
    expect(await screen.findByDisplayValue("Nuevo texto editado")).toBeInTheDocument();
  });

  it("permite cancelar la edici√≥n de un mensaje", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    await screen.findByText(/¬øHasta qu√© hora es el check-in/i);
    fireEvent.click(screen.getByText("‚úèÔ∏è Editar"));
    const textarea = screen.getByRole("textbox");
    fireEvent.change(textarea, { target: { value: "Texto no guardado" } });
    fireEvent.click(screen.getByText("‚ùå Cancelar"));
    expect(await screen.findByDisplayValue("El check-in es hasta la 1 pm.")).toBeInTheDocument();
  });

  it("muestra correctamente el campo respondedBy", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    expect(await screen.findByText(/Respondido por: sofia@hotel.com/i)).toBeInTheDocument();
  });

  it("cambia el estado a 'sent' al hacer clic en '‚úÖ Enviar'", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    await screen.findByText(/¬øHasta qu√© hora es el check-in/i);
    fireEvent.click(screen.getByText("‚úÖ Enviar"));
    expect(await screen.findByText("‚úÖ Enviado")).toBeInTheDocument();
  });

  it("muestra 'üîÅ Reenviar' si el mensaje ya fue enviado", async () => {
    mockFetchResponse([
      {
        messageId: "msg-2",
        ...baseMessage,
        timestamp: new Date().toISOString(),
        content: "¬øHay estacionamiento?",
        suggestion: "S√≠, tenemos estacionamiento gratuito.",
        status: "sent",
        time: ""
      },
    ]);
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    expect(await screen.findByText("üîÅ Reenviar")).toBeInTheDocument();
  });

  it("muestra solo 2 mensajes por p√°gina y permite paginar", async () => {
    const mockMessages: ChannelMessage[] = Array.from({ length: 4 }).map((_, i) => ({
      messageId: `msg-${i + 1}`,
      ...baseMessage,
      timestamp: new Date(`2025-04-17T1${i}:00:00.000Z`).toISOString(),
      content: `Mensaje n√∫mero ${i + 1}`,
      suggestion: `Respuesta ${i + 1}`,
      status: "pending",
      time: "",
    }));
    mockMessages.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    mockFetchResponse(mockMessages);

    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    expect(await screen.findByText("Mensaje n√∫mero 4")).toBeInTheDocument();
    fireEvent.click(screen.getByText(/Siguiente/i));
    expect(await screen.findByText("Mensaje n√∫mero 1")).toBeInTheDocument();
    fireEvent.click(screen.getByText(/Anterior/i));
    await waitFor(() => {
      expect(screen.getByText("Mensaje n√∫mero 4")).toBeInTheDocument();
    });
  });

  it("actualiza el estado a 'rejected' al hacer clic en '‚ùå Rechazar'", async () => {
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    await screen.findByText(/¬øHasta qu√© hora es el check-in/i);
    fireEvent.click(screen.getByText("‚ùå Rechazar"));
    expect(await screen.findByText("‚ùå Rechazado")).toBeInTheDocument();
  });

  it("permite reenviar un mensaje con 'üîÅ Reenviar' y muestra '‚úÖ Enviado'", async () => {
    mockFetchResponse([
      {
        messageId: "msg-2",
        ...baseMessage,
        timestamp: new Date().toISOString(),
        content: "¬øHay estacionamiento?",
        suggestion: "S√≠, tenemos estacionamiento gratuito.",
        status: "sent",
        time: "",
      },
    ]);
    render(<ChannelMessages channelId={channelId} userEmail={userEmail} mode="supervised" />);
    await screen.findByText("üîÅ Reenviar");
    fireEvent.click(screen.getByText("üîÅ Reenviar"));
    expect(await screen.findByText("‚úÖ Enviado")).toBeInTheDocument();
  });
});

---------------------------------


üîπ Archivo: ./app/auth/change-password/page.tsx
---------------------------------
// /root/begasist/app/auth/change-password/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
export default function ChangePasswordPage() {
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [message, setMessage] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setLoading(true);
    setMessage(null);

    try {
      const res = await fetch("/api/me/change-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },        
        body: JSON.stringify({ currentPassword, newPassword }),
      });

      const data = await res.json();

      if (!res.ok) {
        setMessage(data.error || "Error desconocido");
      } else {
        setMessage("‚úÖ Contrase√±a actualizada correctamente.");
        setCurrentPassword("");
        setNewPassword("");
        setTimeout(() => {
          router.push("/admin");
        }, 3000);
      }
    } catch (err) {
      setMessage("‚ùå Error al enviar la solicitud.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="max-w-md mx-auto mt-10 p-4 border rounded shadow">
      <h2 className="text-xl font-semibold mb-4">Cambiar contrase√±a</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block mb-1">Contrase√±a actual</label>
          <input
            type="password"
            value={currentPassword}
            onChange={(e) => setCurrentPassword(e.target.value)}
            className="w-full border px-3 py-2 rounded"
            required
          />
        </div>
        <div>
          <label className="block mb-1">Nueva contrase√±a</label>
          <input
            type="password"
            value={newPassword}
            onChange={(e) => setNewPassword(e.target.value)}
            className="w-full border px-3 py-2 rounded"
            required
          />
        </div>
        <button
          type="submit"
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          disabled={loading}
        >
          {loading ? "Actualizando..." : "Cambiar contrase√±a"}
        </button>
      </form>
      {message && <p className="mt-4 text-sm text-red-600">{message}</p>}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/auth/login/page.tsx
---------------------------------
// /app/auth/login/page.tsx

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { toast } from "sonner";

export default function LoginPage() {
  const router = useRouter();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  // Cambiado: Un array que tiene userId y hotelId para cada hotel donde el user est√° activo
  const [hotelsData, setHotelsData] = useState<{ userId: string; hotelId: string; name: string }[]>([]);

  const [status, setStatus] = useState<"idle" | "loading" | "error" | "success">("idle");
  const [message, setMessage] = useState("");

  const handleSubmit = async () => {
    setStatus("loading");
    setMessage("");
    setHotelsData([]); // Limpia para cada submit

    const res = await fetch("/api/users/hotels-for-user", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });

    const data = await res.json();

    if (!res.ok) {
      setStatus("error");
      setMessage(data.message || "Error desconocido");
      toast.error(data.message || "Error al validar usuario");
      return;
    }
    console.log("Autologin:",data.autoLogin);
    console.log("Hoteles:",data.hotels);
    // Si solo hay un hotel, loguea directo
    if (data.autoLogin && data.hotels.length === 1) {
      await loginWithHotel(data.hotels[0].userId, data.hotels[0].hotelId);
    } else if (data.hotels.length > 1) {
      // Si hay varios hoteles, arma la lista de opciones con userId y hotelId ya juntos
      setHotelsData(data.hotels); // ya viene la lista [{userId, hotelId, name}]
      setStatus("idle");
    }
  };
  const loginWithHotel = async (userId: string, hotelId: string) => {
    console.log("userId antes de fetch", userId);
    console.log("hotelId antes de fetch", hotelId);

    const res = await fetch("/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ userId, hotelId }),
    });
    const data = await res.json();

    if (res.ok) {
      setStatus("success");
      toast.success("Bienvenido üëã");
      router.push("/admin");
    } else {
      setStatus("error");
      setMessage(data.error || "Error al iniciar sesi√≥n");
      toast.error(data.error || "Error al iniciar sesi√≥n");
    }
  };

  return (
    <div className="max-w-sm mx-auto mt-20 p-4 border rounded-xl shadow bg-white text-black">
      <h1 className="text-xl font-semibold mb-4">Login de Hotel</h1>

      {/* Si ya hay opciones de hoteles: mostrar selecci√≥n */}
      {hotelsData.length > 0 ? (
        <>
          <p className="mb-2">Selecciona tu hotel:</p>
          {hotelsData.map((h) => (
            <button
              key={h.hotelId}
              className="w-full mb-2 p-2 border rounded hover:bg-gray-100 text-left"
              onClick={() => loginWithHotel(h.userId, h.hotelId)}
            >
              {h.name}
            </button>
          ))}
        </>
      ) : (
        <>
          {/* Formulario de login */}
          <input
            type="email"
            placeholder="Email"
            className="w-full mb-3 p-2 border rounded"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <input
            type="password"
            placeholder="Contrase√±a"
            className="w-full mb-3 p-2 border rounded"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          <button
            onClick={handleSubmit}
            disabled={status === "loading"}
            className="w-full p-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {status === "loading" ? "Ingresando..." : "Ingresar"}
          </button>
        </>
      )}

      {message && (
        <p className={`mt-4 text-sm ${status === "error" ? "text-red-600" : "text-green-600"}`}>
          {message}
        </p>
      )}

      <p className="text-sm mt-4 text-center">
        <a href="/auth/forgot-password" className="text-blue-600 hover:underline">
          ¬øOlvidaste tu contrase√±a?
        </a>
      </p>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/auth/forgot-password/page.tsx
---------------------------------
// /app/auth/forgot-password/page.tsx
"use client";

import { useState } from "react";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/button";

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState("");
  const [hotelId, setHotelId] = useState(""); // üëà ahora p√∫blico y obligatorio
  const [status, setStatus] = useState<"idle" | "loading" | "success" | "error">("idle");
  const [message, setMessage] = useState("");

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setStatus("idle");
    setMessage("");

    if (!hotelId.trim()) {
      setStatus("error");
      setMessage("Por favor, ingres√° el Hotel ID.");
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email.trim() || !emailRegex.test(email)) {
      setStatus("error");
      setMessage("Por favor, ingres√° un email v√°lido.");
      return;
    }

    setStatus("loading");
    try {
      const res = await fetch("/api/users/send-recovery-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ hotelId, email }),
      });

      if (res.ok) {
        setStatus("success");
        setMessage("üìß Email de recuperaci√≥n enviado correctamente.");
        setEmail("");
      } else {
        const data = await res.json();
        setStatus("error");
        setMessage(`Error: ${data.error || "No se pudo enviar el email."}`);
      }
    } catch (err) {
      setStatus("error");
      setMessage("Error de red al intentar enviar el email.");
    }
  }

  return (
    <div className="max-w-md mx-auto mt-20 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-4">üîë Recuperar contrase√±a</h1>
      <p className="text-sm mb-4 text-zinc-600 dark:text-zinc-400">
        Ingres√° tu correo electr√≥nico registrado y el ID de tu hotel.
      </p>
      <form onSubmit={handleSubmit} className="space-y-4">
        <Input
          placeholder="hotel999"
          value={hotelId}
          onChange={(e) => setHotelId(e.target.value)}
          disabled={status === "loading"}
        />
        <Input
          type="email"
          placeholder="usuario@hotel.com"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          disabled={status === "loading"}
        />
        <Button type="submit" disabled={status === "loading"}>
          {status === "loading" ? "Enviando..." : "Enviar"}
        </Button>
        {status !== "idle" && (
          <div
            className={`text-sm ${
              status === "success" ? "text-green-600" : "text-red-600"
            }`}
          >
            {message}
          </div>
        )}
      </form>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/auth/verify-account/page.tsx
---------------------------------
// /app/auth/verify-account/page.tsx
import { verifyUserAccount } from "@/lib/auth/verifyUserAccount";
import { redirect } from "next/navigation";

export default async function VerifyAccountPage({
  searchParams,
}: {
  searchParams: { token?: string };
}) {
  const token = searchParams?.token ?? null; // ‚úÖ acceder como propiedad

  if (!token) {
    return (
      <div className="text-red-600 p-4">Token de verificaci√≥n faltante.</div>
    );
  }

  const result = await verifyUserAccount(token);

  if (!result.ok) {
    return (
      <div className="text-red-600 p-4">‚ùå Verificaci√≥n fallida: {result.error}</div>
    );
  }

  // Si quer√©s redirigir directamente seg√∫n el rol, puedes hacerlo aqu√≠:
  if (result.roleLevel < 20) {
    redirect("/admin");
  }

  // UI cliente sin hooks, 100% seguro SSR
  return (
    <div className="max-w-md mx-auto mt-20 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-4 text-green-600">‚úÖ Cuenta verificada correctamente.</h1>
      <p className="text-sm text-zinc-600 dark:text-zinc-400 mb-4">
        Ahora deb√©s establecer tu contrase√±a usando la opci√≥n{" "}
        <strong>"¬øOlvidaste tu contrase√±a?"</strong> en la pantalla de login.
      </p>
      <a
        href="/auth/login"
        className="text-blue-600 underline"
      >
        Ir al login
      </a>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/auth/reset-password/page.tsx
---------------------------------
// /app/auth/reset-password/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/button";

type Status = "idle" | "validating" | "validated" | "submitting" | "success" | "error";

export default function ResetPasswordPage() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const token = searchParams?.get("token");

  const [status, setStatus] = useState<Status>("validating");
  const [message, setMessage] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  useEffect(() => {
    if (!token) {
      setStatus("error");
      setMessage("Falta el token de verificaci√≥n.");
      return;
    }

    async function validateToken() {
      try {
        const res = await fetch("/api/users/validate-reset-token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token }),
        });

        if (res.ok) {
          setStatus("validated");
        } else {
          const data = await res.json();
          setStatus("error");
          setMessage(data.error || "Token inv√°lido.");
        }
      } catch {
        setStatus("error");
        setMessage("Error de red al validar el token.");
      }
    }

    validateToken();
  }, [token]);

async function handleSubmit(e: React.FormEvent) {
  e.preventDefault();
  setStatus("submitting");
  setMessage("");

  if (!newPassword || !confirmPassword) {
    setStatus("error");
    setMessage("Por favor, complet√° ambos campos.");
    return;
  }

  if (newPassword !== confirmPassword) {
    setStatus("error");
    setMessage("Las contrase√±as no coinciden.");
    return;
  }

  try {
    const res = await fetch("/api/users/reset-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ token, newPassword }),
    });

    if (res.ok) {
      setStatus("success");
      setMessage("‚úÖ Contrase√±a actualizada. Ya pod√©s iniciar sesi√≥n.");
      setTimeout(() => {
        router.push("/auth/login");
      }, 2000);
    } else {
      const data = await res.json();
      setStatus("error");
      setMessage(`Error: ${data.error || "No se pudo actualizar la contrase√±a."}`);
    }
  } catch (err) {
    setStatus("error");
    setMessage("Error de red al intentar actualizar la contrase√±a.");
  }
}


  return (
    <div className="max-w-md mx-auto mt-20 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-4">üîê Establecer nueva contrase√±a</h1>

      {status === "validating" && <p className="text-sm text-zinc-500">Validando token...</p>}

{(status === "validated" || status === "submitting") && (
  <form onSubmit={handleSubmit} className="space-y-4">
    <Input
      type="password"
      placeholder="Nueva contrase√±a"
      value={newPassword}
      onChange={(e) => setNewPassword(e.target.value)}
      disabled={status === "submitting"}
    />
    <Input
      type="password"
      placeholder="Confirmar contrase√±a"
      value={confirmPassword}
      onChange={(e) => setConfirmPassword(e.target.value)}
      disabled={status === "submitting"}
    />
    <Button type="submit" disabled={status === "submitting"}>
      {status === "submitting" ? "Guardando..." : "Restablecer"}
    </Button>
  </form>
)}


      {status === "success" && (
        <p className="text-green-600 text-sm mt-4">{message}</p>
      )}

      {status === "error" && (
        <p className="text-red-600 text-sm mt-4">{message}</p>
      )}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/embeddings/page.tsx
---------------------------------
// /app/admin/embeddings/page.tsx
export default function EmbeddingsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Embeddings</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/admin/send-verification/page.tsx
---------------------------------
"use client";

import { useState } from "react";

export default function SendVerificationPage() {
  const [email, setEmail] = useState("");
  const [hotelId, setHotelId] = useState("hotel999");
  const [status, setStatus] = useState<"idle" | "loading" | "sent" | "error">("idle");
  const [error, setError] = useState("");

  const handleSend = async () => {
    setStatus("loading");
    setError("");

    const res = await fetch("/api/send-verification-email", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, hotelId }),
    });

    if (res.ok) {
      setStatus("sent");
    } else {
      const data = await res.json();
      setError(data.error || "Error al enviar el email.");
      setStatus("error");
    }
  };

  return (
    <div className="max-w-md mx-auto mt-20 p-6 border rounded-xl shadow text-center space-y-4">
      <h2 className="text-xl font-semibold">Enviar email de verificaci√≥n</h2>

      <input
        className="w-full p-2 border rounded"
        type="email"
        placeholder="Email del usuario"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />

      <input
        className="w-full p-2 border rounded"
        type="text"
        placeholder="Hotel ID"
        value={hotelId}
        onChange={(e) => setHotelId(e.target.value)}
      />

      <button
        onClick={handleSend}
        className="px-4 py-2 bg-blue-600 text-white rounded disabled:opacity-50"
        disabled={status === "loading"}
      >
        Enviar email
      </button>

      {status === "sent" && <p className="text-green-600">üìß Email enviado correctamente.</p>}
      {status === "error" && <p className="text-red-600">‚ùå {error}</p>}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/prompts/page.tsx
---------------------------------
// /app/admin/prompts/page.tsx
export default function PromptsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Prompts</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/admin/channels/page.tsx
---------------------------------
// /app/admin/channels/page.tsx

// ‚úÖ P√°gina de administraci√≥n de canales
import { getHotelConfig } from "@/lib/config/hotelConfig.server";
import ChannelsClient from "@/components/admin/ChannelsClient";
import { BarChart3 } from "lucide-react";

export default async function ChannelsPage() {
  const hotelId = "hotel123";
  const config = await getHotelConfig(hotelId);

  if (!config) {
    return (
      <div className="min-h-screen bg-background text-foreground py-12 px-6">
        <h1 className="text-3xl font-bold mb-6 flex items-center gap-2">
          <BarChart3 className="w-6 h-6" />
          Estado de Canales
        </h1>
        <p className="text-red-500">‚ùå Error: no se pudo cargar la configuraci√≥n del hotel.</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground py-12 px-6">
      <h1 className="text-3xl font-bold mb-6 flex items-center gap-2">
        <BarChart3 className="w-6 h-6" />
        Estado de Canales
      </h1>

      <ChannelsClient initialConfig={config.channelConfigs} />
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/delete/route.ts
---------------------------------
// /app/api/users/delete/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId, userId } = await req.json();

  if (!hotelId || !userId) {
    return NextResponse.json({ error: "Faltan hotelId o userId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config) {
    return NextResponse.json({ error: "Hotel no encontrado" }, { status: 404 });
  }

const users = config.users ?? [];
const remainingUsers = users.filter((u) => u.userId !== userId);

if (remainingUsers.length === users.length) {
  return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
}


  await updateHotelConfig(hotelId, { users: remainingUsers });

  return NextResponse.json({ success: true });
}

---------------------------------


üîπ Archivo: ./app/admin/users/verification/page.tsx
---------------------------------
// /app/admin/users/verification/page.tsx
"use client";

import { useState } from "react";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/button";
import { MailCheck } from "lucide-react";
import { useCurrentUser } from "@/lib/context/UserContext";

export default function UserVerificationPage() {
  const { user } = useCurrentUser(); // ‚úÖ dentro del componente
  const hotelId = user?.hotelId;

  const [email, setEmail] = useState("");
  const [status, setStatus] = useState<"idle" | "success" | "error" | "loading">("idle");
  const [message, setMessage] = useState("");

  const sendVerification = async () => {
    if (!hotelId) {
      setMessage("Hotel no identificado.");
      setStatus("error");
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email.trim() || !emailRegex.test(email)) {
      setMessage("Ingres√° un email v√°lido.");
      setStatus("error");
      return;
    }

    setStatus("loading");
    try {
      const res = await fetch("/api/send-verification-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ hotelId, email }),
      });

      if (res.ok) {
        setStatus("success");
        setMessage("üìß Email enviado correctamente.");
        setEmail("");
      } else {
        const data = await res.json();
        setStatus("error");
        setMessage(`Error: ${data.error || "No se pudo enviar el email."}`);
      }
    } catch (err) {
      setStatus("error");
      setMessage("Error de red al enviar el email.");
    }
  };

  return (
    <div className="max-w-xl mx-auto mt-10 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow-md">
      <h1 className="text-2xl font-bold mb-4 flex items-center gap-2">
        <MailCheck size={24} /> Verificaci√≥n de usuarios
      </h1>

      <p className="text-sm mb-4 text-zinc-600 dark:text-zinc-400">
        Ingres√° el correo electr√≥nico del usuario al que quer√©s reenviar el email de verificaci√≥n.
      </p>

      <div className="flex items-center gap-2">
        <Input
          placeholder="usuario@hotel.com"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <Button onClick={sendVerification} disabled={status === "loading"}>
          Enviar
        </Button>
      </div>

      {status !== "idle" && (
        <div
          className={`mt-4 text-sm ${
            status === "success" ? "text-green-600" : "text-red-600"
          }`}
        >
          {message}
        </div>
      )}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/manage/new/page.tsx
---------------------------------
// /app/admin/users/manage/new/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { useCurrentUser } from "@/lib/context/UserContext";

export default function CreateUserPage() {
  const { user } = useCurrentUser();
  const router = useRouter();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");
  const [position, setPosition] = useState("");
  const [roleLevel, setRoleLevel] = useState(20);
  const [error, setError] = useState("");
  const [saving, setSaving] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError("");
    setSaving(true);

    if (!user?.hotelId) {
      setError("Hotel no identificado");
      setSaving(false);
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      setError("El email no tiene un formato v√°lido.");
      setSaving(false);
      return;
    }

    if (!email.trim() || !password.trim()) {
      setError("Email y contrase√±a son obligatorios");
      setSaving(false);
      return;
    }
    if (!name.trim()) {
      setError("El nombre es obligatorio");
      setSaving(false);
      return;
    }
    if (!position.trim()) {
      setError("El cargo es obligatorio");
      setSaving(false);
      return;
    }

    const res = await fetch("/api/users/create", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        hotelId: user.hotelId,
        email,
        password,
        name,
        position,
        roleLevel,
      }),
    });

    setSaving(false);

    if (!res.ok) {
      const data = await res.json();
      setError(data.error || "Error al crear usuario");
      return;
    }

    router.push("/admin/users/manage");
  }

  return (
    <div className="max-w-xl mx-auto mt-10 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-6">‚ûï Alta de nuevo usuario</h1>
      <form onSubmit={handleSubmit} className="space-y-4">
        <input
          type="email"
          placeholder="Email del usuario"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full border p-2 rounded"
          required
        />
        <input
          type="password"
          placeholder="Contrase√±a"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full border p-2 rounded"
          required
        />
        <input
          type="text"
          placeholder="Nombre"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="w-full border p-2 rounded"
          required
        />
        <input
          type="text"
          placeholder="Cargo (ej: Recepcionista, Gerente)"
          value={position}
          onChange={(e) => setPosition(e.target.value)}
          className="w-full border p-2 rounded"
          required
        />
        <select
          value={roleLevel}
          onChange={(e) => setRoleLevel(parseInt(e.target.value))}
          className="w-full border p-2 rounded"
          required
        >
          <option value={0}>üë®‚Äçüíª Admin T√©cnico (0)</option>
          <option value={15}>üßë‚Äçüíº Gerente (15)</option>
          <option value={20}>üë©‚Äçüíº Recepcionista (20)</option>
        </select>
        {error && <p className="text-red-600 text-sm">{error}</p>}
        <div className="flex justify-between">
          <Button variant="secondary" type="button" onClick={() => router.back()}>
            ‚Üê Cancelar
          </Button>
          <Button type="submit" disabled={saving}>
            {saving ? "Creando..." : "Crear usuario"}
          </Button>
        </div>
      </form>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/manage/[userId]/page.tsx
---------------------------------
// /app/admin/users/manage/[userId]/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { useCurrentUser } from "@/lib/context/UserContext";
import type { HotelUser } from "@/types/user";

export default function EditUserPage() {
  const params = useParams();
  if (!params) {
    return <p className="p-6">No se especific√≥ el ID del usuario.</p>;
  }
  const userId = Array.isArray(params.userId) ? params.userId[0] : params.userId; // acceso seguro

  const router = useRouter();
  const { user } = useCurrentUser();
  const [targetUser, setTargetUser] = useState<HotelUser | null>(null);
  const [error, setError] = useState("");
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    async function fetchUser() {
      if (!user?.hotelId || !userId) return;
      const res = await fetch("/api/users/get", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ hotelId: user.hotelId, userId }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "Error al obtener usuario");
      } else {
        setTargetUser(data.user);
      }
    }
    fetchUser();
  }, [user?.hotelId, userId]);

  async function handleSubmit(e: React.FormEvent) {
  e.preventDefault();
  setError("");
  setSaving(true);

  if (!user?.hotelId || !targetUser) return;

  // Validaci√≥n frontend
  if (!targetUser.name?.trim()) {
    setError("El nombre es obligatorio.");
    setSaving(false);
    return;
  }
  if (!targetUser.position?.trim()) {
    setError("El cargo es obligatorio.");
    setSaving(false);
    return;
  }
  if (isNaN(targetUser.roleLevel)) {
    setError("Seleccion√° un rol v√°lido.");
    setSaving(false);
    return;
  }

    const res = await fetch("/api/users/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hotelId: user.hotelId, user: targetUser }),
    });

    setSaving(false);

    if (!res.ok) {
      const data = await res.json();
      setError(data.error || "Error al actualizar usuario");
    } else {
      router.push("/admin/users/manage");
    }
  }

  if (!targetUser) return <p className="p-6">Cargando usuario...</p>;

  return (
    <div className="max-w-xl mx-auto mt-10 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-6">‚úèÔ∏è Editar usuario</h1>
      <form onSubmit={handleSubmit} className="space-y-4">
        <input
          type="text"
          placeholder="Nombre"
          value={targetUser.name || ""}
          onChange={(e) => setTargetUser({ ...targetUser, name: e.target.value })}
          className="w-full border p-2 rounded"
        />
        <input
          type="text"
          placeholder="Cargo"
          value={targetUser.position || ""}
          onChange={(e) => setTargetUser({ ...targetUser, position: e.target.value })}
          className="w-full border p-2 rounded"
        />
        <select
          value={targetUser.roleLevel}
          onChange={(e) => setTargetUser({ ...targetUser, roleLevel: parseInt(e.target.value) })}
          className="w-full border p-2 rounded"
        >
          <option value={0}>üë®‚Äçüíª Admin T√©cnico (0)</option>
          <option value={15}>üßë‚Äçüíº Gerente (15)</option>
          <option value={20}>üë©‚Äçüíº Recepcionista (20)</option>
        </select>
        {error && <p className="text-red-600 text-sm">{error}</p>}
        <div className="flex justify-between">
          <Button variant="secondary" type="button" onClick={() => router.back()}>
            ‚Üê Cancelar
          </Button>
          <Button type="submit" disabled={saving}>
            {saving ? "Guardando..." : "Guardar cambios"}
          </Button>
        </div>
      </form>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/manage/page.tsx
---------------------------------
// /app/admin/users/manage/page.tsx
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { BegasistTable } from "@/components/ui/BegasistTable";
import { MailCheck, Pencil, Trash2, UserMinus, UserPlus } from "lucide-react";
import { useCurrentUser } from "@/lib/context/UserContext";
import { useRouter } from "next/navigation";
import type { HotelUser } from "@/types/user";

export default function ManageUsersPage() {
  const { user } = useCurrentUser();
  const router = useRouter();
  const [users, setUsers] = useState<HotelUser[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUsers() {
      if (!user?.hotelId) return;
      setLoading(true);
      const res = await fetch("/api/users/list", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ hotelId: user.hotelId }),
      });
      const data = await res.json();
      setUsers(data.users || []);
      setLoading(false);
    }
    fetchUsers();
  }, [user?.hotelId]);

  async function handleDelete(userId: string) {
    if (!user?.hotelId) return;
    if (!window.confirm("¬øEst√°s seguro de eliminar este usuario?")) return;

    const res = await fetch("/api/users/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hotelId: user.hotelId, userId }),
    });

    if (res.ok) {
      setUsers((prev) => prev.filter((u) => u.userId !== userId));
    } else {
      const data = await res.json();
      alert(data.error || "Error al eliminar usuario");
    }
  }

  async function handleResendVerification(email: string) {
    if (!user?.hotelId) return;

    const res = await fetch("/api/users/send-verification-email", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hotelId: user.hotelId, email }),
    });

    if (res.ok) {
      alert("üìß Invitaci√≥n reenviada.");
    } else {
      const data = await res.json();
      alert(data.error || "Error al reenviar invitaci√≥n");
    }
  }

  async function handleToggleActive(u: HotelUser) {
    if (!user?.hotelId) return;

    const res = await fetch("/api/users/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        hotelId: user.hotelId,
        user: { ...u, active: !u.active },
      }),
    });

    if (res.ok) {
      setUsers((prev) =>
        prev.map((item) =>
          item.userId === u.userId ? { ...item, active: !u.active } : item
        )
      );
    } else {
      const data = await res.json();
      alert(data.error || "Error al actualizar estado");
    }
  }

  return (
    <div className="max-w-6xl mx-auto mt-10 p-6 bg-white dark:bg-zinc-900 rounded-xl shadow">
      <h1 className="text-2xl font-bold mb-6">üë• Administraci√≥n de usuarios</h1>
      {loading ? (
        <p>Cargando...</p>
      ) : (
        <>
          <div className="flex justify-end mb-4">
            <Button onClick={() => router.push("/admin/users/manage/new")}>
              ‚ûï Nuevo usuario
            </Button>
          </div>
          <BegasistTable headers={["Email", "Nombre", "Cargo", "Rol", "Estado", "Creado", "Acciones"]}>
            {users.map((u) => (
              <tr key={u.userId} className="border-b hover:bg-zinc-50 dark:hover:bg-zinc-800">
                <td className="p-3">{u.email}</td>
                <td className="p-3">
                  {u.name || <span className="text-zinc-500 italic">Sin nombre</span>}
                </td>
                <td className="p-3">
                  {u.position || <span className="text-zinc-500 italic">Sin cargo</span>}
                </td>
                <td className="p-3">{u.roleLevel}</td>
                <td className="p-3">
                  {u.active ? "‚úÖ Activo" : "‚ùå Inactivo"}
                  {u.verificationToken && (
                    <span className="text-yellow-500 ml-2">(no verificado)</span>
                  )}
                </td>
                <td className="p-3">
                  {u.createdAt ? new Date(u.createdAt).toLocaleDateString() : "‚Äì"}
                </td>
                <td className="p-3 flex justify-end gap-2">
                  {u.verificationToken && (
                    <Button
                      size="sm"
                      variant="outline"
                      title="Reenviar invitaci√≥n"
                      onClick={() => handleResendVerification(u.email)}
                    >
                      <MailCheck className="w-4 h-4" />
                    </Button>
                  )}
                  <Button
                    size="sm"
                    variant="outline"
                    title={u.active ? "Desactivar" : "Activar"}
                    onClick={() => handleToggleActive(u)}
                  >
                    {u.active ? <UserMinus className="w-4 h-4" /> : <UserPlus className="w-4 h-4" />}
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    title="Editar usuario"
                    onClick={() => router.push(`/admin/users/manage/${u.userId}`)}
                  >
                    <Pencil className="w-4 h-4" />
                  </Button>
                  <Button
                    size="sm"
                    variant="destructive"
                    title="Eliminar usuario"
                    onClick={() => handleDelete(u.userId)}
                  >
                    <Trash2 className="w-4 h-4" />
                  </Button>
                </td>
              </tr>
            ))}
          </BegasistTable>
        </>
      )}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/get/route.ts
---------------------------------
// /root/begasist/app/admin/users/get/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId, userId } = await req.json();

  if (!hotelId || !userId) {
    return NextResponse.json({ error: "Faltan hotelId o userId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config) {
    return NextResponse.json({ error: "Hotel no encontrado" }, { status: 404 });
  }

  const user = config.users?.find((u) => u.userId === userId);
  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  return NextResponse.json({ user });
}

---------------------------------


üîπ Archivo: ./app/admin/users/list/page.tsx
---------------------------------
// /app/admin/users/list/page.tsx
"use client";

import { useEffect, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { useCurrentUser } from "@/lib/context/UserContext";

export default function UsersListPage() {
  const { user } = useCurrentUser();
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchUsers() {
      if (!user?.hotelId) {
        setError("Hotel no identificado");
        setLoading(false);
        return;
      }

      try {
        const res = await fetch(`/api/users?hotelId=${user.hotelId}`);
        const data = await res.json();

        if (!res.ok) throw new Error(data.error || "Error al cargar usuarios");
        console.log("üë§ Usuario actual:", user);
        console.log("üì° Fetch a: ", `/api/users?hotelId=${user?.hotelId}`);
        console.log("üì¶ Respuesta cruda:", data);

        setUsers(data.users);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchUsers();
  }, [user?.hotelId]);

  return (
    <div className="max-w-5xl mx-auto mt-10">
      <h1 className="text-2xl font-bold mb-6">Usuarios del Hotel</h1>
      {loading && <p className="text-sm text-muted-foreground">Cargando usuarios...</p>}
      {error && <p className="text-sm text-red-600">{error}</p>}

      {!loading && !error && (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Email</TableHead>
              <TableHead>Rol</TableHead>
              <TableHead>Estado</TableHead>
              <TableHead>Verificado</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {users.map((u, idx) => (
              <TableRow key={idx}>
                <TableCell>{u.email}</TableCell>
                <TableCell>
                  <Badge variant="outline">Nivel {u.roleLevel}</Badge>
                </TableCell>
                <TableCell>
                  <Badge className={u.active ? "bg-green-600" : "bg-zinc-500"}>
                    {u.active ? "Activo" : "Inactivo"}
                  </Badge>
                </TableCell>
                <TableCell>
                  {u.verificationToken ? (
                    <Badge className="bg-orange-500">Pendiente</Badge>
                  ) : (
                    <Badge className="bg-green-600">Verificado</Badge>
                  )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/page.tsx
---------------------------------
// /app/admin/users/page.tsx
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger
} from "@/components/ui/dropdown-menu";
import { MoreHorizontal } from "lucide-react";
import { useCurrentUser } from "@/lib/context/UserContext";

export default function AdminUsersPage() {
  const { user } = useCurrentUser();
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!user?.hotelId) return;
    fetch(`/api/users?hotelId=${user.hotelId}`)
      .then(res => res.json())
      .then(data => setUsers(data.users || []));
  }, [user?.hotelId]);

  async function resendVerification(email: string) {
    if (!user?.hotelId) return;
    await fetch("/api/send-verification-email", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hotelId: user.hotelId, email })
    });
    alert("üìß Verificaci√≥n reenviada");
  }

  async function toggleActive(email: string, active: boolean) {
    if (!user?.hotelId) return;
    setLoading(true);
    await fetch("/api/users/update-status", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hotelId: user.hotelId, email, active: !active })
    });
    const updated = users.map(u =>
      u.email === email ? { ...u, active: !active } : u
    );
    setUsers(updated);
    setLoading(false);
  }

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Usuarios</h1>
      <table className="w-full border">
        <thead>
          <tr className="bg-zinc-800 text-white">
            <th className="p-2 text-left">Email</th>
            <th className="p-2">Activo</th>
            <th className="p-2">Acciones</th>
          </tr>
        </thead>
        <tbody>
          {users.map((u) => (
            <tr key={u.email} className="border-t">
              <td className="p-2">{u.email}</td>
              <td className="p-2 text-center">{u.active ? "‚úÖ" : "‚ùå"}</td>
              <td className="p-2 text-center">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm" className="w-8 h-8 p-0">
                      <MoreHorizontal className="w-4 h-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent>
                    <DropdownMenuItem onClick={() => resendVerification(u.email)}>
                      ‚úâÔ∏è Reenviar verificaci√≥n
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => toggleActive(u.email, u.active)}>
                      {u.active ? "üõë Desactivar" : "‚úÖ Activar"}
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/users/update/route.ts
---------------------------------
// /app/api/users/update/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import type { HotelUser } from "@/types/user";

export async function POST(req: NextRequest) {
  const { hotelId, user }: { hotelId: string; user: HotelUser } = await req.json();

  if (!hotelId || !user || !user.userId) {
    return NextResponse.json({ error: "Faltan datos obligatorios" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config) {
    return NextResponse.json({ error: "Hotel no encontrado" }, { status: 404 });
  }

  const updatedUsers = (config.users || []).map((u) =>
    u.userId === user.userId ? { ...u, ...user } : u
  );

  await updateHotelConfig(hotelId, { users: updatedUsers });

  return NextResponse.json({ success: true });
}

---------------------------------


üîπ Archivo: ./app/admin/roles/page.tsx
---------------------------------
// /app/admin/roles/page.tsx

import React from "react";
import { RoleLabels, RoleLevels, type RoleLevel } from "@/constants/roles";

const supportedLanguages = ["spa", "eng", "por", "fra", "ita", "rus"];
const roleLevels: RoleLevel[] = [RoleLevels.TECHNICAL, RoleLevels.MANAGER, RoleLevels.STANDARD];

export default function RolesPage() {
  return (
    <div className="p-6">
      <h1 className="text-xl font-semibold mb-4">Etiquetas por Rol y Lenguaje</h1>
      <table className="w-full border text-sm">
        <thead>
          <tr>
            <th className="border p-2">Nivel</th>
            {supportedLanguages.map((lang) => (
              <th key={lang} className="border p-2 text-center uppercase">{lang}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {roleLevels.map((role) => (
            <tr key={role}>
              <td className="border p-2 font-medium text-center">{role}</td>
              {supportedLanguages.map((lang) => (
                <td key={lang} className="border p-2 text-center">
                  {RoleLabels[role][lang] ?? "-"}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/upload/page.tsx
---------------------------------
// /app/admin/upload/page.tsx
"use client";

import { useEffect, useState } from "react";
import HotelDocumentUploader from "@/components/admin/HotelDocumentUploader";
import { DarkCard } from "@/components/ui/DarkCard";
import { useCurrentUser } from "@/lib/context/UserContext";
import { Button } from "@/components/ui/button";

type DocResumen = {
  hotelId: string;
  originalName: string;
  version: string;
  uploader: string;
  author: string | null;
  uploadedAt: string;
  categories: string[];
  promptKeys: string[];
  detectedLang: string;
  targetLang: string;
  chunkCount: number;
};

export default function UploadPage() {
  const { user, loading } = useCurrentUser();
  const [docs, setDocs] = useState<DocResumen[]>([]);
  const [refresh, setRefresh] = useState(0);
  const [loadingTable, setLoadingTable] = useState(false);

  // üîÑ Fetch docs cuando el usuario cambia o refrescamos
  useEffect(() => {
    if (!user?.hotelId) return;
    setLoadingTable(true);
    fetch(`/api/hotel-documents?hotelId=${encodeURIComponent(user.hotelId)}`)
      .then((res) => res.json())
      .then((data) => {
        setDocs(data.docs || []);
      })
      .finally(() => setLoadingTable(false));
  }, [user?.hotelId, refresh]);

  if (loading) return <div>Cargando usuario...</div>;
  if (!user) return <div>No autenticado</div>;

  return (
    <div className="max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-6">Carga de documentos</h2>

      {/* Uploader arriba */}
      <DarkCard className="mb-10">
        <HotelDocumentUploader
          hotelId={user.hotelId}
          uploader={user.email}
          onSuccess={() => setRefresh((r) => r + 1)} // recarga tabla al subir
        />
      </DarkCard>

      {/* Tabla resumen */}
      <DarkCard>
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-semibold">Documentos subidos</h3>
          <Button onClick={() => setRefresh((r) => r + 1)} disabled={loadingTable}>
            {loadingTable ? "Actualizando..." : "Actualizar"}
          </Button>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full border-collapse text-sm">
            <thead>
              <tr className="bg-muted text-foreground">
                <th className="px-3 py-2 text-left">Nombre</th>
                <th className="px-3 py-2">Versi√≥n</th>
                <th className="px-3 py-2">Categor√≠as</th>
                <th className="px-3 py-2">Chunks</th>
                <th className="px-3 py-2">Uploader</th>
                <th className="px-3 py-2">Fecha</th>
              </tr>
            </thead>
            <tbody>
              {docs.length === 0 && (
                <tr>
                  <td colSpan={6} className="py-6 text-center text-muted-foreground">
                    No hay documentos cargados.
                  </td>
                </tr>
              )}
              {docs.map((doc, i) => (
                <tr key={i} className="border-b border-muted">
                  <td className="px-3 py-2">{doc.originalName}</td>
                  <td className="px-3 py-2">{doc.version}</td>
                  <td className="px-3 py-2">{doc.categories.join(", ")}</td>
                  <td className="px-3 py-2 text-center">{doc.chunkCount}</td>
                  <td className="px-3 py-2">{doc.uploader}</td>
                  <td className="px-3 py-2">{new Date(doc.uploadedAt).toLocaleString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </DarkCard>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/layout.tsx
---------------------------------
// /app/admin/layout.tsx
"use client";

import { SidebarLogout } from "@/components/ui/SidebarLogout";
import { ReactNode, useEffect, useState } from "react";
import { fetchWithAuth } from "@/lib/client/fetchWithAuth";
import { ThemeToggle } from "@/components/ui/ThemeToggle";
import { SidebarLink } from "@/components/ui/SidebarLink";
import { Users, KeyRound } from "lucide-react";
import { UserProvider } from "@/lib/context/UserContext";
import { Toaster } from "@/components/ui/toaster";
import { SidebarGroup } from "@/components/ui/SidebarGroup";
import { ADMIN_MENU_ITEMS } from "@/lib/constants/adminMenu";
import {
  canAccessHotelsSection,
  canAccessUploadSection,
  canAccessEmbeddingsSection,
  canAccessPromptsSection,
  canAccessChannelsSection,
  canAccessLogsSection,
  canAccessUsersSection,
  canAccessChangePasswordSection,
} from "@/lib/auth/roles";

export default function AdminLayout({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<{
    email: string;
    hotelId: string;
    hotelName: string;
    roleLevel: number;
    userId?: string;
  } | null>(null);

  useEffect(() => {
    async function loadUser() {
      try {
        const res = await fetchWithAuth("/api/me");
        if (!res.ok) throw new Error("Unauthorized");
        const data = await res.json();
        setUser(data);
      } catch {
        setUser(null);
      }
    }
    loadUser();
  }, []);

  if (!user) {
    return <p className="p-4 text-gray-500">Verificando sesi√≥n...</p>;
  }

  return (
    <UserProvider>
      <div className="flex min-h-screen bg-background text-foreground transition-colors duration-300">
        <aside className="w-64 bg-gray-900 p-4 flex flex-col justify-between text-foreground">
          <div>
            <div className="flex items-center justify-between mb-4">
              <h1 className="text-2xl font-bold">Begasist Admin</h1>
              <ThemeToggle />
            </div>
            <div className="text-xs text-muted-foreground mb-2 leading-snug">
              {user.email}
              <br />
              {user.hotelName} <span className="text-[10px] text-gray-400">(ID: {user.hotelId})</span>
            </div>
            <nav className="space-y-2">
              {canAccessHotelsSection(user.roleLevel) && (
                <SidebarLink href="/admin/hotels" label="Hoteles" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessUploadSection(user.roleLevel) && (
                <SidebarLink href="/admin/upload" label="Carga de Datos" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessEmbeddingsSection(user.roleLevel) && (
                <SidebarLink href="/admin/embeddings" label="Embeddings" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessPromptsSection(user.roleLevel) && (
                <SidebarLink href="/admin/prompts" label="Prompts Curados" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessChannelsSection(user.roleLevel) && (
                <SidebarLink href="/admin/channels" label="Canales" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessLogsSection(user.roleLevel) && (
                <SidebarLink href="/admin/logs" label="Logs y Debug" icon={<Users className="w-5 h-5" />} />
              )}

              {canAccessUsersSection(user.roleLevel) && (
                <SidebarGroup icon={<Users className="w-5 h-5" />} label="Usuarios">
                  <SidebarLink href="/admin/users/manage" label="Administraci√≥n" />
                  <SidebarLink href="/auth/change-password" icon={<KeyRound className="w-4 h-4" />} label="Cambiar contrase√±a" />
                </SidebarGroup>
              )}

              {canAccessChangePasswordSection(user.roleLevel) && (
                <SidebarLink href="/auth/change-password" icon={<KeyRound className="w-5 h-5" />} label="Cambiar contrase√±a" />
              )}
            </nav>
            <SidebarLogout />
          </div>
        </aside>

        <main className="flex-1 p-6 overflow-y-auto">{children}</main>
      </div>
      <Toaster />
    </UserProvider>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/test-toast/page.tsx
---------------------------------
// /app/admin/test-toast/page.tsx
"use client";

import { toast } from "sonner";
import { Button } from "@/components/ui/button";

export default function TestToastPage() {
  return (
    <div className="max-w-md mx-auto mt-10 text-center space-y-4">
      <h1 className="text-xl font-semibold">üöÄ Prueba de Toast</h1>
      <Button
        onClick={() => toast.success("¬°Este es un toast exitoso! üéâ")}
      >
        Mostrar Toast
      </Button>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/page.tsx
---------------------------------
// /app/admin/page.tsx
"use client";

import { Button } from "@/components/ui/button";
import Link from "next/link";
import { DarkCard } from "@/components/ui/DarkCard";
import {
  Hotel,
  Upload,
  Brain,
  BookOpen,
  Server,
  FileText,
  Settings,
} from "lucide-react";
import UserStatus from "@/components/UsertStatus";
import { useCurrentUser } from "@/lib/context/UserContext";
import {
  canSeeHotelsDashboard,
  canSeeUploadDashboard,
  canSeeEmbeddingsDashboard,
  canSeePromptsDashboard,
  canSeeChannelsDashboard,
  canSeeLogsDashboard,
} from "@/lib/auth/roles";

export default function AdminDashboard() {
  const { user, loading } = useCurrentUser();

  if (loading) return <div>Cargando usuario...</div>;
  if (!user) return <div>No autenticado</div>;

  return (
    <div className="min-h-screen bg-background text-foreground py-12 px-6">
      <h1 className="text-3xl font-bold text-center mb-10 flex items-center justify-center gap-3">
        <Settings className="w-6 h-6" />
        Panel de Control
      </h1>

      <div className="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        {/* Cada card ahora depende de helpers de roles */}
        {canSeeHotelsDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <Hotel className="w-5 h-5" />
                Hoteles
              </div>
            }
            description="Gestion√° tus hoteles registrados en el sistema."
          >
            <Link href="/admin/hotels">
              <Button>Ver hoteles</Button>
            </Link>
          </DarkCard>
        )}

        {canSeeUploadDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <Upload className="w-5 h-5" />
                Carga de Datos
              </div>
            }
            description="Sub√≠ documentos o URLs para enriquecer la base de conocimiento."
          >
            <Link href="/admin/upload">
              <Button>Cargar datos</Button>
            </Link>
          </DarkCard>
        )}

        {canSeeEmbeddingsDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <Brain className="w-5 h-5" />
                Embeddings
              </div>
            }
            description="Consult√° y gestion√° la base vectorial por hotel y categor√≠a."
          >
            <Link href="/admin/embeddings">
              <Button>Ver embeddings</Button>
            </Link>
          </DarkCard>
        )}

        {canSeePromptsDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <BookOpen className="w-5 h-5" />
                Prompts Curados
              </div>
            }
            description="Edit√° prompts por categor√≠a y subcategor√≠a."
          >
            <Link href="/admin/prompts">
              <Button>Editar prompts</Button>
            </Link>
          </DarkCard>
        )}

        {canSeeChannelsDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <Server className="w-5 h-5" />
                Canales
              </div>
            }
            description="Estado de los canales conectados: web, email, WhatsApp, channel manager."
          >
            <Link href="/admin/channels">
              <Button>Ver estado</Button>
            </Link>
          </DarkCard>
        )}

        {canSeeLogsDashboard(user.roleLevel) && (
          <DarkCard
            title={
              <div className="flex items-center gap-2">
                <FileText className="w-5 h-5" />
                Logs y Debug
              </div>
            }
            description="Revis√° errores, ejecuciones recientes y trazas de flujo."
          >
            <Link href="/admin/logs">
              <Button>Ver logs</Button>
            </Link>
          </DarkCard>
        )}
      </div>

      <UserStatus />
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/hotels/page.tsx
---------------------------------
// /app/admin/page.tsx
"use client";

import { Button } from "@/components/ui/button";
import Link from "next/link";
import { DarkCard } from "@/components/ui/DarkCard";
import {
  Hotel,
  Upload,
  Brain,
  BookOpen,
  Server,
  FileText,
  Settings,
} from "lucide-react";
import UserStatus from "@/components/UsertStatus";
import { useCurrentUser } from "@/lib/context/UserContext"; // üëà

export default function AdminDashboard() {
  const { user, loading } = useCurrentUser();
  console.log("üë§ user desde contexto:", user, "loading:", loading);
  if (loading) {
    return <div className="p-6 text-center text-gray-500">Cargando usuario...</div>;
  }
  if (!user) {
    return <div className="p-6 text-center text-red-600">No se pudo cargar el usuario.</div>;
  }

  // Cards configurados por roles
  const allCards = [
    {
      key: "hotels",
      roleMin: 0,
      roleMax: 19,
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><Hotel className="w-5 h-5" />Hoteles</div>}
          description="Gestion√° tus hoteles registrados en el sistema."
        >
          <Link href="/admin/hotels"><Button>Ver hoteles</Button></Link>
        </DarkCard>
      ),
    },
    {
      key: "upload",
      roleMin: 0,
      roleMax: 19,
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><Upload className="w-5 h-5" />Carga de Datos</div>}
          description="Sub√≠ documentos o URLs para enriquecer la base de conocimiento."
        >
          <Link href="/admin/upload"><Button>Cargar datos</Button></Link>
        </DarkCard>
      ),
    },
    {
      key: "embeddings",
      roleMin: 0,
      roleMax: 19,
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><Brain className="w-5 h-5" />Embeddings</div>}
          description="Consult√° y gestion√° la base vectorial por hotel y categor√≠a."
        >
          <Link href="/admin/embeddings"><Button>Ver embeddings</Button></Link>
        </DarkCard>
      ),
    },
    {
      key: "prompts",
      roleMin: 0,
      roleMax: 19,
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><BookOpen className="w-5 h-5" />Prompts Curados</div>}
          description="Edit√° prompts por categor√≠a y subcategor√≠a."
        >
          <Link href="/admin/prompts"><Button>Editar prompts</Button></Link>
        </DarkCard>
      ),
    },
    {
      key: "channels",
      roleMin: 0,
      roleMax: 99, // todos los roles ven canales
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><Server className="w-5 h-5" />Canales</div>}
          description="Estado de los canales conectados: web, email, WhatsApp, channel manager."
        >
          <Link href="/admin/channels"><Button>Ver estado</Button></Link>
        </DarkCard>
      ),
    },
    {
      key: "logs",
      roleMin: 0,
      roleMax: 19,
      node: (
        <DarkCard
          title={<div className="flex items-center gap-2"><FileText className="w-5 h-5" />Logs y Debug</div>}
          description="Revis√° errores, ejecuciones recientes y trazas de flujo."
        >
          <Link href="/admin/logs"><Button>Ver logs</Button></Link>
        </DarkCard>
      ),
    },
  ];

  // Solo muestra los cards seg√∫n el roleLevel
  const visibleCards = allCards.filter(
    (card) =>
      user.roleLevel >= card.roleMin && user.roleLevel <= card.roleMax
  );

  return (
    <div className="min-h-screen bg-background text-foreground py-12 px-6">
      <h1 className="text-3xl font-bold text-center mb-10 flex items-center justify-center gap-3">
        <Settings className="w-6 h-6" />
        Panel de Control
      </h1>

      <div className="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        {visibleCards.map(card => (
          <div key={card.key}>{card.node}</div>
        ))}
      </div>
      <UserStatus />
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/logs/page.tsx
---------------------------------
// /app/admin/logs/page.tsx
export default function LogsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Logs</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/lib/translation.ts
---------------------------------
process.env.OPENAI_LOG = "off";
import { ChatOpenAI } from "@langchain/openai";

const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 });

export async function translationModel(text: string, targetLanguage: string) {
  return await model.invoke([{ role: "system", content: `Translate this to ${targetLanguage}: ${text}` }]);
}

---------------------------------


üîπ Archivo: ./app/test-dnd/page.tsx
---------------------------------
// /app/test-dnd/page.tsx
"use client";
import { useDropzone } from "react-dropzone";
export default function TestDnD() {
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: files => { console.log("onDrop", files); },
    accept: { "application/pdf": [], "text/plain": [] }
  });
  return (
    <div {...getRootProps()} style={{
      border: "2px dashed blue", padding: 40, margin: 60, textAlign: "center"
    }}>
      <input {...getInputProps()} />
      <div>{isDragActive ? "Drop here!" : "Drag PDF/TXT here"}</div>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/globals.css
---------------------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

/* üé® Variables de tema */
:root {
  --background: #ffffff;
  --foreground: #171717;
  --border: #e5e7eb;
  --muted-foreground: #6b7280;
}

html.dark {
  --background: #0a0a0a;
  --foreground: #ededed;
  --border: #444;
  --muted-foreground: #a1a1aa;
}

/* üí° Fallback si el usuario prefiere dark */
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

/* üåç Estilo global del body */
body {
  background-color: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
  transition: background-color 0.3s, color 0.3s;
}

/* üîó Estilos de links */
a {
  color: #2563eb;
  text-decoration: underline;
}

a:hover {
  color: #1e40af;
}



@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

---------------------------------


üîπ Archivo: ./app/layout.tsx
---------------------------------
// /app/layout.tsx
import { Metadata } from "next";
import { ThemeProvider } from "@/context/ThemeContext";
import { ApplyThemeClass } from "@/components/utils/ApplyThemeClass";
import { Toaster } from "sonner"; // üëà import√° el componente
import "./globals.css";

export const metadata: Metadata = {
  title: "Begasist",
  description: "Asistente conversacional hotelero",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="bg-background text-foreground transition-colors duration-300">
        <ThemeProvider>
          <ApplyThemeClass />
          {children}
        </ThemeProvider>

        {/* ‚úÖ Toasts globales */}
        <Toaster position="top-right" richColors />
      </body>
    </html>
  );
}

---------------------------------


üîπ Archivo: ./app/page.tsx
---------------------------------
// /root/begasist/app/page.tsx
"use client";

import { useEffect, useState } from "react";
import ReactMarkdown from "react-markdown";
import { useSearchParams } from "next/navigation";

export default function ChatPage() {
  const searchParams = useSearchParams();
  // üëá Le√© el hotelId del query param, o default
  const hotelId = searchParams?.get("hotelId") ?? "";
  const [query, setQuery] = useState("");
  const [response, setResponse] = useState("");
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState<"sent" | "pending" | null>(null);
  const [messageId, setMessageId] = useState<string | null>(null);

  const sendQuery = async () => {
    console.log("Verificando estado de !query.trim()...", !query.trim()); // <-- nuevo
    if (!query.trim()) return;
    console.log("Enviando consulta:", query); // <-- nuevo
    setLoading(true);
    setResponse("");
    setStatus(null);
    setMessageId(null);

    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: query,
          channel: "web",
          hotelId: hotelId,
        }),
      });
      let data: any = null;
      const text = await res.text();
      try {
        data = JSON.parse(text);
      } catch {
        // No era JSON, probablemente HTML
        setResponse("‚ö†Ô∏è Error del servidor o la ruta no existe. Consulta el backend.");
        setLoading(false);
        return;
      }
      const responseText =
        typeof data.response === "string"
          ? data.response
          : JSON.stringify(data.response, null, 2);

      setResponse(responseText);
      setStatus(data.status ?? null);
      setMessageId(data.messageId ?? null); // ‚úÖ Usar messageId correctamente
    } catch (error) {
      console.error("Error en la consulta:", error);
      setResponse("Error al obtener respuesta.");
    } finally {
      setLoading(false);
    }
  };

  // üîÅ Polling si est√° en modo supervisado
  useEffect(() => {
    if (status === "pending" && messageId) {
      const interval = setInterval(async () => {
        const res = await fetch(`/api/messages?channelId=web`);
        const data = await res.json();
        const updated = data.messages?.find((m: any) => m.messageId === messageId); // ‚úÖ Buscar por messageId

        if (updated?.status === "sent") {
          setResponse(updated.approvedResponse ?? updated.suggestion ?? "");
          setStatus("sent");
          clearInterval(interval);
        }
      }, 5000);

      return () => clearInterval(interval);
    }
  }, [status, messageId]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-background text-foreground p-6 transition-colors">
      <h1 className="text-3xl font-bold mb-4">üí¨ Chat con IA</h1>

      <div className="w-full max-w-lg bg-muted p-4 shadow-md rounded-lg border border-border">
        <textarea
          className="w-full border border-border bg-background text-foreground p-2 rounded-md focus:ring-2 focus:ring-blue-500 outline-none transition"
          rows={3}
          placeholder="Escrib√≠ tu pregunta..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />

        <button
          className="w-full bg-blue-600 text-white p-2 mt-3 rounded-md hover:bg-blue-700 transition"
          onClick={sendQuery}
          disabled={loading}
        >
          {loading ? "Pensando..." : "Preguntar"}
        </button>
      </div>

      {response && (
        <div className="w-full max-w-lg bg-muted p-4 mt-4 shadow-md rounded-lg border border-border text-foreground">
          <h2 className="text-lg font-semibold">ü§ñ Respuesta:</h2>
          <div className="mt-2 text-muted-foreground">
            <ReactMarkdown
              components={{
                a: ({ ...props }) => (
                  <a
                    className="text-blue-500 underline hover:text-blue-700"
                    {...props}
                  />
                ),
              }}
            >
              {status === "sent"
                ? response
                : "üïì Tu consulta fue enviada. Un recepcionista est√° revisando tu solicitud..."}
            </ReactMarkdown>
          </div>
        </div>
      )}

      <p className="mt-2 text-sm text-yellow-600">{status}</p>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/api/refresh/route.ts
---------------------------------
import { NextRequest, NextResponse } from "next/server";
import { signJWT, verifyRefreshToken } from "@/lib/auth/jwt";

export async function GET(req: NextRequest) {
  const refreshToken = req.cookies.get("refreshToken")?.value;

  if (!refreshToken) {
    return NextResponse.json({ error: "Falta refresh token" }, { status: 401 });
  }

  const payload = await verifyRefreshToken(refreshToken);

  if (!payload) {
    return NextResponse.json({ error: "Refresh token inv√°lido o expirado" }, { status: 401 });
  }

  const newAccessToken = await signJWT({
    email: payload.email,
    hotelId: payload.hotelId,
    roleLevel: payload.roleLevel,
    userId: payload.userId,
  });

  const response = NextResponse.json({ success: true });

  response.cookies.set("token", newAccessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: 60 * 60, // 1 hora
  });

  return response;
}

---------------------------------


üîπ Archivo: ./app/api/login/route.ts
---------------------------------
// /app/api/login/route.ts
import { NextResponse } from "next/server";
import { collection } from "@/lib/config/hotelConfig.server";
import { signJWT, signRefreshToken } from "@/lib/auth/jwt";
import type { HotelUser } from "@/types/user";

export async function POST(req: Request) {
  const { userId, hotelId } = await req.json();
  console.log("userId", userId);
  console.log("hotelId", hotelId);
  if (!userId || !hotelId) {
    return NextResponse.json({ error: "Faltan campos" }, { status: 400 });
  }

  const config = await collection.findOne({ hotelId });
  if (!config) {
    return NextResponse.json({ error: "Hotel no encontrado" }, { status: 404 });
  }

  const user = config.users.find((u: HotelUser) => u.userId === userId && u.active);
  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado en este hotel o inactivo" }, { status: 403 });
  }

  const accessToken = await signJWT({
    email: user.email,
    hotelId,
    roleLevel: user.roleLevel,
    userId: user.userId,
  });

  const refreshToken = await signRefreshToken({
    email: user.email,
    hotelId,
    roleLevel: user.roleLevel,
    userId: user.userId,
  });

  const response = NextResponse.json({ success: true });

  response.cookies.set("token", accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: 60 * 60,
  });

  response.cookies.set("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: 60 * 60 * 24 * 7,
  });

  return response;
}

---------------------------------


üîπ Archivo: ./app/api/users/change-password/route.ts
---------------------------------
// /app/api/users/change-password/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { hash, compare } from "bcryptjs";

export async function POST(req: NextRequest) {
  const { hotelId, email, currentPassword, newPassword } = await req.json();

  if (!hotelId || !email || !currentPassword || !newPassword) {
    return NextResponse.json({ error: "Faltan datos obligatorios" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  const user = config.users.find((u) => u.email === email);

  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  // Validar existencia de hash
  if (!user.passwordHash) {
    return NextResponse.json({ error: "Usuario sin contrase√±a definida" }, { status: 400 });
  }

  const validPassword = await compare(currentPassword, user.passwordHash);
  if (!validPassword) {
    return NextResponse.json({ error: "Contrase√±a actual incorrecta" }, { status: 403 });
  }

  const newHash = await hash(newPassword, 10);
  user.passwordHash = newHash;

  delete user.resetToken;
  delete user.resetTokenExpires;

  await updateHotelConfig(hotelId, { users: config.users });

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/users/send-verification-email/route.ts
---------------------------------
// /app/api/send-verification-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { randomUUID } from "crypto";
import { sendEmail } from "@/lib/email/sendEmail";
import { buildVerificationUrl } from "@/lib/utils/buildVerificationUrl";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { hotelId, email } = body;

  if (!hotelId || !email) {
    return NextResponse.json({ error: "Faltan campos obligatorios" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Configuraci√≥n del hotel no encontrada" }, { status: 404 });
  }

  const smtp = config.emailSettings;
  if (!smtp?.smtpHost || !smtp?.smtpPort || !smtp?.emailAddress || !smtp?.password) {
    return NextResponse.json({ error: "Configuraci√≥n SMTP incompleta" }, { status: 500 });
  }

  const user = config.users.find((u) => u.email === email);
  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  const token = randomUUID();
  user.verificationToken = token;
  user.active = false;

  await updateHotelConfig(hotelId, { users: config.users });

  
  const verifyUrl = await buildVerificationUrl("verify-account", token, hotelId);


  await sendEmail(
    {
      host: smtp.smtpHost,
      port: smtp.smtpPort,
      user: smtp.emailAddress,
      pass: smtp.password,
      secure: smtp.secure ?? false,
    },
    email,
    "Verificaci√≥n de cuenta",
    `
      <p>Hola,</p>
      <p>Para activar tu cuenta, hac√© clic en el siguiente enlace:</p>
      <p><a href="${verifyUrl}">${verifyUrl}</a></p>
      <p>Si no solicitaste esto, ignor√° este mensaje.</p>
    `
  );

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/users/create/route.ts
---------------------------------
// /app/api/users/create/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { randomUUID } from "crypto";

export async function POST(req: NextRequest) {
  const { hotelId, email, name, position, roleLevel } = await req.json();

  if (!hotelId || !email) {
    return NextResponse.json({ error: "Faltan datos obligatorios (hotelId, email)" }, { status: 400 });
  }

  // ‚õîÔ∏è Validaci√≥n: s√≥lo 'system' puede tener usuarios roleLevel 0
  if (roleLevel === 0 && hotelId !== "system") {
    return NextResponse.json(
      { error: "No se puede asignar roleLevel 0 fuera del hotel system" },
      { status: 400 }
    );
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  const exists = config.users.find((u) => u.email === email);
  if (exists) {
    return NextResponse.json({ error: "Ya existe un usuario con ese email" }, { status: 400 });
  }

  const verificationToken = randomUUID();

  const newUser = {
    userId: randomUUID(),
    email,
    name: name?.trim() || "",
    position: position?.trim() || "",
    roleLevel: roleLevel ?? 20,
    active: false, // üëà Por defecto inactivo hasta que verifique
    verificationToken, // üëà Token de verificaci√≥n
    createdAt: new Date().toISOString(),
  };

  config.users.push(newUser);
  await updateHotelConfig(hotelId, { users: config.users });

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/users/delete/route.ts
---------------------------------
// /app/api/users/delete/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { isRoleLevelZeroAllowed } from "@/lib/auth/roles";

export async function POST(req: NextRequest) {
  const { hotelId, userId } = await req.json();

  if (!hotelId || !userId) {
    return NextResponse.json({ error: "Faltan hotelId o userId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  const existing = config.users.find((u) => u.userId === userId);
  if (!existing) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  // ‚õîÔ∏è Bloqueo: no permitir eliminar usuario roleLevel 0 fuera de "system"
  if (!isRoleLevelZeroAllowed(hotelId, existing.roleLevel)) {
    return NextResponse.json(
      { error: "No se puede eliminar un usuario con roleLevel 0 fuera del hotel system" },
      { status: 403 }
    );
  }

  // Seguridad extra: prevenir eliminar usuario √∫nico admin
  const admins = config.users.filter((u) => u.roleLevel < 10);
  if (admins.length === 1 && existing.roleLevel < 10) {
    return NextResponse.json({ error: "No se puede eliminar el √∫nico administrador t√©cnico" }, { status: 403 });
  }

  // Filtrar usuario
  config.users = config.users.filter((u) => u.userId !== userId);
  await updateHotelConfig(hotelId, { users: config.users });

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/users/validate-reset-token/route.ts
---------------------------------
// /app/api/users/validate-reset-token/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getAllHotelConfigs } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { token } = await req.json();

  if (!token) {
    return NextResponse.json({ error: "Token faltante" }, { status: 400 });
  }

  const configs = await getAllHotelConfigs();

  for (const config of configs) {
    const user = config.users?.find((u) => u.resetToken === token);
    if (!user) continue;

    if (!user.resetTokenExpires) {
      return NextResponse.json({ error: "Token inv√°lido o corrupto" }, { status: 400 });
    }

    const isExpired = new Date(user.resetTokenExpires) < new Date();
    if (isExpired) {
      return NextResponse.json({ error: "Token expirado" }, { status: 400 });
    }

    // Token v√°lido y vigente
    return NextResponse.json({ ok: true });
  }

  return NextResponse.json({ error: "Token inv√°lido" }, { status: 404 });
}

---------------------------------


üîπ Archivo: ./app/api/users/get/route.ts
---------------------------------
// /app/api/users/get/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId, userId } = await req.json();

  if (!hotelId || !userId) {
    return NextResponse.json({ error: "Faltan hotelId o userId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  console.log(`üîç Buscando usuario ${userId} en hotel ${hotelId}`);

  const user = config.users.find((u) => u.userId === userId);

  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  // ‚úÖ Solo campos seguros
  const safeUser = {
    userId: user.userId,
    email: user.email,
    name: user.name,
    position: user.position,
    roleLevel: user.roleLevel,
    active: user.active,
    createdAt: user.createdAt,
    verificationToken: !!user.verificationToken,
  };

  return NextResponse.json({ user: safeUser });
}

---------------------------------


üîπ Archivo: ./app/api/users/hotels-for-user/route.ts
---------------------------------
// /app/api/users/hotels-for-user/route.ts

import { NextResponse } from "next/server";
import { compare } from "bcryptjs";
import { getAllHotelConfigs } from "@/lib/config/hotelConfig.server";

/**
 * Valida login por email y password.
 * Devuelve los hoteles v√°lidos donde el usuario est√° activo y el password coincide.
 */
export async function POST(req: Request) {
  const { email, password } = await req.json();

  if (!email || !password) {
    return NextResponse.json(
      { status: "error", message: "Faltan campos" },
      { status: 400 }
    );
  }

  // Trae todos los hoteles (y usuarios)
  const hotels = await getAllHotelConfigs();

  // Busca en TODOS los hoteles, a todos los usuarios activos con login local
  let matchingUsers: {
    userId: string;
    passwordHash: string;
    hotelId: string;
    name?: string;
  }[] = [];

  for (const hotel of hotels) {
    const user = hotel.users?.find(
      (u) =>
        u.email === email &&
        u.active &&
        u.passwordHash // solo login local
    );
    if (user) {
      const passOK = await compare(password, user.passwordHash!);
      console.log(`Comparando pass para userId=${user.userId} hotelId=${hotel.hotelId} => ${passOK}`);
      if (passOK) {
        matchingUsers.push({
          userId: user.userId,
          passwordHash: user.passwordHash as string,
          hotelId: hotel.hotelId,
          name: hotel.hotelName ?? hotel.hotelId,
        });
      }
    }
  }

  if (!matchingUsers.length) {
    return NextResponse.json(
      {
        status: "error",
        message:
          "Usuario no v√°lido para login local. Verific√° si est√° inactivo, sin contrase√±a o registrado con login federado.",
      },
      { status: 401 }
    );
  }

  // Prepara la lista para el selector
  const hotelList = matchingUsers.map((u) => ({
    hotelId: u.hotelId,
    name: u.name,
    userId: u.userId,
  }));

  return NextResponse.json({
    status: "ok",
    hotels: hotelList,
    autoLogin: hotelList.length === 1,
  });
}

---------------------------------


üîπ Archivo: ./app/api/users/send-recovery-email/route.ts
---------------------------------
// /app/api/users/send-recovery-email/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { generateToken } from "@/lib/auth/tokenUtils";
import { sendRecoveryEmail } from "@/lib/email/sendRecoveryEmail";

export async function POST(req: NextRequest) {
  const { hotelId, email } = await req.json();

  if (!hotelId || !email) {
    return NextResponse.json({ error: "Faltan hotelId o email" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config?.users || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  const user = config.users.find((u) => u.email === email);

  if (!user) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  // Generar nuevo token seguro
  const recoveryToken = generateToken();
  user.resetToken = recoveryToken;
  user.resetTokenExpires = new Date(Date.now() + 1000 * 60 * 60 * 2).toISOString(); // 2 horas

  await updateHotelConfig(hotelId, { users: config.users });

  // Enviar email reutilizando helper
  await sendRecoveryEmail({
    email: user.email,
    token: recoveryToken,
    hotelId,
  });

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/users/verify-account/route.ts
---------------------------------
// /app/api/users/verify-account/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getAllHotelConfigs, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { signJWT, signRefreshToken } from "@/lib/auth/jwt";

export async function POST(req: NextRequest) {
  const { token } = await req.json();

  if (!token) {
    return NextResponse.json({ error: "Token faltante" }, { status: 400 });
  }

  const allConfigs = await getAllHotelConfigs();
  const match = allConfigs.find((cfg) =>
    cfg.users?.some((u) => u.verificationToken === token)
  );

  if (!match) {
    return NextResponse.json({ error: "Token inv√°lido" }, { status: 404 });
  }

  const user = match.users!.find((u) => u.verificationToken === token);

  if (!user) {
    return NextResponse.json({ error: "Token inv√°lido o expirado" }, { status: 404 });
  }

  // ‚úÖ Marcar como activo y remover token
  user.active = true;
  delete user.verificationToken;

  await updateHotelConfig(match.hotelId, { users: match.users });

  // ‚úÖ Emitir JWT y Refresh token para login autom√°tico tras verificaci√≥n
  const jwtPayload = {
    email: user.email,
    hotelId: match.hotelId,
    roleLevel: user.roleLevel,
    userId: user.userId || user.email, // preferentemente userId, sino fallback email
  };

  const accessToken = await signJWT(jwtPayload);
  const refreshToken = await signRefreshToken(jwtPayload);

  const response = NextResponse.json({ accessToken });

  response.cookies.set("refreshToken", refreshToken, {
    httpOnly: true,
    secure: true,
    path: "/",
    sameSite: "strict",
    maxAge: 60 * 60 * 24 * 7, // 7 d√≠as
  });

  return response;
}

---------------------------------


üîπ Archivo: ./app/api/users/reset-password/route.ts
---------------------------------
// /app/api/users/reset-password/route.ts
import { NextRequest, NextResponse } from "next/server";
import { updateHotelConfig, getAllHotelConfigs } from "@/lib/config/hotelConfig.server";
import { hash } from "bcryptjs";

export async function POST(req: NextRequest) {
  const { token, newPassword } = await req.json();

  if (!token || !newPassword?.trim()) {
    return NextResponse.json({ error: "Faltan token o nueva contrase√±a v√°lida" }, { status: 400 });
  }

  const configs = await getAllHotelConfigs();

  for (const config of configs) {
    const user = config.users?.find((u) => u.resetToken === token);
    if (!user) continue;

    if (!user.resetTokenExpires) {
      return NextResponse.json({ error: "Token inv√°lido o corrupto" }, { status: 400 });
    }

    if (new Date(user.resetTokenExpires) < new Date()) {
      return NextResponse.json({ error: "Token expirado" }, { status: 400 });
    }

    // Actualizaci√≥n segura
    user.passwordHash = await hash(newPassword, 10);
    user.active = true;
    delete user.resetToken;
    delete user.resetTokenExpires;

    await updateHotelConfig(config.hotelId, { users: config.users });

    return NextResponse.json({ ok: true });
  }

  return NextResponse.json({ error: "Token inv√°lido" }, { status: 404 });
}

---------------------------------


üîπ Archivo: ./app/api/users/list/route.ts
---------------------------------
// /app/api/users/list/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId } = await req.json();

  if (!hotelId) {
    return NextResponse.json({ error: "Falta hotelId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  return NextResponse.json({ users: config.users });
}

---------------------------------


üîπ Archivo: ./app/api/users/update/route.ts
---------------------------------
// /app/api/users/update/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import type { HotelUser } from "@/types/user";
import { isRoleLevelZeroAllowed } from "@/lib/auth/roles";

export async function POST(req: NextRequest) {
  const { hotelId, user }: { hotelId: string; user: HotelUser } = await req.json();

  if (!hotelId || !user || !user.userId) {
    return NextResponse.json({ error: "Faltan datos obligatorios (hotelId o userId)" }, { status: 400 });
  }

  // ‚õîÔ∏è Bloqueo: no permitir roleLevel 0 fuera de "system"
  if (!isRoleLevelZeroAllowed(hotelId, user.roleLevel)) {
    return NextResponse.json(
      { error: "No se puede asignar roleLevel 0 fuera del hotel system" },
      { status: 400 }
    );
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Hotel no encontrado o sin usuarios" }, { status: 404 });
  }

  const existingUserIndex = config.users.findIndex((u) => u.userId === user.userId);
  if (existingUserIndex === -1) {
    return NextResponse.json({ error: "Usuario no encontrado" }, { status: 404 });
  }

  const existingUser = config.users[existingUserIndex];

  // Seguridad: Prevenir desactivar o degradar el √∫nico admin t√©cnico (roleLevel < 10)
  const admins = config.users.filter((u) => u.roleLevel < 10 && u.active);
  const isLastAdmin = admins.length === 1 && existingUser.roleLevel < 10;

  if (isLastAdmin) {
    // Intentando desactivar o cambiar rol a no admin t√©cnico
    if (user.active === false || user.roleLevel >= 10) {
      return NextResponse.json({ error: "No se puede desactivar ni degradar al √∫nico administrador t√©cnico" }, { status: 403 });
    }
  }

  // ‚úÖ Actualizaci√≥n segura permitida
  config.users[existingUserIndex] = {
    ...existingUser,
    name: user.name?.trim() || "",
    position: user.position?.trim() || "",
    roleLevel: user.roleLevel,
    active: user.active !== undefined ? user.active : existingUser.active,
    // Preservar campos cr√≠ticos
    email: existingUser.email,
    passwordHash: existingUser.passwordHash,
    userId: existingUser.userId,
    createdAt: existingUser.createdAt,
  };

  await updateHotelConfig(hotelId, { users: config.users });

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/hotel-documents/route.ts
---------------------------------
// /app/api/hotel-documents/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getHotelAstraCollection } from "@/lib/astra/connection";
import type { ChunkResult } from "@/types/chunk";

// Utilidad para agrupar por documento original+versi√≥n
function groupChunksByOriginal(chunks: ChunkResult[]) {
  const groups: Record<string, any> = {};

  for (const chunk of chunks) {
    const key = `${chunk.originalName || "?"}__${chunk.version || "v1"}`;
    if (!groups[key]) {
      groups[key] = {
        hotelId: chunk.hotelId,
        originalName: chunk.originalName,
        version: chunk.version,
        uploader: chunk.uploader,
        author: chunk.author,
        uploadedAt: chunk.uploadedAt,
        categories: new Set(),
        promptKeys: new Set(),
        detectedLang: chunk.detectedLang,
        targetLang: chunk.targetLang,
        chunkCount: 0,
      };
    }
    if (chunk.category) groups[key].categories.add(chunk.category);
    if (chunk.promptKey) groups[key].promptKeys.add(chunk.promptKey);
    groups[key].chunkCount++;
  }

  // Formateo para salida legible
  return Object.values(groups).map((doc: any) => ({
    hotelId: doc.hotelId,
    originalName: doc.originalName,
    version: doc.version,
    uploader: doc.uploader,
    author: doc.author,
    uploadedAt: doc.uploadedAt,
    categories: Array.from(doc.categories).sort(),      // ‚Üê ordenado
    categoryCount: doc.categories.size,                 // ‚Üê cantidad
    promptKeys: Array.from(doc.promptKeys),
    detectedLang: doc.detectedLang,
    targetLang: doc.targetLang,
    chunkCount: doc.chunkCount,
  }));
}

// üö© Handler principal
export async function GET(req: NextRequest) {
  const hotelId = req.nextUrl.searchParams.get("hotelId");
  if (!hotelId) {
    return NextResponse.json({ error: "Missing hotelId" }, { status: 400 });
  }

  const collection = getHotelAstraCollection<ChunkResult>(hotelId);

  // Limitar cantidad si hay muchos docs
  const allDocs = await collection.find({ hotelId }).toArray();

  const allChunks: ChunkResult[] = allDocs.map((doc: any) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $vector, ...chunk } = doc;
    return chunk as ChunkResult;
  });

  const grouped = groupChunksByOriginal(allChunks);

  // BONUS: ordenar por originalName, version DESC
  grouped.sort((a: any, b: any) => {
    if (a.originalName === b.originalName) {
      // Ordenar por versi√≥n descendente (v3 > v2 > v1)
      const nA = parseInt((a.version || "v0").replace("v", ""), 10);
      const nB = parseInt((b.version || "v0").replace("v", ""), 10);
      return nB - nA;
    }
    return (a.originalName || "").localeCompare(b.originalName || "");
  });

  return NextResponse.json({ ok: true, docs: grouped });
}

---------------------------------


üîπ Archivo: ./app/api/logout/route.ts
---------------------------------
// /app/api/logout/route.ts
import { NextResponse } from "next/server";

export async function POST() {
  const res = NextResponse.json({ ok: true });
  res.cookies.set("token", "", { maxAge: 0, path: "/" });
  res.cookies.set("refreshToken", "", { maxAge: 0, path: "/" });
  return res;
}

---------------------------------


üîπ Archivo: ./app/api/config/add/route.ts
---------------------------------
// /app/api/config/add/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { ChannelMode } from "@/types/channel";
import { parseChannel } from "@/lib/utils/parseChannel";
export async function POST(req: Request) {
  const url = new URL(req.url);
  const rawChannel = url.searchParams.get("channel");
  const channel = parseChannel(rawChannel);

  if (!channel) {
    return NextResponse.json({ error: "Canal no permitido" }, { status: 400 });
  }

  const hotelId = "hotel123"; // Simulado
  const config = await getHotelConfig(hotelId);

  // ‚úÖ Si ya existe, no hacer nada
  if (config?.channelConfigs?.[channel]) {
    return NextResponse.json({ message: "Canal ya est√° configurado" }, { status: 200 });
  }

  // ‚úÖ Agrega el canal a la configuraci√≥n
  const updatedConfigs = {
    ...config?.channelConfigs,
    [channel]: {
      enabled: false,
      mode: "supervised" as ChannelMode,
    },
  };

  await updateHotelConfig(hotelId, { channelConfigs: updatedConfigs });

  // ‚úÖ Redirige de nuevo a la p√°gina de canales
  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/config/mode/route.ts
---------------------------------
// /app/api/config/mode/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { ChannelMode } from "@/types/channel";
import { parseChannel } from "@/lib/utils/parseChannel";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const rawChannel = url.searchParams.get("channel");
  const channel = parseChannel(rawChannel);

  if (!channel) {
    return NextResponse.json({ error: "Canal no permitido" }, { status: 400 });
  }

  const hotelId = "hotel123"; // simulado
  const config = await getHotelConfig(hotelId);
  const current = config?.channelConfigs?.[channel];

  if (!current) {
    return NextResponse.json({ error: "Canal no configurado" }, { status: 404 });
  }

  const newMode: ChannelMode = current.mode === "automatic" ? "supervised" : "automatic";

  await updateHotelConfig(hotelId, {
    channelConfigs: {
      ...config.channelConfigs,
      [channel]: {
        ...current,
        mode: newMode as ChannelMode,
      },
    },
  });

  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/config/toggle/route.ts
---------------------------------
// /app/api/config/toggle/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { parseChannel } from "@/lib/utils/parseChannel";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const rawChannel = url.searchParams.get("channel");
  const channel = parseChannel(rawChannel);
  
  if (!channel) {
    return NextResponse.json({ error: "Canal no permitido" }, { status: 400 });
  }

  const hotelId = "hotel123"; // ‚Üê Simulado
  const config = await getHotelConfig(hotelId);

  const current = config?.channelConfigs?.[channel];
  if (!current) {
    return NextResponse.json({ error: "Canal no configurado" }, { status: 404 });
  }

  const updatedConfigs = {
    ...config.channelConfigs,
    [channel]: {
      ...current,
      enabled: !current.enabled, // ‚Üê alternamos el valor
    },
  };

  await updateHotelConfig(hotelId, { channelConfigs: updatedConfigs });

  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/me/change-password/route.ts
---------------------------------
// /app/api/me/change-password/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";
import { compare, hash } from "bcryptjs";
import { verifyJWT } from "@/lib/auth/jwt";

export async function POST(req: NextRequest) {
  const token = req.cookies.get("token")?.value;

  if (!token) {
    return NextResponse.json({ error: "Token faltante" }, { status: 401 });
  }
  
  const payload = await verifyJWT(token);
  

  if (!payload) {
    return NextResponse.json({ error: "Token inv√°lido o expirado" }, { status: 401 });
  }

  const { email, hotelId } = payload;
  const body = await req.json();
  const { currentPassword, newPassword } = body;

  if (!currentPassword || !newPassword) {
    return NextResponse.json({ error: "Faltan campos requeridos" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config || !Array.isArray(config.users)) {
    return NextResponse.json({ error: "Configuraci√≥n del hotel inv√°lida" }, { status: 500 });
  }

  const user = config.users.find((u) => u.email === email);
  if (!user || !user.passwordHash) {
    return NextResponse.json({ error: "Usuario no encontrado o sin contrase√±a" }, { status: 404 });
  }

  const isValid = await compare(currentPassword, user.passwordHash);
  if (!isValid) {
    return NextResponse.json({ error: "Contrase√±a actual incorrecta" }, { status: 401 });
  }

  user.passwordHash = await hash(newPassword, 10);
  await updateHotelConfig(hotelId, { users: config.users });

  return NextResponse.json({ ok: true, message: "Contrase√±a actualizada correctamente" });
}

---------------------------------


üîπ Archivo: ./app/api/me/route.ts
---------------------------------
// /app/api/me/route.ts
import { NextResponse } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";

export async function GET() {
  const user = await getCurrentUser();

  if (!user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }


  return NextResponse.json({
    email: user.email,
    hotelId: user.hotelId,
    hotelName: user.hotelName, // üëà nuevo
    roleLevel: user.roleLevel,
    userId: user.userId,
  });
}

---------------------------------


üîπ Archivo: ./app/api/messages/by-conversation/route.ts
---------------------------------
// /app/api/messages/by-conversation/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";
import { getMessagesByConversation } from "@/lib/services/messages";
import { parseChannel } from "@/lib/utils/parseChannel";

export async function GET(req: NextRequest) {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }

  const url = new URL(req.url);
  const rawChannel = url.searchParams.get("channelId");
  const conversationId = url.searchParams.get("conversationId");

  const channel = parseChannel(rawChannel);

  if (!channel || !conversationId) {
    return NextResponse.json({ error: "Par√°metros inv√°lidos" }, { status: 400 });
  }

  const messages = await getMessagesByConversation(user.hotelId, channel, conversationId);
  return NextResponse.json({ messages });
}

---------------------------------


üîπ Archivo: ./app/api/messages/route.ts
---------------------------------
// /app/api/messages/route.ts

import { NextResponse } from "next/server";
import {
  getMessagesFromChannel,
  updateMessageInChannel,
} from "@/lib/services/messages";
import { channelHandlers } from "@/lib/services/channelHandlers";
import { parseChannel } from "@/lib/utils/parseChannel";
import { getCurrentUser } from "@/lib/auth/getCurrentUser";

export async function GET(req: Request) {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json({ error: "No autorizado" }, { status: 401 });
  }

  const url = new URL(req.url);
  const rawChannel = url.searchParams.get("channelId");
  const channel = parseChannel(rawChannel);

  if (!channel) {
    return NextResponse.json({ error: "Canal no permitido" }, { status: 400 });
  }

  const messages = await getMessagesFromChannel(user.hotelId, channel);
  return NextResponse.json({ messages });
}

export async function POST(req: Request) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: "No autorizado" }, { status: 401 });
    }

    const {
      messageId,
      approvedResponse,
      status,
      respondedBy,
      channel: rawChannel,
    } = await req.json();

    const channel = parseChannel(rawChannel);

    if (!messageId || !channel || !(channel in channelHandlers)) {
      return NextResponse.json(
        { error: "Datos inv√°lidos o canal no soportado" },
        { status: 400 }
      );
    }

    const updateResult = await updateMessageInChannel(
      user.hotelId,
      channel,
      messageId,
      {
        ...(approvedResponse && { approvedResponse }),
        ...(status && { status }),
        ...(respondedBy && { respondedBy }),
      }
    );

    if (!updateResult) {
      return NextResponse.json(
        { error: "Mensaje no encontrado o sin cambios" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("‚õî Error en POST /api/messages:", error);
    return NextResponse.json({ error: "Error interno" }, { status: 500 });
  }
}


---------------------------------


üîπ Archivo: ./app/api/whatsapp/route.ts
---------------------------------
// app/api/whatsapp/route.ts

import { NextResponse } from "next/server";

export async function GET() {
  return NextResponse.json({ status: "üü¢ WhatsApp bot is running." });
}

export async function POST() {
  return NextResponse.json({ status: "üü¢ WhatsApp bot is running independently and does not require webhooks." });
}

---------------------------------


üîπ Archivo: ./app/api/chat/route.ts
---------------------------------
// app/api/chat/route.ts
import { NextResponse } from "next/server";
import { agentGraph } from "@/lib/agents";
import { HumanMessage, AIMessage } from "@langchain/core/messages";
import { debugLog } from "@/lib/utils/debugLog";
import { channelMemory } from "@/lib/services/channelMemory";
import { v4 as uuidv4 } from "uuid";
import type { Channel, ChannelMode, MessageStatus, ChannelMessage } from "@/types/channel";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: Request) {
  try {
    const { query, channel, hotelId }: { query: string; channel: Channel; hotelId?: string } = await req.json();

    debugLog("üîç Consulta recibida:", query);

    const realHotelId = hotelId || "hotel123";
    const config = await getHotelConfig(realHotelId);
    const mode: ChannelMode = config?.channelConfigs[channel]?.mode || "automatic";

    const response = await agentGraph.invoke({
      messages: [new HumanMessage(query)],
      hotelId: realHotelId,
    });

    const aiMessage = response.messages.findLast(
      (msg) => msg instanceof AIMessage
    ) as AIMessage | undefined;

    const responseText = aiMessage?.content || "No se encontr√≥ una respuesta.";

    const timestamp = new Date().toISOString();

    const status: MessageStatus = mode === "automatic" ? "sent" : "pending";

    const newMessage: ChannelMessage = {
      messageId: uuidv4(),
      sender: "Usuario Web",
      time: new Date(timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
      timestamp,
      content: query,
      hotelId: realHotelId,
      channel,
      suggestion: String(responseText),
      status,
      approvedResponse: status === "sent" ? String(responseText) : undefined,
      respondedBy: status === "sent" ? "assistant" : undefined,
    };
    
    

    console.log("üß† Agregando mensaje en memoria:", newMessage);

    channelMemory.addMessage(newMessage);

    debugLog("üìå Respuesta enviada:", responseText);

    return NextResponse.json({
      response: responseText,
      status,
      messageId: newMessage.messageId,
    });

  } catch (error) {
    console.error("‚õî Error en la API /api/chat:", error);
    return NextResponse.json(
      { response: "Ocurri√≥ un error al procesar la solicitud." },
      { status: 500 }
    );
  }
}

---------------------------------


üîπ Archivo: ./app/api/debug/hotelPhoneMap/route.ts
---------------------------------
// /app/api/debug/hotelPhoneMap/route.ts

import { NextResponse } from "next/server";
import { debugHotelPhoneMap } from "@/lib/config/hotelPhoneMap";

/**
 * Endpoint temporal para inspeccionar el cach√© de tel√©fonos -> hotelId.
 */
export async function GET() {
  console.log("üõ†Ô∏è [DEBUG] Dump de hotelPhoneMap solicitado...");
  debugHotelPhoneMap();
  return NextResponse.json({ message: "Cache de tel√©fonos registrado en consola." });
}

---------------------------------


üîπ Archivo: ./app/api/test/list-users/route.ts
---------------------------------
// /app/api/test/list-users/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId } = await req.json();
  if (!hotelId) return NextResponse.json({ error: "hotelId faltante" }, { status: 400 });

  const config = await getHotelConfig(hotelId);
  if (!config?.users) return NextResponse.json({ error: "Hotel o usuarios no encontrados" }, { status: 404 });

  return NextResponse.json({ users: config.users });
}

---------------------------------


üîπ Archivo: ./app/api/hotels/create/route.ts
---------------------------------
// /app/api/hotels/create/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createHotelWithAdmin } from "@/lib/services/hotel"; // üëà Importa la funci√≥n auxiliar

export async function POST(req: NextRequest) {
  try {
    const {
      hotelId,
      hotelName,
      timezone,
      defaultLanguage,
      adminEmail,
      adminPassword,
      adminRoleLevel,
      emailSettings, // <-- extrae emailSettings del body
    } = await req.json();

    // Usa la funci√≥n centralizada para crear hotel y admin
    const result = await createHotelWithAdmin({
      hotelId,
      hotelName,
      timezone,
      defaultLanguage,
      adminEmail,
      adminPassword,
      adminRoleLevel,
      emailSettings, // <-- p√°salo a la funci√≥n
    });

    return NextResponse.json(result);
  } catch (error: any) {
    return NextResponse.json({ error: error.message || "Error inesperado" }, { status: 400 });
  }
}

---------------------------------


üîπ Archivo: ./app/api/hotels/delete/route.ts
---------------------------------
// /app/api/hotels/delete/route.ts
import { NextRequest, NextResponse } from "next/server";
import { collection } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId } = await req.json();
  if (!hotelId) {
    return NextResponse.json({ error: "Falta hotelId" }, { status: 400 });
  }
  if (hotelId === "system") {
    return NextResponse.json({ error: "No se puede eliminar el hotel system" }, { status: 400 });
  }
  await collection.deleteOne({ hotelId });
  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/hotels/rollback-version/route.ts
---------------------------------
// /app/api/hotels/rollback-version/route.ts

import { NextResponse } from "next/server";
import { rollbackVersionForHotel } from "@/lib/retrieval/rollbackVersionForHotel";

export async function POST(req: Request) {
  const body = await req.json();
  const { hotelId, sourceVersion, userEmail } = body;
  if (!hotelId || !sourceVersion) {
    return NextResponse.json({ error: "Falta hotelId o sourceVersion" }, { status: 400 });
  }
  try {
    const result = await rollbackVersionForHotel(hotelId, sourceVersion, undefined, userEmail);
    return NextResponse.json(result);
  } catch (err) {
    return NextResponse.json({ error: String(err) }, { status: 500 });
  }
}
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const hotelId = searchParams.get("hotelId");
  const sourceVersion = searchParams.get("sourceVersion");
  if (!hotelId || !sourceVersion) {
    return NextResponse.json({ error: "Falta hotelId o sourceVersion" }, { status: 400 });
  }
  try {
    const result = await rollbackVersionForHotel(hotelId, sourceVersion);
    return NextResponse.json(result);
  } catch (err) {
    return NextResponse.json({ error: String(err) }, { status: 500 });
  }
}
---------------------------------


üîπ Archivo: ./app/api/hotels/delete-version/route.ts
---------------------------------
// /app/api/hotels/delete-version/route.ts

import { NextResponse } from "next/server";
import { deleteVersionForHotel } from "@/lib/retrieval/deleteVersionForHotel";

export async function POST(req: Request) {
  const body = await req.json();
  const { hotelId, version } = body;
  if (!hotelId || !version) {
    return NextResponse.json({ error: "Falta hotelId o version" }, { status: 400 });
  }
  try {
    const result = await deleteVersionForHotel(hotelId, version);
    return NextResponse.json(result);
  } catch (err) {
    return NextResponse.json({ error: String(err) }, { status: 500 });
  }
}

---------------------------------


üîπ Archivo: ./app/api/hotels/get/route.ts
---------------------------------
// /app/api/hotels/get/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig } from "@/lib/config/hotelConfig.server";

export async function GET(req: NextRequest) {
  const url = new URL(req.url);
  const hotelId = url.searchParams.get("hotelId");

  if (!hotelId) {
    return NextResponse.json({ error: "Falta hotelId" }, { status: 400 });
  }

  const config = await getHotelConfig(hotelId);
  if (!config) {
    return NextResponse.json({ error: "Hotel no encontrado" }, { status: 404 });
  }

  return NextResponse.json({ hotel: config });
}

---------------------------------


üîπ Archivo: ./app/api/hotels/route.ts
---------------------------------
// /app/api/hotels/route.ts
import { NextRequest, NextResponse } from "next/server";
import bcrypt from "bcryptjs";
import { collection } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  try {
    const {
      hotelId,
      hotelName,
      timezone,
      defaultLanguage,
      adminEmail,
      adminPassword,
    } = await req.json();

    if (!hotelId || !adminEmail || !adminPassword) {
      return NextResponse.json(
        { error: "Faltan datos obligatorios" },
        { status: 400 }
      );
    }

    // Verificar si ya existe
    const existing = await collection.findOne({ hotelId });
    if (existing) {
      return NextResponse.json(
        { error: "Ya existe un hotel con ese ID" },
        { status: 409 }
      );
    }

    const passwordHash = await bcrypt.hash(adminPassword, 10);

    const newHotel = {
      hotelId,
      hotelName,
      timezone,
      defaultLanguage,
      channelConfigs: {
        web: { enabled: true, mode: "supervised" },
      },
      users: [
        {
          email: adminEmail,
          passwordHash,
          roleLevel: 0,
          active: true,
          createdAt: new Date().toISOString(),
        },
      ],
      lastUpdated: new Date().toISOString(),
    };

    await collection.insertOne(newHotel);

    return NextResponse.json({ success: true });
  } catch (err: any) {
    console.error("‚ùå Error creando hotel:", err);
    return NextResponse.json({ error: "Error interno del servidor" }, { status: 500 });
  }
}

---------------------------------


üîπ Archivo: ./app/api/hotels/list/route.ts
---------------------------------
// /app/api/hotels/list/route.ts
/**
 * Endpoint para obtener un listado de todos los hoteles registrados.
 * (Opcional: Filtra info sensible antes de devolver, si lo necesit√°s.)
 */
import { NextRequest, NextResponse } from "next/server";
import { getAllHotelConfigs } from "@/lib/config/hotelConfig.server";

export async function GET() {
  const configs = await getAllHotelConfigs();
  // Ac√° podr√≠as mapear o limpiar los campos si lo necesit√°s
  return NextResponse.json({ hotels: configs });
}

---------------------------------


üîπ Archivo: ./app/api/hotels/upload-docs/route.ts
---------------------------------
// /app/api/hotels/upload-docs/route.ts
import { NextRequest, NextResponse } from "next/server";
import formidable from "formidable";
import { loadDocumentFileForHotel } from "@/lib/retrieval";
import { promises as fs } from "fs";
import path from "path";

// Necesario para deshabilitar el bodyParser
export const config = {
  api: { bodyParser: false }
};

async function parseForm(req: Request): Promise<{ fields: any, files: any }> {
  const form = formidable({ multiples: false, uploadDir: "/tmp", keepExtensions: true });
  return new Promise((resolve, reject) => {
    form.parse(req as any, (err: any, fields: any, files: any) => {
      if (err) reject(err);
      else resolve({ fields, files });
    });
  });
}

export async function POST(req: NextRequest) {
  // Validaci√≥n de usuario/hotel (ejemplo simple, mejor√° para usar auth real)
  const hotelId = req.headers.get("x-hotel-id"); // o sacalo del token, etc.
  const uploader = req.headers.get("x-user-email") || "admin@unknown";

  if (!hotelId) {
    return NextResponse.json({ error: "hotelId requerido" }, { status: 401 });
  }

  try {
    const { fields, files } = await parseForm(req as any);
    const file = files.file; // nombre input="file"
    if (!file) return NextResponse.json({ error: "Archivo requerido" }, { status: 400 });

    const filePath = file.filepath || file.path;
    const originalName = file.originalFilename || file.name;
    const mimeType = file.mimetype || "application/pdf";

    const result = await loadDocumentFileForHotel({
      hotelId,
      filePath,
      originalName,
      uploader,
      mimeType,
      metadata: {} // Pod√©s agregar m√°s metadata ac√° si quer√©s
    });

    // Opcional: borrar el archivo temporal
    await fs.unlink(filePath);

    return NextResponse.json(result);
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

---------------------------------


üîπ Archivo: ./app/api/hotels/update/route.ts
---------------------------------
// /app/api/hotels/update/route.ts
/**
 * Endpoint para modificar datos de un hotel existente.
 * Solo permite cambiar campos no cr√≠ticos.
 * Restricci√≥n: no se puede cambiar hotelId ni el nombre del hotel system.
 */
import { NextRequest, NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: NextRequest) {
  const { hotelId, updates } = await req.json();

  // Validaci√≥n de campos b√°sicos
  if (!hotelId || !updates) {
    return NextResponse.json({ error: "Faltan datos obligatorios" }, { status: 400 });
  }

  // ‚ö†Ô∏è No permitir cambio de hotelId
  if (updates.hotelId && updates.hotelId !== hotelId) {
    return NextResponse.json({ error: "No se puede cambiar el hotelId" }, { status: 400 });
  }

  // ‚ö†Ô∏è No cambiar nombre del hotel system
  if (hotelId === "system" && updates.hotelName) {
    return NextResponse.json({ error: "No se puede cambiar el nombre del hotel system" }, { status: 400 });
  }

  // Realiza la actualizaci√≥n (merge parcial)
  await updateHotelConfig(hotelId, updates);

  return NextResponse.json({ ok: true });
}

---------------------------------


üîπ Archivo: ./app/api/hotels/list-versions/route.ts
---------------------------------
// /lib/retrieval/listVersionsForHotel.ts
import { DataAPIClient } from "@datastax/astra-db-ts";
import { getCollectionName } from "@/lib/retrieval/index.ts";
import dotenv from "dotenv";
dotenv.config();


export async function listVersionsForHotel(hotelId: string) {
  const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
  const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
  const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN!);
  const db = client.db(ASTRA_DB_URL!, { keyspace: ASTRA_DB_KEYSPACE! });
  const collectionName = getCollectionName(hotelId);
  const collection = await db.collection(collectionName);

  const docs = await collection.find({ hotelId },  { projection: { version: 1, uploadedAt: 1 } }).toArray();

  // Agrupa por version
  const versionMap: Record<string, string> = {};
  for (const d of docs) {
    // Guarda la fecha m√°s reciente por version
    if (!versionMap[d.version] || d.uploadedAt > versionMap[d.version]) {
      versionMap[d.version] = d.uploadedAt;
    }
  }

  // Arma el array de versiones ordenadas
  const versions = Object.entries(versionMap)
    .map(([version, uploadedAt]) => ({ version, uploadedAt }))
    .sort((a, b) => b.uploadedAt.localeCompare(a.uploadedAt)); // m√°s reciente primero

  return versions;
}

---------------------------------

