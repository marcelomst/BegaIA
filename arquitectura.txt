üìÇ Estructura del Proyecto
=========================
.
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ admin
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channels
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ embeddings
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotels
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prompts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ upload
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chat
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts:Zone.Identifier
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ add
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mode
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ toggle
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email 
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsapp
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ generatePDF.js
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ globals.css
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lib
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Hotel_Demo.pdf
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ translation.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ taildocs.txt
‚îú‚îÄ‚îÄ arquitectura.txt
‚îú‚îÄ‚îÄ aux.json
‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ admin
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ChannelMessages.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ChannelsClient.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ui
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DarkCard.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SidebarLink.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ThemeToggle.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ button.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ card.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ ApplyThemeClass.tsx
‚îú‚îÄ‚îÄ context
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ThemeContext.tsx
‚îú‚îÄ‚îÄ documentacion
‚îú‚îÄ‚îÄ ecosystem.config.js
‚îú‚îÄ‚îÄ eslint.config.mjs
‚îú‚îÄ‚îÄ estructura_del_proyecto.txt
‚îú‚îÄ‚îÄ generate_architecture.sh
‚îú‚îÄ‚îÄ google-chrome-stable_current_amd64.deb
‚îú‚îÄ‚îÄ index.modified.ts:Zone.Identifier
‚îú‚îÄ‚îÄ info.txt
‚îú‚îÄ‚îÄ lib
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ agents
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billing.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ defaultResponse.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ internal_support.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reservations.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ retrieval_based.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ services.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ astra
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ load_from_pdf.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ classifier
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ categoryAliases.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfig.server.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotelConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ initHotelConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ toggle
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ route.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ entrypoints
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ all.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsapp.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pms
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prompts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ promptMetadata.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ retrieval
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validateClassification.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ channelManager.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ email.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ whatsapp.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ whatsappClient.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ debugLog.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ language.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ similarity.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.ts
‚îú‚îÄ‚îÄ next
‚îú‚îÄ‚îÄ next-env.d.ts
‚îú‚îÄ‚îÄ next.config.ts
‚îú‚îÄ‚îÄ output_cleaned.txt
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ parsed-completo.json
‚îú‚îÄ‚îÄ pnpm-lock.yaml
‚îú‚îÄ‚îÄ postcss.config.mjs
‚îú‚îÄ‚îÄ prompt-clasificador.txt
‚îú‚îÄ‚îÄ public
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ file.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fonts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-latin-ext.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-latin.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ geist-mono-latin-ext.woff2
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ geist-mono-latin.woff2
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ globe.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ next.svg
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ vercel.svg
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ window.svg
‚îú‚îÄ‚îÄ scripts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ init-config.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setupHotel.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-astra.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-retrievalBased.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test-search-wifi.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ testClassifier.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_search.ts
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hotel_agent_uml.uml
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ test
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ agents.test.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chat.test.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 05-versions-space.pdf
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 05-versions-space.pdf.txt
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ presentacion.test.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ retrieval.test.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ui.test.tsx
‚îú‚îÄ‚îÄ test-imap-connection.ts
‚îú‚îÄ‚îÄ test-imap-simple.ts
‚îú‚îÄ‚îÄ testAstraConnection.ts
‚îú‚îÄ‚îÄ texto.json
‚îú‚îÄ‚îÄ touch @types
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ rehype-raw.d.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ tsconfig.tsbuildinfo
‚îú‚îÄ‚îÄ types
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chunk.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mailparser.d.ts
‚îú‚îÄ‚îÄ vector_cache
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ rooms_vectorstore.json
‚îú‚îÄ‚îÄ vitest.config.ts
‚îú‚îÄ‚îÄ vitest.setup.ts
‚îî‚îÄ‚îÄ zzaux.aux

46 directories, 121 files

=========================

üìú Scripts Claves
=================

üîπ Archivo: ./lib/services/channelManager.ts
---------------------------------
// lib/services/channelManager.ts
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";

const simulatedReservations = [
  "Quiero reservar una habitaci√≥n doble para el 10 de junio al 12 de junio.",
  "¬øTienen disponibilidad para una suite del 5 al 7 de mayo?",
  "Necesito una habitaci√≥n individual para esta noche.",
];

export async function startChannelManagerBot() {
  console.log("üõ∞Ô∏è [channelManager] Iniciado. Simulando reservas cada 15s...");

  setInterval(async () => {
    try {
      const randomMessage =
        simulatedReservations[Math.floor(Math.random() * simulatedReservations.length)];

      console.log("üì• [channelManager] Reserva simulada:", randomMessage);

      const response = await agentGraph.invoke({
        messages: [new HumanMessage(randomMessage)],
      });

      const reply = response.messages.at(-1)?.content;

      if (reply) {
        console.log("üì§ [channelManager] Respuesta del asistente:", reply);
      }
    } catch (err) {
      console.error("‚õî [channelManager] Error procesando reserva:", err);
    }
  }, 15000);
}

---------------------------------


üîπ Archivo: ./lib/services/email.ts
---------------------------------
import { simpleParser } from "mailparser";
import imaps from "imap-simple";
import nodemailer from "nodemailer";
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";
import dotenv from "dotenv";

dotenv.config();

export async function startEmailBot() {
  console.log("üì• [email] Iniciando bot de correo...");

  try {
    const {
      EMAIL_USER,
      EMAIL_PASS,
      IMAP_HOST,
      IMAP_PORT,
      SMTP_HOST,
      SMTP_PORT,
      EMAIL_SECURE,
    } = process.env;

    if (!EMAIL_USER || !EMAIL_PASS || !IMAP_HOST || !SMTP_HOST) {
      throw new Error("‚ùå Faltan variables de entorno cr√≠ticas (EMAIL_USER, EMAIL_PASS, IMAP_HOST, SMTP_HOST)");
    }

    const imapConfig = {
      imap: {
        user: EMAIL_USER,
        password: EMAIL_PASS,
        host: IMAP_HOST,
        port: Number(IMAP_PORT) || 993,
        tls: true,
        tlsOptions: { rejectUnauthorized: false }, // ‚¨ÖÔ∏è Clave para evitar errores SSL locales
        authTimeout: 10000,
      },
    };

    const transporter = nodemailer.createTransport({
      host: SMTP_HOST,
      port: Number(SMTP_PORT) || 587,
      secure: false, // usar STARTTLS (para puerto 587)
      auth: {
        user: EMAIL_USER,
        pass: EMAIL_PASS,
      },
    });

    const connection = await imaps.connect(imapConfig);
    await connection.openBox("INBOX");
    console.log("‚úÖ [email] Conectado a IMAP. Escuchando correos cada 15s...");

    setInterval(async () => {
      try {
        const messages = await connection.search(["UNSEEN"], {
          bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE)", "TEXT"],
          struct: true,
        });

        if (!messages.length) return;

        console.log(`üì¨ [email] Correos no le√≠dos: ${messages.length}`);

        for (const message of messages) {
          const parts = imaps.getParts(message.attributes.struct);
          const part = parts.find((p: any) => p.type === "text");
          if (!part) continue;
        
          const raw = await connection.getPartData(message, part);
          const parsed = await simpleParser(raw);
        
          const htmlRaw =
            typeof parsed.html === "string"
              ? parsed.html
              : Buffer.isBuffer(parsed.html)
              ? parsed.html.toString("utf-8")
              : "";
        
          const cleanText =
            parsed.text?.trim() ||
            htmlRaw.replace(/<[^>]+>/g, "").trim() ||
            parsed.headerLines?.map((h: { key: string; line: string }) => h.line).join("\n").trim();
        
          const headerPart = message.parts.find((p: any) => p.which?.toLowerCase().includes("header"));
          const rawFrom = Array.isArray(headerPart?.body?.from) ? headerPart.body.from[0] : undefined;
        
          const from =
            parsed.from?.text ||
            rawFrom ||
            parsed.headerLines?.find((h: { key: string; line: string }) => h.line.includes("@"))?.line;
        
          if (!cleanText || !from) {
            console.warn("‚ö†Ô∏è [email] Email ignorado: sin texto o remitente v√°lido.", {
              fromFallback: rawFrom,
              parsedFrom: parsed.from?.text,
              parsedText: parsed.text,
              parsedHTML: parsed.html,
              headerLines: parsed.headerLines,
            });
            continue;
          }
        
          console.log(`üìß [email] Procesando email de ${from}`);
        
          const response = await agentGraph.invoke({
            messages: [new HumanMessage(cleanText)],
          });
        
          const reply = response.messages.at(-1)?.content;
          if (typeof reply === "string") {
            await transporter.sendMail({
              from: EMAIL_USER,
              to: from,
              subject: "Re: " + (parsed.subject || "Consulta recibida"),
              text: reply,
            });
        
            console.log(`üì§ [email] Respuesta enviada a ${from}`);
          }
        }
        
      } catch (err) {
        console.error("‚õî [email] Error procesando correos:", err);
      }
    }, 15000);
  } catch (startupErr) {
    console.error("üí• [email] Error cr√≠tico al iniciar el bot:", startupErr);
    throw startupErr;
  }
}

---------------------------------


üîπ Archivo: ./lib/services/whatsapp.ts
---------------------------------
// lib/services/whatsapp.ts

import { Message } from "whatsapp-web.js";
import { whatsappClient as client } from "./whatsappClient";
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";
import qrcode from "qrcode-terminal";

export function startWhatsAppBot() {
  client.on("qr", (qr) => {
    console.log("‚ö° [whatsapp] Escane√° este c√≥digo QR para conectar:");
    qrcode.generate(qr, { small: true });
  });

  client.on("ready", () => {
    console.log("‚úÖ [whatsapp] Bot listo para recibir mensajes.");
  });

  client.on("message", async (message: Message) => {
    try {
      console.log(`üì© [whatsapp] Mensaje recibido: ${message.body}`);

      const response = await agentGraph.invoke({
        messages: [new HumanMessage(message.body)],
      });

      const reply = response.messages.at(-1)?.content;

      if (typeof reply === "string" && reply.trim()) {
        await message.reply(reply);
        console.log(`üì§ [whatsapp] Respuesta enviada.`);
      } else {
        console.warn("‚ö†Ô∏è [whatsapp] Respuesta vac√≠a o malformada.");
      }
    } catch (error) {
      console.error("‚õî [whatsapp] Error procesando mensaje:", error);
      await message.reply("‚ö†Ô∏è Hubo un error procesando tu solicitud.");
    }
  });

  client.initialize();
}

---------------------------------


üîπ Archivo: ./lib/services/whatsappClient.ts
---------------------------------
import { Client } from "whatsapp-web.js";
import puppeteer from "puppeteer";

export const whatsappClient = new Client({
  puppeteer: {
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    executablePath: puppeteer.executablePath(), // üëà Esto es lo clave
  },
});

---------------------------------


üîπ Archivo: ./lib/classifier/categoryAliases.ts
---------------------------------
// /lib/classifier/categoryAliases.ts
const CATEGORY_ALIASES: Record<string, string> = {
    cancellation: "reservation",
    // futuros alias
    checkin: "reservation",
    checkout: "reservation",
    modification: "reservation",
  };
  
  export function normalizeCategory(category: string): string {
    return CATEGORY_ALIASES[category] ?? category;
  }
  
---------------------------------


üîπ Archivo: ./lib/classifier/index.ts
---------------------------------
import { ChatOpenAI } from "@langchain/openai";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";
import { normalizeCategory } from "./categoryAliases";
export type Classification = {
  category: string;
  promptKey?: string | null;
};
process.env.OPENAI_LOG = "off";

const classifierModel = new ChatOpenAI({
  modelName: "gpt-3.5-turbo",
  temperature: 0,
});

export async function classifyQuery(question: string): Promise<Classification> {
  const allowedCategories = Object.keys(promptMetadata).join(", ");
  const allPromptKeys = Object.entries(promptMetadata)
    .flatMap(([_, keys]) => keys)
    .filter(Boolean);

  const prompt = `
Dada la siguiente consulta del usuario, responde solo con un JSON v√°lido con dos campos:

- "category": una de las siguientes: ${allowedCategories}
- "promptKey": si la categor√≠a necesita un prompt curado especial, elige una de: [${allPromptKeys.join(", ")}]; si no, pon null.

Ejemplo de respuesta:
{
  "category": "retrieval_based",
  "promptKey": "room_info"
}

Consulta:
"${question}"
`.trim();

  const res = await classifierModel.invoke([{ role: "user", content: prompt }]);

  try {
    const parsed = JSON.parse(res.content as string);
    let { category, promptKey } = parsed;
      // üîÑ Normalizar la categor√≠a
    category = normalizeCategory(category);
    if (!promptMetadata[category]) {
      throw new Error(`‚ùå Categor√≠a inv√°lida detectada: ${category}`);
    }

    const isValidPrompt = promptKey === null || promptMetadata[category].includes(promptKey);
    if (!isValidPrompt) {
      throw new Error(`‚ùå Prompt key inv√°lido: ${promptKey} para categor√≠a: ${category}`);
    }

    debugLog("üß† Clasificaci√≥n final:", { category, promptKey });
    return { category, promptKey };
  } catch (e) {
    console.error("‚ùå Error al parsear o validar respuesta del clasificador:", res.content);
    return { category: "retrieval_based", promptKey: null };
  }
}

---------------------------------


üîπ Archivo: ./lib/pms/index.ts
---------------------------------
export type ReservationStatus = "confirmed" | "cancelled";

export interface Reservation {
  guest: string;
  roomType: string;
  checkIn: string;
  checkOut: string;
  status: ReservationStatus;
}

export class PMS {
  private reservations: Record<string, Reservation> = {}; // üî• Reemplazamos `any` por `Reservation`

  createReservation(guest: string, roomType: string, checkIn: string, checkOut: string): Reservation & { id: string } {
    const id = `res-${Date.now()}`;
    this.reservations[id] = { guest, roomType, checkIn, checkOut, status: "confirmed" };
    return { id, ...this.reservations[id] };
  }

  getReservation(id: string): Reservation | null {
    return this.reservations[id] || null;
  }

  cancelReservation(id: string): Reservation | null {
    if (this.reservations[id]) {
      this.reservations[id].status = "cancelled";
      return this.reservations[id];
    }
    return null;
  }
}

export const pms = new PMS();

---------------------------------


üîπ Archivo: ./lib/prompts/promptMetadata.ts
---------------------------------
// lib/prompts/promptMetadata.ts

/**
 * Define qu√© promptKeys son v√°lidas para cada categor√≠a.
 * Esto evita que el clasificador invente claves y permite escalar de forma controlada.
 */
export const promptMetadata: Record<string, string[]> = {
    retrieval_based: ["room_info"],
    reservation: [],
    amenities: [],
    billing: [],
    support: [],
  };
  
  
---------------------------------


üîπ Archivo: ./lib/prompts/index.ts
---------------------------------
// lib/prompts/index.ts

// üß† Prompt gen√©rico
export const defaultPrompt = `
Responde la siguiente consulta usando exclusivamente la informaci√≥n proporcionada.

- S√© claro y profesional.
- Si no hay suficiente informaci√≥n, responde con cortes√≠a sin inventar.

Informaci√≥n disponible:

{{retrieved}}

Consulta del usuario: "{{query}}"
`.trim();

// üè® Prompts curados por clave
export const curatedPrompts: Record<string, string> = {
  room_info: `
Usa la siguiente informaci√≥n del hotel para responder de manera clara y bien estructurada.

**Formato requerido:**
- Usa **Markdown** con listas y tablas para alineaci√≥n.
- La tabla **sin l√≠neas de separaci√≥n entre filas**.
- Usa t√≠tulos en **negrita** con el emoji üè® antes del nombre de la habitaci√≥n.
- **A√±ade un doble salto de l√≠nea entre cada tipo de habitaci√≥n.**
- **Finaliza con una invitaci√≥n a reservar.**

Ejemplo de formato esperado:
\`\`\`md
**üè® Habitaci√≥n Doble**  

| üõèÔ∏è  1 cama doble      | üìè √Årea de 17 metros cuadrados |  
| üöø Ba√±o privado       | üìû Tel√©fono                    |  
| üì∫ TV LCD             | üíá‚Äç‚ôÄÔ∏è Secador de pelo             |  
| ‚ùÑÔ∏è Aire acondicionado | üì∂ WiFi gratis                 |  
| üîí Caja fuerte        | üö≠ No fumadores                |  
| üõÅ Toallas            | üî• Calefacci√≥n                 |  

<br><br>

**üè® Habitaci√≥n Triple**  

| üõèÔ∏è  1 cama doble y 1 simple   | üìè √Årea de 23 metros cuadrados |  
| üöø Ba√±o privado               | üìû Tel√©fono                    |  
| üì∫ TV LCD                     | üíá‚Äç‚ôÄÔ∏è Secador de pelo             |  
| ‚ùÑÔ∏è Aire acondicionado         | üì∂ WiFi gratis                 |  
| üîí Caja fuerte                | üö≠ No fumadores                |  
| üõÅ Toallas                    | üî• Calefacci√≥n                 |  

<br><br>

üìÖ **¬°Reserva ahora para obtener el mejor precio!** üí∞  
üîó [Haz clic aqu√≠ para reservar](https://booking.bedzzle.com/desktop/?&apikey=6177b98dc5c442893dd76be7da149008&lang=es)
\`\`\`

**Aqu√≠ est√° la informaci√≥n relevante del hotel:**  

{{retrieved}}

**Aseg√∫rate de seguir estrictamente este formato.**
`, 
};

---------------------------------


üîπ Archivo: ./lib/retrieval/validateClassification.ts
---------------------------------
type Classification = {
    category: string;
    promptKey: string | null;
  };
  
  const validCategories = [
    "reservation",
    "billing",
    "support",
    "amenities",
    "retrieval_based",
  ];
  
  export function validateClassification(item: any): Classification {
    const fallback: Classification = {
      category: "retrieval_based",
      promptKey: null,
    };
  
    if (!item || typeof item !== "object") return fallback;
  
    const { category, promptKey } = item;
  
    const isValidCategory = validCategories.includes(category);
    const isValidPromptKey =
      promptKey === null || typeof promptKey === "string";
  
    return {
      category: isValidCategory ? category : fallback.category,
      promptKey: isValidPromptKey ? promptKey : fallback.promptKey,
    };
  }
  
---------------------------------


üîπ Archivo: ./lib/retrieval/index.ts
---------------------------------
// /root/begasist/lib/retrieval/index.ts

import { cache } from "react";

import puppeteer from "puppeteer-extra";
import { Document } from "@langchain/core/documents";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import { OpenAIEmbeddings } from "@langchain/openai";
import { translationModel } from "../../app/lib/translation";
import { debugLog } from "../utils/debugLog";
import { DataAPIClient } from "@datastax/astra-db-ts";
import { ChatOpenAI } from "@langchain/openai";
import { validateClassification } from "./validateClassification"; 
import fs from "fs";
import { cosineSimilarity } from "../utils/similarity";
import type { ChunkResult, InsertableChunk } from "../../types/chunk.ts"; // o el path relativo seg√∫n tu setup

 
import dotenv from "dotenv";
dotenv.config();

const urls = ["https://www.hoteldemo.com/en/index.php"];
const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;

export const getCollectionName = (hotelId: string) => `${hotelId}_collection`;

const curationAssistant = new ChatOpenAI({
  modelName: "gpt-4",
  temperature: 0,
});

const classificationPrompt = `
Eres un experto en hospitalidad. Vas a clasificar fragmentos de texto provenientes de documentos de hoteles en una de las siguientes categor√≠as:

- reservation
- billing
- support
- amenities
- retrieval_based

Adem√°s, si corresponde, asignar√°s una clave de prompt especializada (promptKey) como por ejemplo: room_info, cancellation_policy, breakfast_details, etc. Si no hay un promptKey aplicable, devu√©lvelo como null.

Devuelve **exclusivamente** un JSON v√°lido con esta estructura (una lista con un objeto por fragmento):

[
  {
    "category": "reservation",
    "promptKey": "cancellation_policy"
  },
  ...
]

Ahora analiza los siguientes fragmentos:

{fragments}
`;


async function classifyFragmentsWithCurationAssistant(documents: Document[]): Promise<Document[]> {
  const inputChunks = documents.map((doc) => doc.pageContent);
  const promptText = classificationPrompt.replace(
    "{fragments}",
    inputChunks.map((t, i) => `Fragmento ${i + 1}: """${t}"""`).join("\n\n")
  );
  fs.writeFileSync("prompt-clasificador.txt", promptText, "utf8");
  console.log("üß† Prompt guardado en prompt-clasificador.txt");
  
  const response = await curationAssistant.invoke([{ role: "user", content: promptText }]);
  
  function extractTextContent(content: any): string {
    if (typeof content === "string") return content;
    if (Array.isArray(content)) {
      return content.map((c) => c?.text || "").join("\n");
    }
    return JSON.stringify(content);
  }
  
  let parsed: any[] = [];
  try {
    parsed = JSON.parse(extractTextContent(response.content) || "[]");
    

  } catch (e) {
    debugLog("‚õî Error al parsear JSON del clasificador:", e);
  }
  fs.writeFileSync("parsed-completo.json", JSON.stringify(parsed, null, 2));

  return documents.map((doc, i) => {
    const classification = validateClassification(parsed[i] || {});
    return new Document({
      pageContent: doc.pageContent,
      metadata: {
        ...doc.metadata,
        category: classification.category,
        promptKey: classification.promptKey,
      },
    });
  });
}

async function fetchPageWithPuppeteer(url: string): Promise<string | null> {
  debugLog("üåê Cargando p√°gina con Puppeteer:", url);
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  const page = await browser.newPage();
  try {
    await page.goto(url, { waitUntil: "networkidle2", timeout: 120000 });
    await page.waitForSelector("body", { timeout: 120000 });
    return await page.evaluate(() => document.body.innerText);
  } catch (error) {
    debugLog("‚ùå Error en Puppeteer:", error);
    return null;
  } finally {
    await browser.close();
  }
}

export async function translateText(text: string) {
  try {
    const lang = process.env.SYSTEM_NATIVE_LANGUAGE;
    if (!lang) throw new Error("SYSTEM_NATIVE_LANGUAGE is not defined in .env");
    const translated = await translationModel(text, lang);
    return typeof translated.content === "string"
      ? translated.content
      : JSON.stringify(translated.content);
  } catch (error) {
    debugLog("‚õî Error en traducci√≥n:", error);
    return text;
  }
}

export async function loadDocuments(hotelId: string) {
  debugLog(`üì¶ Cargando documentos para hotel ${hotelId}`);

  const docs = await Promise.all(
    urls.map(async (url) => {
      const html = await fetchPageWithPuppeteer(url);
      if (!html) return null;
      const translated = await translateText(html);
      return new Document<{ source: string; hotelId: string }>({
        pageContent: translated,
        metadata: { source: url, hotelId },
      });
    })
  );

  const validDocs = docs.filter((d): d is Document<{ source: string; hotelId: string }> => d !== null);

  // üß© Primero fragmentamos
  const splitter = new RecursiveCharacterTextSplitter({ chunkSize: 1500, chunkOverlap: 200 });
  const chunks = await splitter.splitDocuments(validDocs);

  // üß† Luego clasificamos
  const enrichedChunks = await classifyFragmentsWithCurationAssistant(chunks);
  
  const embedder = new OpenAIEmbeddings();
  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
  const collectionName = getCollectionName(hotelId);

  const collection = await db.collection<InsertableChunk >(collectionName);


  for (const doc of enrichedChunks) {
    const embedding = await embedder.embedQuery(doc.pageContent);
    const { hotelId, category, promptKey } = doc.metadata;
  
    if (!hotelId || !category) {
      throw new Error("Faltan hotelId o category en el metadata del chunk.");
    }
  
    await collection.insertOne({
      hotelId,
      category,
      promptKey: promptKey ?? null, // opcional, aseguramos que sea null o string
      text: doc.pageContent,
      $vector: embedding,
    });
  }
  

  debugLog(`‚úÖ Insertados ${enrichedChunks.length} chunks en colecci√≥n ${collectionName}`);
}

type SearchFilters = {
  category?: string;
  promptKey?: string;
};

export async function searchFromAstra(
  query: string,
  hotelId: string = "hotel123",
  filters: SearchFilters = {}
) {
  if (!hotelId || hotelId === "hotel123") {
    console.warn("‚ö†Ô∏è [searchFromAstra] hotelId no proporcionado, usando fallback: 'hotel123'");
  }
  const embedder = new OpenAIEmbeddings();
  const queryVector = await embedder.embedQuery(query);

  const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
  const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
  const collectionName = getCollectionName(hotelId);
  const collection = await db.collection<ChunkResult>(collectionName);

  debugLog("Collection name:", collection);
  // üß† Primer intento: por promptKey (si est√°)
  if (filters.promptKey) {
    const promptKeyFilter = {
      hotelId,
      promptKey: filters.promptKey,
    };
    debugLog("üîç Filtro por promptKey:", promptKeyFilter);

    const cursor = await collection.find(promptKeyFilter, {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    });
    const results = await cursor.toArray();
    if (results.length > 0) {
      return results.map((r: any) => r.text);
    }
  }

  // üåÄ No hubo resultados ‚Üí intentar por category si existe
  if (filters.category) {
    const categoryFilter = {
      hotelId,
      category: filters.category,
    };
    debugLog("üîÅ Fallback por category:", categoryFilter);
  
    const fallbackCursor = await collection.find(categoryFilter, {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    });
  
    type ChunkResult = {
      _id: string;
      text: string;
      $similarity: number;
      $vector: number[];
      [key: string]: any;
    };
  
    const fallbackResults = (await fallbackCursor.toArray()) as ChunkResult[];
  
    debugLog("üîÅ FallbackResults por category:", fallbackResults);
    for (const r of fallbackResults) {
      if (!Array.isArray(r.$vector)) {
        console.warn("‚ö†Ô∏è Chunk con vector inv√°lido:", r);
      }
    }
    
    const SIMILARITY_THRESHOLD = 0.95;
  
    const relevantResults = fallbackResults
      .filter((r) => Array.isArray(r.$vector)&& r.$vector.length === queryVector.length) // defensivo
      .map((r) => ({
        ...r,
        semanticRelevance: cosineSimilarity(queryVector, r.$vector),
      }))
      .filter((r) => r.semanticRelevance > SIMILARITY_THRESHOLD)
      .sort((a, b) => b.semanticRelevance - a.semanticRelevance);
  
    if (relevantResults.length > 0) {
      debugLog("‚úÖ Resultados relevantes por similitud sem√°ntica:", relevantResults);
      return relevantResults.map((r) => r.text);
    }
  
    console.warn("‚ö†Ô∏è Ning√∫n resultado con buena similitud. Reintentando sin filtros...");
  }
  
  // üîö Sin promptKey ni category ‚Üí buscar solo por hotelId
  debugLog("üîç B√∫squeda sin filtro adicional (solo hotelId):", { hotelId });

  const fallbackCursor = await collection.find(
    { hotelId },
    {
      sort: { $vector: queryVector },
      limit: 5,
      includeSimilarity: true,
    }
  );
  const fallbackResults = await fallbackCursor.toArray();
  return fallbackResults.map((r: any) => r.text);
    
  }

---------------------------------


üîπ Archivo: ./lib/config/hotelConfig.ts
---------------------------------
// /lib/config/hotelConfig.ts
import { DataAPIClient } from "@datastax/astra-db-ts";
import dotenv from "dotenv";
dotenv.config();


const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;
console.log("DEBUG ASTRA_DB_URL", ASTRA_DB_URL); // üëà esto deber√≠a mostrar una URL real

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
export const collection = db.collection("hotel_config");

// Tipo base de configuraci√≥n por canal
type ChannelMode = "auto" | "supervised";

export type HotelChannelConfig = {
  mode: ChannelMode;
  enabled: boolean;
  [key: string]: any;
};

export type HotelConfig = {
  hotelId: string;
  channelConfigs: {
    [channel: string]: HotelChannelConfig;
  };
  lastUpdated?: string;
};

export async function getHotelConfig(hotelId: string): Promise<HotelConfig | null> {
  const result = await collection.findOne({ hotelId });
  return result as HotelConfig | null;
}

export async function updateHotelConfig(hotelId: string, updates: Partial<HotelConfig>) {
  const now = new Date().toISOString();
  await collection.updateOne(
    { hotelId },
    { $set: { ...updates, lastUpdated: now } },
    { upsert: true }
  );
}

---------------------------------


üîπ Archivo: ./lib/config/initHotelConfig.ts
---------------------------------
// /lib/config/initHotelConfig.ts
import { HotelConfig, collection } from "./hotelConfig";

export async function initHotelConfig(hotelId: string) {
  const existing = await collection.findOne({ hotelId });

  if (existing) {
    console.log(`‚ÑπÔ∏è Configuraci√≥n ya existente para ${hotelId}`);
    return;
  }

  const mockConfig: HotelConfig = {
    hotelId,
    channelConfigs: {
      email: {
        enabled: true,
        mode: "supervised",
        imap: {
          host: "imap.gmail.com",
          port: 993,
          user: "hotel@example.com",
          password: "app-password",
        },
        smtp: {
          host: "smtp.gmail.com",
          port: 587,
          secure: false,
        },
      },
      whatsapp: {
        enabled: true,
        mode: "supervised",
        botNumber: "+34 123 456 789",
      },
      channelManager: {
        enabled: true,
        mode: "supervised",
        pollingInterval: 15000,
      },
    },
    lastUpdated: new Date().toISOString(),
  };

  await collection.insertOne(mockConfig);
  console.log(`‚úÖ Configuraci√≥n inicial creada para ${hotelId}`);
}

---------------------------------


üîπ Archivo: ./lib/config/hotelConfig.server.ts
---------------------------------
// /lib/config/hotelConfig.server.ts
import { DataAPIClient } from "@datastax/astra-db-ts";

const ASTRA_DB_URL = process.env.ASTRA_DB_URL!;
const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_KEYSPACE = process.env.ASTRA_DB_KEYSPACE!;

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
const db = client.db(ASTRA_DB_URL, { keyspace: ASTRA_DB_KEYSPACE });
export const collection = db.collection("hotel_config");

export type ChannelMode = "auto" | "supervised";

export type HotelChannelConfig = {
  mode: ChannelMode;
  enabled: boolean;
  [key: string]: any;
};

export type HotelConfig = {
  hotelId: string;
  channelConfigs: {
    [channel: string]: HotelChannelConfig;
  };
  lastUpdated?: string;
};

export async function getHotelConfig(hotelId: string): Promise<HotelConfig | null> {
  const result = await collection.findOne({ hotelId });
  return result as HotelConfig | null;
}

export async function updateHotelConfig(hotelId: string, updates: Partial<HotelConfig>) {
  const now = new Date().toISOString();
  await collection.updateOne(
    { hotelId },
    { $set: { ...updates, lastUpdated: now } },
    { upsert: true }
  );
}

---------------------------------


üîπ Archivo: ./lib/config/toggle/route.ts
---------------------------------
// /app/api/config/toggle/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const channel = url.searchParams.get("channel");

  if (!channel) {
    return NextResponse.json({ error: "Channel is required" }, { status: 400 });
  }

  const hotelId = "hotel123"; // Simulado
  const config = await getHotelConfig(hotelId);
  const current = config?.channelConfigs?.[channel];

  if (!current) {
    return NextResponse.json({ error: "Canal no configurado" }, { status: 404 });
  }

  const updated = {
    ...config.channelConfigs,
    [channel]: {
      ...current,
      enabled: !current.enabled,
    },
  };

  await updateHotelConfig(hotelId, { channelConfigs: updated });

  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./lib/entrypoints/all.ts
---------------------------------
process.on("uncaughtException", (err) => {
    console.error("üí• Excepci√≥n no capturada:", err);
  });
  
  process.on("unhandledRejection", (reason) => {
    console.error("üí• Promesa rechazada sin catch:", reason);
  });
  
  console.log("üü¢ Iniciando entrypoint all.ts...");
  
  import { startEmailBot } from "../services/email";
  import { startWhatsAppBot } from "../services/whatsapp";
  import { startChannelManagerBot } from "../services/channelManager";
  
  async function startAll() {
    try {
      await Promise.all([
        startEmailBot(),
        startWhatsAppBot(),
        startChannelManagerBot(),
      ]);
      console.log("‚úÖ Todos los canales iniciados correctamente.");
    } catch (err) {
      console.error("‚ùå Error al iniciar uno o m√°s canales:", err);
    }
  }
  
  startAll();
  
---------------------------------


üîπ Archivo: ./lib/entrypoints/email.ts
---------------------------------

console.log("üü¢ Entrando a email.ts");

process.on("uncaughtException", (err) => {
  console.error("üí• Excepci√≥n no capturada:");
  console.error("Tipo:", typeof err);
  console.error("Contenido:", err);
  console.error("Inspecci√≥n profunda:", require("util").inspect(err, { depth: null, colors: true }));
});

process.on("unhandledRejection", (reason) => {
  console.error("üí• Promesa rechazada sin catch:");
  console.error("Tipo:", typeof reason);
  console.error("Contenido:", reason);
  console.error("Inspecci√≥n profunda:", require("util").inspect(reason, { depth: null, colors: true }));
});

console.log("üõ†Ô∏è Iniciando entrypoint email.ts");

import { startEmailBot } from "../../lib/services/email";

console.log("üì• startEmailBot importado");
(async () => {
  try {
    console.log("üöÄ Iniciando bot de email...");
    await startEmailBot();
  } catch (error) {
    console.error("‚õî Error en el bot de email:", error instanceof Error ? error.message : error);
    console.error(error); // üëà esto imprime el stack completo
  }
})();
---------------------------------


üîπ Archivo: ./lib/entrypoints/whatsapp.ts
---------------------------------
// lib/entrypoints/whatsapp.ts
import dotenv from "dotenv";
dotenv.config();

import { startWhatsAppBot } from "../services/whatsapp";

console.log("üöÄ Iniciando bot de WhatsApp...");
startWhatsAppBot();

---------------------------------


üîπ Archivo: ./lib/astra/index.ts
---------------------------------
import { DataAPIClient } from "@datastax/astra-db-ts";

const ASTRA_DB_APPLICATION_TOKEN = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_COLLECTION_NAME = "begaia";

export async function searchAstraDB(query: string) {
  try {
    const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
    const db = client.db('https://bd3a9cf5-660d-4c90-ad58-39a03af1fed2-us-east-2.apps.astra.datastax.com');
    const collections = await db.listCollections();
    console.log("üìÇ Colecciones en AstraDB:", collections);

    const collection = db.collection(ASTRA_DB_COLLECTION_NAME);
    if (!collection) {
      throw new Error(`No se encontr√≥ la colecci√≥n: ${ASTRA_DB_COLLECTION_NAME}`);
    }

    // Generar embedding de la consulta con OpenAI
    const response = await fetch("https://api.openai.com/v1/embeddings", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: "text-embedding-ada-002",
        input: query,
      }),
    });

    const { data } = await response.json();
    let queryVector = data[0].embedding;

    console.log("üî¢ Dimensi√≥n del embedding de la consulta:", queryVector.length);

    if (queryVector.length !== 1536) {
      console.warn("‚ö† ADVERTENCIA: El embedding de la consulta no tiene 1536 dimensiones.");
    }

    // Verificar la configuraci√≥n de la colecci√≥n en AstraDB
    const collectionInfo = await collection.options();
    console.log("üìå Configuraci√≥n de la colecci√≥n en AstraDB:", JSON.stringify(collectionInfo, null, 2));

    // Realizar b√∫squeda vectorial
    console.log("üîç Ejecutando b√∫squeda vectorial...");
    const cursor = await collection.find({}, {
      sort: { $vector: queryVector },
      limit: 10,
      includeSimilarity: true,
    });

    const results = await cursor.toArray();
    console.log("üìÑ Documentos obtenidos:", JSON.stringify(results, null, 2));

    return results;
  } catch (error) {
    console.error("‚ùå Error en searchAstraDB:", error);
    throw error;
  }
}

---------------------------------


üîπ Archivo: ./lib/astra/load_from_pdf.ts
---------------------------------
import { DataAPIClient } from "@datastax/astra-db-ts";
import OpenAI from "openai";
import fs from "fs";
import pdf from "pdf-parse";
import path from "path";
import dotenv from "dotenv";
dotenv.config();

const ASTRA_DB_APPLICATION_TOKEN: string = process.env.ASTRA_DB_APPLICATION_TOKEN!;
const ASTRA_DB_COLLECTION_NAME: string = "begaia";
const OPENAI_API_KEY: string = process.env.OPENAI_API_KEY!;
const PDF_FILE_PATH = path.resolve("app/lib/hotel_demo.pdf");
const JSON_OUTPUT_PATH = path.resolve("hotel_data.json");

const client = new DataAPIClient(ASTRA_DB_APPLICATION_TOKEN);
const db = client.db("https://bd3a9cf5-660d-4c90-ad58-39a03af1fed2-us-east-2.apps.astra.datastax.com");
const collection = db.collection(ASTRA_DB_COLLECTION_NAME);
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

// Funci√≥n para generar embeddings con OpenAI sin reducci√≥n
async function generateEmbeddings(text: string): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: "text-embedding-ada-002", // Usa 1536 dimensiones
    input: text,
  });
  return response.data[0].embedding;
}

// Funci√≥n para verificar la configuraci√≥n de la colecci√≥n en AstraDB
async function checkCollectionConfig() {
  const collectionInfo = await collection.options();
  console.log("üìå Configuraci√≥n REAL de la colecci√≥n en AstraDB:", JSON.stringify(collectionInfo, null, 2));

  if (collectionInfo.vector?.dimension !== 1536) {
    console.warn("‚ö† ADVERTENCIA: La colecci√≥n no est√° configurada para embeddings de 1536 dimensiones.");
  }
}

// Carga de datos en AstraDB y guardado en JSON
async function loadHotelData(): Promise<void> {
  try {
    // Verificar la configuraci√≥n de la colecci√≥n antes de cargar datos
    await checkCollectionConfig();

    const pdfBuffer: Buffer = fs.readFileSync(PDF_FILE_PATH);
    const pdfData = await pdf(pdfBuffer);
    const hotelData: string = pdfData.text;

    console.log("üîç Generando embedding para el texto completo...");
    const embedding: number[] = await generateEmbeddings(hotelData);
    console.log("üí™ Dimensi√≥n del embedding generado:", embedding.length);

    if (embedding.length !== 1536) {
      console.warn("‚ö† ADVERTENCIA: El embedding generado no tiene 1536 dimensiones.");
    }

    const document = {
      idea: hotelData, // Se usa 'idea' como campo de texto
      $vector: embedding, // Usa el campo correcto para AstraDB
      metadata: {
        source: "Hotel Demo Punta del Este",
        createdAt: new Date().toISOString(),
      },
    };

    // Guardar en archivo JSON
    fs.writeFileSync(JSON_OUTPUT_PATH, JSON.stringify(document, null, 2));
    console.log("‚úÖ Documento guardado en hotel_data.json");

    // Insertar en AstraDB
    await collection.insertOne(document);
    console.log("‚úÖ Documento insertado en AstraDB con √©xito.");

  } catch (error) {
    console.error("‚ùå Error cargando datos en AstraDB:", error);
  }
}

// Ejecutar la carga de datos
loadHotelData();

---------------------------------


üîπ Archivo: ./lib/agents/retrieval_based.ts
---------------------------------
import { ChatOpenAI } from "@langchain/openai";
import { GraphState} from "./index";
import { AIMessage, HumanMessage } from "@langchain/core/messages";
import { defaultPrompt, curatedPrompts } from "../prompts";
import { debugLog } from "../utils/debugLog";
import { searchFromAstra } from "../retrieval";

let localModel: ChatOpenAI | null = null;

export function setRetrievalModel(model: ChatOpenAI) {
  localModel = model;
}

// ‚úÖ Seteo por defecto
setRetrievalModel(new ChatOpenAI({ modelName: "gpt-4o", temperature: 0 }));

process.env.OPENAI_LOG = "off";

const translationModel = new ChatOpenAI({ model: "gpt-4o" });

async function translateResponseBack(originalLang: string, content: string): Promise<string> {
  if (originalLang === process.env.SYSTEM_NATIVE_LANGUAGE) return content;

  const translated = await translationModel.invoke([
    {
      role: "system",
      content: `Traduce el siguiente contenido al idioma '${originalLang}' manteniendo emojis y formato Markdown.`,
    },
    { role: "user", content },
  ]);

  return typeof translated.content === "string" ? translated.content : content;
}

export async function retrieve_hotel_info(
  query: string,
  lang: string,
  hotelId: string,
  category?: string,
  promptKey?: string | null
) {
  const translated = lang === process.env.SYSTEM_NATIVE_LANGUAGE
    ? { content: query }
    : await translationModel.invoke([
        {
          role: "system",
          content: `Solo responde con la traducci√≥n literal de la siguiente consulta al idioma '${process.env.SYSTEM_NATIVE_LANGUAGE}'.`,
        },
        { role: "user", content: query },
      ]);

  const searchQuery = typeof translated.content === "string"
    ? translated.content
    : JSON.stringify(translated.content);

  const docs = await searchFromAstra(searchQuery, hotelId, {
    category,
    promptKey: promptKey ?? undefined,
  });

  return docs.join("\n\n");
}

export async function retrievalBased(state: typeof GraphState.State) {
  const lastMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const userQuery = typeof lastMessage?.content === "string" ? lastMessage.content.trim() : "";
  const lang = state.detectedLanguage ?? process.env.SYSTEM_NATIVE_LANGUAGE;
  const promptKey = state.promptKey;
  const hotelId = (state as any).hotelId ?? "defaultHotelId"; // fallback por si no viene

  if (!userQuery) {
    return { messages: [new AIMessage("Consulta vac√≠a o inv√°lida.")] };
  }

  const retrievedInfo = await retrieve_hotel_info(userQuery, lang, hotelId, state.category, promptKey);

  if (!retrievedInfo) {
    debugLog("‚ö†Ô∏è No se encontr√≥ informaci√≥n relevante en los documentos.");
    if (!localModel) {
      throw new Error("localModel is not initialized.");
    }
    const response = await localModel.invoke(state.messages);
    const responseText = typeof response.content === "string" ? response.content.trim() : "";
    return {
      messages: [new AIMessage(responseText || "Lo siento, no encontr√© informaci√≥n.")],
    };
  }

  const promptTemplate = (promptKey && curatedPrompts[promptKey]) || defaultPrompt;
  const finalPrompt = promptTemplate
    .replace("{{retrieved}}", retrievedInfo)
    .replace("{{query}}", userQuery);

  if (!localModel) {
    throw new Error("localModel is not initialized.");
  }
  const response = await localModel.invoke([
    { role: "system", content: finalPrompt },
    { role: "user", content: userQuery },
  ]);

  const responseText = typeof response.content === "string" ? response.content.trim() : "";
  const finalResponse = lang === process.env.SYSTEM_NATIVE_LANGUAGE
    ? responseText
    : await translateResponseBack(lang, responseText);

  return {
    ...state,
    messages: [...state.messages, new AIMessage(finalResponse || "Lo siento, no encontr√© informaci√≥n.")],
  };
}

---------------------------------


üîπ Archivo: ./lib/agents/billing.ts
---------------------------------
// app/agents/billings.ts
import { AIMessage } from "@langchain/core/messages";
export function handleBilling() {
    return { messages: [new AIMessage("Handling billings query")] };
}

---------------------------------


üîπ Archivo: ./lib/agents/defaultResponse.ts
---------------------------------
// app/agents/defaultResponse.ts
import { AIMessage } from "@langchain/core/messages";
export function defaultResponse() {
    return { messages: [new AIMessage("Handling default respponse query")] };
}

---------------------------------


üîπ Archivo: ./lib/agents/reservations.ts
---------------------------------
import { pms } from "lib/pms";

export async function handleReservation(state: { messages: { content: string }[] }) {
  const userMessage = state.messages[0].content; // Extraer el mensaje del usuario
  console.log(`User request: ${userMessage}`); // Se usa para evitar el error de variable no utilizada

  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [`Reservation confirmed: ${response.id}`] };
}

---------------------------------


üîπ Archivo: ./lib/agents/services.ts
---------------------------------
// app/agents/services.ts
import { AIMessage } from "@langchain/core/messages";
export function handleServices() {
    return { messages: [new AIMessage("Handling services query")] };
}
---------------------------------


üîπ Archivo: ./lib/agents/internal_support.ts
---------------------------------
// app/agents/internal_support.ts
import { AIMessage } from "@langchain/core/messages";
export function handleSupport() {
    return { messages: [new AIMessage("Handling support query")] };
}


---------------------------------


üîπ Archivo: ./lib/agents/index.ts
---------------------------------
import { StateGraph } from "@langchain/langgraph";
import { classifyQuery } from "../classifier";
import { AIMessage, HumanMessage, BaseMessage } from "@langchain/core/messages";
import { pms } from "../pms";
import { ChatOpenAI } from "@langchain/openai";
import { createRetrieverTool } from "langchain/tools/retriever";
import { Annotation } from "@langchain/langgraph";
import { retrievalBased } from "./retrieval_based";
import { franc } from "franc";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";
import { searchFromAstra } from "../retrieval";
import { detectLanguage } from "../utils/language";


process.env.OPENAI_LOG = "off";
debugLog("üîß Compilando grafo conversacional...");

// ----------------------------
// Estado del grafo
export const GraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),
    default: () => [] as BaseMessage[],
  }),
  category: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "other",
  }),
  detectedLanguage: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "en",
  }),
  promptKey: Annotation<string | null>({
    reducer: (x, y) => y,
    default: () => null,
  }),
  hotelId: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "hotel123",
  }),
});

// ----------------------------
// Vector store y modelo (usado por retrievalBased)
export let vectorStore: any;
let retriever: any;
export let model: any;

export async function initializeVectorStore() {
  if (!vectorStore) {
    // Simula un retriever a partir de AstraDB
    vectorStore = {
      asRetriever: () => ({
        getRelevantDocuments: async (query: string) => {
          const results = await searchFromAstra(query, "hotel123");
          return results.map((text) => ({
            pageContent: text,
            metadata: {},
          }));
        },
      }),
    };

    retriever = createRetrieverTool(vectorStore.asRetriever(), {
      name: "retrieve_hotel_info",
      description: "Search hotel FAQs and policies.",
    });

    model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 }).bindTools([retriever]);
    debugLog("‚úÖ Vector store inicializado desde AstraDB (sin Puppeteer)");
  }
}

// ----------------------------
// Nodo de clasificaci√≥n
export async function classifyNode(state: typeof GraphState.State) {
  const lastUserMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const question = typeof lastUserMessage?.content === "string" ? lastUserMessage.content.trim() : "";

  if (!question) {
    return {
      ...state,
      category: "retrieval_based",
      promptKey: null,
      messages: [
        ...state.messages,
        new AIMessage("Consulta vac√≠a o no v√°lida. Intenta reformular tu pregunta."),
      ],
    };
  }

  const detectedLang = detectLanguage(question);


  let classification;
  try {
    classification = await classifyQuery(question);
    debugLog("üîÄ Clasificaci√≥n detectada:", classification);
  } catch (e) {
    console.error("‚ùå Error clasificando la consulta:", e);
    classification = { category: "retrieval_based", promptKey: null };
  }

  const { category, promptKey } = classification;
  const validPromptKeys = promptMetadata[category] || [];
  const finalPromptKey = validPromptKeys.includes(promptKey || "") ? promptKey : null;

  debugLog("üß† Clasificaci√≥n final:", { category, promptKey: finalPromptKey });

  return {
    ...state,
    category,
    promptKey: finalPromptKey,
    detectedLanguage: detectedLang || process.env.SYSTEM_NATIVE_LANGUAGE,
    messages: [
      ...state.messages,
      new AIMessage(`Consulta clasificada como: ${category}${finalPromptKey ? ` (üß† promptKey: ${finalPromptKey})` : ""}`),
    ],
  };
}

// ----------------------------
// Nodos funcionales del grafo
async function handleReservationNode() {
  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [new AIMessage(`Reserva confirmada: ${response.id}`)] };
}
async function handleAmenitiesionNode() {
  return { messages: [new AIMessage("Aqu√≠ est√°n los detalles de amenities.")] };
}
async function handleBillingNode() {
  return { messages: [new AIMessage("Aqu√≠ est√°n los detalles de facturaci√≥n.")] };
}
async function handleSupportNode() {
  return { messages: [new AIMessage("¬øEn qu√© puedo ayudarte? Nuestro equipo est√° disponible para asistirte.")] };
}
async function retrievalBasedNode(state: typeof GraphState.State) {
  return await retrievalBased(state);
}

// ----------------------------
// Definici√≥n del grafo
const graph = new StateGraph(GraphState)
  .addNode("classify", classifyNode)
  .addNode("handle_reservation", handleReservationNode)
  .addNode("handle_amenities", handleAmenitiesionNode)
  .addNode("handle_billing", handleBillingNode)
  .addNode("handle_support", handleSupportNode)
  .addNode("handle_retrieval_based", retrievalBasedNode)
  .addEdge("__start__", "classify")
  .addConditionalEdges("classify", (state) => state.category, {
    reservation: "handle_reservation",
    amenities: "handle_amenities",
    billing: "handle_billing",
    support: "handle_support",
    retrieval_based: "handle_retrieval_based",
  })
  .addEdge("handle_reservation", "__end__")
  .addEdge("handle_amenities", "__end__")
  .addEdge("handle_billing", "__end__")
  .addEdge("handle_support", "__end__")
  .addEdge("handle_retrieval_based", "__end__");

debugLog("‚úÖ Grafo compilado con √©xito.");
export const agentGraph = graph.compile();

---------------------------------


üîπ Archivo: ./lib/utils/debugLog.ts
---------------------------------
// lib/utils/debugLog.ts

export function debugLog(...args: any[]) {
  if (process.env.DEBUG === "true") {
    console.log("üêû DEBUG:", ...args);
  }
}

  
---------------------------------


üîπ Archivo: ./lib/utils/language.ts
---------------------------------
import { franc } from "franc";

const supportedLanguages = new Set(["spa", "eng", "ita", "fra", "por"]);

export function detectLanguage(text: string): string {
  if (!text || text.trim().length < 10) return "spa";

  const lang = franc(text.trim(), { minLength: 3 });

  return supportedLanguages.has(lang) ? lang : "spa";
}

---------------------------------


üîπ Archivo: ./lib/utils/similarity.ts
---------------------------------
export function cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (normA * normB);
  }
  
---------------------------------


üîπ Archivo: ./lib/utils.ts
---------------------------------
// lib/utils.ts
export function cn(...classes: (string | undefined | false | null)[]) {
    return classes.filter(Boolean).join(" ");
  }
  
---------------------------------


üîπ Archivo: ./test/agents.test.ts
---------------------------------
import { test, expect, vi, describe } from "vitest";
import 'openai/shims/node';

// üõë Mock de OpenAI para evitar llamadas reales
vi.mock("@langchain/openai", () => ({
  ChatOpenAI: vi.fn(() => ({
    invoke: vi.fn(() =>
      Promise.resolve({ content: "S√≠, las habitaciones tienen WiFi gratis." })
    ),
  })),
}));

// üõë Mock de retrieve_hotel_info para evitar acceso a la base de datos
vi.mock("@/agents/room_info", () => ({
  retrieve_hotel_info: vi.fn(() => Promise.resolve("üì∂ WiFi gratis")),
}));

// üîÑ Ahora importamos despu√©s de los mocks
import { ChatOpenAI } from "@langchain/openai";
import * as Agents from "lib/agents/retrieval_based";

describe("Agente de hotel - Pruebas con respuestas mockeadas", () => {
  test("El modelo usa correctamente la base vectorial", async () => {
    const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 });
    const query = "¬øLas habitaciones tienen WiFi gratis?";
    const lang = process.env.SYSTEM_NATIVE_LANGUAGE || 'es';
    const vectorResponse = await Agents.retrieve_hotel_info("¬øQu√© tipos de habitaciones tienen?", lang);
    const aiResponse = await model.invoke([{ role: "user", content: query }]);

    console.log("üìå Respuesta del modelo:", aiResponse);
    console.log("üìå Tipo de aiResponse:", typeof aiResponse);

    expect(aiResponse.content).toContain("WiFi gratis");
    expect(vectorResponse).toContain("üì∂ WiFi gratis");
  });
});

---------------------------------


üîπ Archivo: ./test/presentacion.test.ts
---------------------------------
import { test, expect } from "vitest";
import { retrievalBased } from "../lib/agents/retrieval_based";
import { GraphState } from "../lib/agents"; // importa el GraphState para armar el estado
import { HumanMessage } from "@langchain/core/messages";

test("El formato contiene Markdown visual con emojis", async () => {
  const testQuery = "¬øQu√© tipos de habitaciones tienen?";

  // üß† Simular estado del grafo como si viniera del flujo real
  const testState: typeof GraphState.State = {
    messages: [new HumanMessage(testQuery)],
    category: "room_info",
    detectedLanguage: "es",
    promptKey: null
  };

  // ‚úÖ Invocar el nodo como lo har√≠a LangGraph
  const result = await retrievalBased(testState);

  // üßæ Extraer respuesta
  const response = result.messages[0].content;

  // üß™ Aserciones sobre el formato visual
  expect(response).toMatch(/üè®/); // emoji t√≠tulo
  expect(response).toMatch(/\| üõèÔ∏è/); // tabla
  expect(response).toMatch(/\*\*¬°Reserva ahora.*\*\*/); // llamado final en negrita
});

---------------------------------


üîπ Archivo: ./test/retrieval.test.ts
---------------------------------
import { test, expect } from "vitest";

import { retrieve_hotel_info } from "../lib/agents/retrieval_based.ts";

test("Recupera informaci√≥n sobre habitaciones correctamente", async () => {
  const query = "¬øQu√© tipos de habitaciones tienen?";
  const response = await retrieve_hotel_info(query, "es");
  console.log("üìå Respuesta obtenida:", response);

  expect(response).toContain("Habitaci√≥n");
  expect(response).toContain("√°rea de");
  expect(response).toContain("Ba√±o privado");
});



---------------------------------


üîπ Archivo: ./test/chat.test.ts
---------------------------------
import "openai/shims/node"; // Para arreglar el fetch de OpenAI
import request from "supertest";
import { createServer } from "http";
import { POST } from "../app/api/chat/route.ts";
import { test, expect, beforeAll, afterAll } from "vitest";

// üìå Servidor de pruebas
let server: any;

beforeAll(() => {
  server = createServer(async (req, res) => {
    try {
      let data = "";
      req.on("data", (chunk) => (data += chunk));
      req.on("end", async () => {
        try {
          const body = JSON.parse(data);

          // ‚úÖ Aseguramos que la URL sea absoluta
          const fullUrl = new URL(req.url ?? "/api/chat", "http://localhost:3001");

          const nextReq = new Request(fullUrl.toString(), {
            method: req.method ?? "POST",
            headers: req.headers as HeadersInit,
            body: JSON.stringify(body),
          });

          // Ejecutar la funci√≥n POST de Next.js
          const response = await POST(nextReq);
          const responseData = await response.json();

          // Responder con el contenido de Next.js
          res.writeHead(response.status, { "Content-Type": "application/json" });
          res.end(JSON.stringify(responseData));
        } catch (error) {
          console.error("‚ùå Error al parsear JSON:", error);
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Solicitud inv√°lida" }));
        }
      });
    } catch (error) {
      console.error("‚ùå Error en el servidor de pruebas:", error);
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Error interno en el servidor" }));
    }
  });

  server.listen(3001, () => {
    console.log("üöÄ Servidor de pruebas en ejecuci√≥n en el puerto 3001");
  });
});

afterAll(() => {
  server.close();
  console.log("üõë Servidor de pruebas detenido.");
});

// üî• Test para validar la API de chat
test("Debe responder con un mensaje v√°lido del bot", async () => {
  const response = await request(server)
    .post("/api/chat")
    .send({ query: "¬øQu√© tipos de habitaciones tienen?" });

  console.log("üìå Respuesta del servidor:", response.body);

  expect(response.status).toBe(200);
  expect(response.body).toBeDefined();
  expect(response.body.response).toBeDefined();
  expect(response.body.response.length).toBeGreaterThan(0);
});

---------------------------------


üîπ Archivo: ./test/ui.test.tsx
---------------------------------
import { test, expect } from "vitest";
import "@testing-library/jest-dom"; // üëà Agregar esto

import React from "react";
import { render, screen } from "@testing-library/react";
import { describe, it} from "vitest";
import ReactMarkdown from "react-markdown";
import rehypeRaw from "rehype-raw";

describe("ReactMarkdown", () => {
  it("Renderiza un enlace en ReactMarkdown", () => {
    render(
      <ReactMarkdown rehypePlugins={[rehypeRaw]}>
        {"[Reserva aqu√≠](https://booking.bedzzle.com/desktop/?&apikey=123&lang=es)"}
      </ReactMarkdown>
    );

    const linkElement = screen.getByText("Reserva aqu√≠");
    expect(linkElement).toBeInTheDocument(); // ‚úÖ Ahora funcionar√°
  });
});

---------------------------------


üîπ Archivo: ./app/admin/embeddings/page.tsx
---------------------------------
// /app/admin/embeddings/page.tsx
export default function EmbeddingsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Embeddings</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/admin/prompts/page.tsx
---------------------------------
// /app/admin/prompts/page.tsx
export default function PromptsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Prompts</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/admin/channels/page.tsx
---------------------------------
// /app/admin/channels/page.tsx

// ‚úÖ P√°gina de administraci√≥n de canales
import { getHotelConfig } from "@/lib/config/hotelConfig.server";
import ChannelsClient from "@/components/admin/ChannelsClient";
import { BarChart3 } from "lucide-react";

export default async function ChannelsPage() {
  const hotelId = "hotel123";
  const config = await getHotelConfig(hotelId);

  if (!config) {
    return (
      <div className="min-h-screen bg-background text-foreground py-12 px-6">
        <h1 className="text-3xl font-bold mb-6 flex items-center gap-2">
          <BarChart3 className="w-6 h-6" />
          Estado de Canales
        </h1>
        <p className="text-red-500">‚ùå Error: no se pudo cargar la configuraci√≥n del hotel.</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground py-12 px-6">
      <h1 className="text-3xl font-bold mb-6 flex items-center gap-2">
        <BarChart3 className="w-6 h-6" />
        Estado de Canales
      </h1>

      <ChannelsClient initialConfig={config.channelConfigs} />
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/upload/page.tsx
---------------------------------
// /app/admin/upload/page.tsx
export default function UploadPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Upload</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/admin/layout.tsx
---------------------------------
// /app/admin/layout.tsx
"use client";

import { ReactNode } from "react";
import { ThemeToggle } from "@/components/ui/ThemeToggle";
import { SidebarLink } from "@/components/ui/SidebarLink";
import {
  Home,
  Hotel,
  Upload,
  Brain,
  FileText,
} from "lucide-react";

export default function AdminLayout({ children }: { children: ReactNode }) {
  return (
    <div className="flex min-h-screen bg-background text-foreground transition-colors duration-300">
      {/* Sidebar */}
      <aside className="w-64 bg-gray-900 p-4 flex flex-col justify-between text-foreground">
        <div>
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-2xl font-bold">Begasist Admin</h1>
            <ThemeToggle />
          </div>
          <nav className="space-y-2">
            <SidebarLink href="/admin" icon={<Home className="w-5 h-5" />} label="Inicio" />
            <SidebarLink href="/admin/hotels" icon={<Hotel className="w-5 h-5" />} label="Hoteles" />
            <SidebarLink href="/admin/upload" icon={<Upload className="w-5 h-5" />} label="Carga de datos" />
            <SidebarLink href="/admin/prompts" icon={<Brain className="w-5 h-5" />} label="Prompts" />
            <SidebarLink href="/admin/logs" icon={<FileText className="w-5 h-5" />} label="Logs" />
          </nav>
        </div>
      </aside>

      {/* Main content */}
      <main className="flex-1 p-6 overflow-y-auto">{children}</main>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/page.tsx
---------------------------------
// /app/admin/page.tsx
"use client";

import { Button } from "@/components/ui/button";
import Link from "next/link";
import { DarkCard } from "@/components/ui/DarkCard";
import {
  Hotel,
  Upload,
  Brain,
  BookOpen,
  Server,
  FileText,
  Settings,
} from "lucide-react";

export default function AdminDashboard() {
  return (
    <div className="min-h-screen bg-background text-foreground py-12 px-6">
      <h1 className="text-3xl font-bold text-center mb-10 flex items-center justify-center gap-3">
        <Settings className="w-6 h-6" />
        Panel de Control
      </h1>

      <div className="max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <Hotel className="w-5 h-5" />
              Hoteles
            </div>
          }
          description="Gestion√° tus hoteles registrados en el sistema."
        >
          <Link href="/admin/hotels">
            <Button>Ver hoteles</Button>
          </Link>
        </DarkCard>

        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <Upload className="w-5 h-5" />
              Carga de Datos
            </div>
          }
          description="Sub√≠ documentos o URLs para enriquecer la base de conocimiento."
        >
          <Link href="/admin/upload">
            <Button>Cargar datos</Button>
          </Link>
        </DarkCard>

        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <Brain className="w-5 h-5" />
              Embeddings
            </div>
          }
          description="Consult√° y gestion√° la base vectorial por hotel y categor√≠a."
        >
          <Link href="/admin/embeddings">
            <Button>Ver embeddings</Button>
          </Link>
        </DarkCard>

        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <BookOpen className="w-5 h-5" />
              Prompts Curados
            </div>
          }
          description="Edit√° prompts por categor√≠a y subcategor√≠a."
        >
          <Link href="/admin/prompts">
            <Button>Editar prompts</Button>
          </Link>
        </DarkCard>

        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <Server className="w-5 h-5" />
              Canales
            </div>
          }
          description="Estado de los canales conectados: web, email, WhatsApp, channel manager."
        >
          <Link href="/admin/channels">
            <Button>Ver estado</Button>
          </Link>
        </DarkCard>

        <DarkCard
          title={
            <div className="flex items-center gap-2">
              <FileText className="w-5 h-5" />
              Logs y Debug
            </div>
          }
          description="Revis√° errores, ejecuciones recientes y trazas de flujo."
        >
          <Link href="/admin/logs">
            <Button>Ver logs</Button>
          </Link>
        </DarkCard>
      </div>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/hotels/page.tsx
---------------------------------
// /app/admin/hotels/page.tsx
export default function HotelsPage() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Hotels</h1>
      <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/admin/logs/page.tsx
---------------------------------
// /app/admin/logs/page.tsx
export default function LogsPage() {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Logs</h1>
        <p className="text-gray-500">Esta secci√≥n estar√° disponible pr√≥ximamente.</p>
      </div>
    );
  }
  
---------------------------------


üîπ Archivo: ./app/lib/translation.ts
---------------------------------
process.env.OPENAI_LOG = "off";
import { ChatOpenAI } from "@langchain/openai";

const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 });

export async function translationModel(text: string, targetLanguage: string) {
  return await model.invoke([{ role: "system", content: `Translate this to ${targetLanguage}: ${text}` }]);
}

---------------------------------


üîπ Archivo: ./app/globals.css
---------------------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

/* üé® Variables de tema */
:root {
  --background: #ffffff;
  --foreground: #171717;
  --border: #e5e7eb;
  --muted-foreground: #6b7280;
}

html.dark {
  --background: #0a0a0a;
  --foreground: #ededed;
  --border: #444;
  --muted-foreground: #a1a1aa;
}

/* üí° Fallback si el usuario prefiere dark */
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

/* üåç Estilo global del body */
body {
  background-color: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
  transition: background-color 0.3s, color 0.3s;
}

/* üîó Estilos de links */
a {
  color: #2563eb;
  text-decoration: underline;
}

a:hover {
  color: #1e40af;
}

---------------------------------


üîπ Archivo: ./app/layout.tsx
---------------------------------
// /app/layout.tsx
import { Metadata } from "next";
import { ThemeProvider } from "@/context/ThemeContext";
import { ApplyThemeClass } from "@/components/utils/ApplyThemeClass";
import "./globals.css";

export const metadata: Metadata = {
  title: "Begasist",
  description: "Asistente conversacional hotelero",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="bg-background text-foreground transition-colors duration-300">
        <ThemeProvider>
          <ApplyThemeClass />
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

---------------------------------


üîπ Archivo: ./app/page.tsx
---------------------------------
// /app/page.tsx
"use client";

import { useState } from "react";
import ReactMarkdown from "react-markdown";

export default function ChatPage() {
  const [query, setQuery] = useState("");
  const [response, setResponse] = useState("");
  const [loading, setLoading] = useState(false);

  const sendQuery = async () => {
    if (!query.trim()) return;

    setLoading(true);
    setResponse("");

    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query }),
      });

      const data = await res.json();
      const responseText =
        typeof data.response === "string"
          ? data.response
          : JSON.stringify(data.response, null, 2);

      setResponse(responseText);
    } catch (error) {
      console.error("Error en la consulta:", error);
      setResponse("Error al obtener respuesta.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-background text-foreground p-6 transition-colors">
      <h1 className="text-3xl font-bold mb-4">üí¨ Chat con IA</h1>

      <div className="w-full max-w-lg bg-muted p-4 shadow-md rounded-lg border border-border">
        <textarea
          className="w-full border border-border bg-background text-foreground p-2 rounded-md focus:ring-2 focus:ring-blue-500 outline-none transition"
          rows={3}
          placeholder="Escrib√≠ tu pregunta..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />

        <button
          className="w-full bg-blue-600 text-white p-2 mt-3 rounded-md hover:bg-blue-700 transition"
          onClick={sendQuery}
          disabled={loading}
        >
          {loading ? "Pensando..." : "Preguntar"}
        </button>
      </div>

      {response && (
        <div className="w-full max-w-lg bg-muted p-4 mt-4 shadow-md rounded-lg border border-border text-foreground">
          <h2 className="text-lg font-semibold">ü§ñ Respuesta:</h2>
          <div className="mt-2 text-muted-foreground">
            <ReactMarkdown
              components={{
                a: ({ ...props }) => (
                  <a
                    className="text-blue-500 underline hover:text-blue-700"
                    {...props}
                  />
                ),
              }}
            >
              {response}
            </ReactMarkdown>
          </div>
        </div>
      )}
    </div>
  );
}

---------------------------------


üîπ Archivo: ./app/api/config/add/route.ts
---------------------------------
// /app/api/config/add/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig, type ChannelMode } from "@/lib/config/hotelConfig.server";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const channel = url.searchParams.get("channel");

  const allowedChannels = ["web", "email", "whatsapp", "channelManager"];

  // üö´ Verificamos si es un canal permitido
  if (!channel || !allowedChannels.includes(channel)) {
    return NextResponse.json({ error: "Canal no permitido" }, { status: 400 });
  }

  const hotelId = "hotel123"; // Simulado
  const config = await getHotelConfig(hotelId);

  // ‚úÖ Si ya existe, no hacer nada
  if (config?.channelConfigs?.[channel]) {
    return NextResponse.json({ message: "Canal ya est√° configurado" }, { status: 200 });
  }

  // ‚úÖ Agrega el canal a la configuraci√≥n
  const updatedConfigs = {
    ...config?.channelConfigs,
    [channel]: {
      enabled: false,
      mode: "supervised" as ChannelMode,
    },
  };

  await updateHotelConfig(hotelId, { channelConfigs: updatedConfigs });

  // ‚úÖ Redirige de nuevo a la p√°gina de canales
  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/config/mode/route.ts
---------------------------------
// /app/api/config/mode/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const channel = url.searchParams.get("channel");

  if (!channel) {
    return NextResponse.json({ error: "Falta el par√°metro 'channel'" }, { status: 400 });
  }

  const hotelId = "hotel123"; // simulado
  const config = await getHotelConfig(hotelId);
  const current = config?.channelConfigs?.[channel];

  if (!current) {
    return NextResponse.json({ error: "Canal no configurado" }, { status: 404 });
  }

  const newMode = current.mode === "auto" ? "supervised" : "auto";

  await updateHotelConfig(hotelId, {
    channelConfigs: {
      ...config.channelConfigs,
      [channel]: {
        ...current,
        mode: newMode,
      },
    },
  });

  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/config/toggle/route.ts
---------------------------------
// /app/api/config/toggle/route.ts
import { NextResponse } from "next/server";
import { getHotelConfig, updateHotelConfig } from "@/lib/config/hotelConfig.server";

export async function POST(req: Request) {
  const url = new URL(req.url);
  const channel = url.searchParams.get("channel");

  if (!channel) {
    return NextResponse.json({ error: "Falta el par√°metro 'channel'" }, { status: 400 });
  }

  const hotelId = "hotel123"; // ‚Üê Simulado
  const config = await getHotelConfig(hotelId);

  const current = config?.channelConfigs?.[channel];
  if (!current) {
    return NextResponse.json({ error: "Canal no configurado" }, { status: 404 });
  }

  const updatedConfigs = {
    ...config.channelConfigs,
    [channel]: {
      ...current,
      enabled: !current.enabled, // ‚Üê alternamos el valor
    },
  };

  await updateHotelConfig(hotelId, { channelConfigs: updatedConfigs });

  return NextResponse.redirect(new URL("/admin/channels", req.url));
}

---------------------------------


üîπ Archivo: ./app/api/whatsapp/route.ts
---------------------------------
// app/api/whatsapp/route.ts

import { NextResponse } from "next/server";

export async function GET() {
  return NextResponse.json({ status: "üü¢ WhatsApp bot is running." });
}

export async function POST() {
  return NextResponse.json({ status: "üü¢ WhatsApp bot is running independently and does not require webhooks." });
}

---------------------------------


üîπ Archivo: ./app/api/chat/route.ts
---------------------------------
// /root/begasist/app/api/chat/route.ts

import { NextResponse } from "next/server";
import { agentGraph } from "@/lib/agents";
import { HumanMessage, AIMessage } from "@langchain/core/messages";
import { debugLog } from "../../../lib/utils/debugLog";

process.env.OPENAI_LOG = "off";
export async function POST(req: Request) {
  try {
    const { query } = await req.json();
    
    debugLog("üîç Consulta recibida:", query);

    const hotelId = "hotel123"; // fallback

    if (!hotelId) {
      console.warn("‚ö†Ô∏è [API /chat] hotelId no proporcionado. Usando fallback: 'hotel123'");
    }

    const response = await agentGraph.invoke({
      messages: [new HumanMessage(query)],
      hotelId,
    });
    
    // Buscar el √∫ltimo mensaje que sea un AIMessage y obtener su contenido
    const aiMessage = response.messages.findLast(
      (msg) => msg instanceof AIMessage
    ) as AIMessage | undefined;

    const responseText = aiMessage?.content || "No se encontr√≥ una respuesta.";

    debugLog("üìå Respuesta enviada:", responseText);

    return NextResponse.json({ response: responseText });
  } catch (error) {
    console.error("‚õî Error en la API /api/chat:", error);
    return NextResponse.json(
      { response: "Ocurri√≥ un error al procesar la solicitud." },
      { status: 500 }
    );
  }
}

---------------------------------

