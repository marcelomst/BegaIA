ğŸ“‚ Estructura del Proyecto
=========================
.
â”œâ”€â”€ README.md
â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ api
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ chat
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts:Zone.Identifier
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ email 
â”‚Â Â  â”‚Â Â  â””â”€â”€ whatsapp
â”‚Â Â  â”‚Â Â      â””â”€â”€ route.ts
â”‚Â Â  â”œâ”€â”€ favicon.ico
â”‚Â Â  â”œâ”€â”€ generatePDF.js
â”‚Â Â  â”œâ”€â”€ globals.css
â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”œâ”€â”€ lib
â”‚Â Â  â”‚Â Â  â””â”€â”€ translation.ts
â”‚Â Â  â”œâ”€â”€ page.tsx
â”‚Â Â  â””â”€â”€ taildocs.txt
â”œâ”€â”€ arquitectura.txt
â”œâ”€â”€ documentacion
â”œâ”€â”€ ecosystem.config.js
â”œâ”€â”€ eslint.config.mjs
â”œâ”€â”€ estructura_del_proyecto.txt
â”œâ”€â”€ generate_architecture.sh
â”œâ”€â”€ google-chrome-stable_current_amd64.deb
â”œâ”€â”€ info.txt
â”œâ”€â”€ lib
â”‚Â Â  â”œâ”€â”€ agents
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ billing.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ defaultResponse.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ internal_support.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ reservations.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ retrieval_based.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ services.ts
â”‚Â Â  â”œâ”€â”€ classifier
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ config.ts
â”‚Â Â  â”œâ”€â”€ entrypoints
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ all.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ email.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ whatsapp.ts
â”‚Â Â  â”œâ”€â”€ pms
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ prompts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ promptMetadata.ts
â”‚Â Â  â”œâ”€â”€ retrieval
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ email.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ whatsapp.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ whatsappClient.ts
â”‚Â Â  â””â”€â”€ utils
â”‚Â Â      â””â”€â”€ debugLog.ts
â”œâ”€â”€ next
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.ts
â”œâ”€â”€ output_cleaned.txt
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ postcss.config.mjs
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ file.svg
â”‚Â Â  â”œâ”€â”€ fonts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ geist-latin-ext.woff2
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ geist-latin.woff2
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ geist-mono-latin-ext.woff2
â”‚Â Â  â”‚Â Â  â””â”€â”€ geist-mono-latin.woff2
â”‚Â Â  â”œâ”€â”€ globe.svg
â”‚Â Â  â”œâ”€â”€ next.svg
â”‚Â Â  â”œâ”€â”€ vercel.svg
â”‚Â Â  â””â”€â”€ window.svg
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ testClassifier.ts
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app.ts
â”‚Â Â  â”œâ”€â”€ config.ts
â”‚Â Â  â”œâ”€â”€ hotel_agent_uml.uml
â”‚Â Â  â””â”€â”€ utils
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ test
â”‚Â Â  â”œâ”€â”€ agents.test.ts
â”‚Â Â  â”œâ”€â”€ chat.test.ts
â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 05-versions-space.pdf
â”‚Â Â  â”‚Â Â  â””â”€â”€ 05-versions-space.pdf.txt
â”‚Â Â  â”œâ”€â”€ presentacion.test.ts
â”‚Â Â  â”œâ”€â”€ retrieval.test.ts
â”‚Â Â  â””â”€â”€ ui.test.tsx
â”œâ”€â”€ testAstraConnection.ts
â”œâ”€â”€ touch @types
â”‚Â Â  â””â”€â”€ rehype-raw.d.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.tsbuildinfo
â”œâ”€â”€ types
â”‚Â Â  â””â”€â”€ mailparser.d.ts
â”œâ”€â”€ vector_cache
â”‚Â Â  â””â”€â”€ rooms_vectorstore.json
â”œâ”€â”€ vitest.config.ts
â””â”€â”€ vitest.setup.ts

27 directories, 74 files

=========================

ğŸ“œ Scripts Claves
=================

ğŸ”¹ Archivo: ./lib/services/email.ts
---------------------------------
// lib/services/email.ts
import { simpleParser } from "mailparser";
import imaps from "imap-simple";
import nodemailer from "nodemailer";
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";
import dotenv from "dotenv";

dotenv.config();

console.log("âœ… Archivo email.ts cargado");
console.log("âœ… Grafo conversacional importado");

export async function startEmailBot() {
  console.log("ğŸ“¥ Inicializando conexiÃ³n IMAP...");

  try {
    const {
      EMAIL_USER,
      EMAIL_PASS,
      IMAP_HOST,
      IMAP_PORT,
      SMTP_HOST,
      SMTP_PORT,
      EMAIL_SECURE,
    } = process.env;

    if (!EMAIL_USER || !EMAIL_PASS || !IMAP_HOST || !SMTP_HOST) {
      throw new Error("âŒ Faltan variables de entorno crÃ­ticas (EMAIL_USER, EMAIL_PASS, IMAP_HOST, SMTP_HOST)");
    }

    const imapConfig = {
      imap: {
        user: EMAIL_USER,
        password: EMAIL_PASS,
        host: IMAP_HOST,
        port: Number(IMAP_PORT) || 993,
        tls: true,
        authTimeout: 3000,
      },
    };

    console.log("ğŸ“¬ Configurando transporte SMTP...");
    const transporter = nodemailer.createTransport({
      host: SMTP_HOST,
      port: Number(SMTP_PORT) || 587,
      secure: EMAIL_SECURE === "true",
      auth: {
        user: EMAIL_USER,
        pass: EMAIL_PASS,
      },
    });

    console.log("ğŸ”Œ Conectando a servidor IMAP...");
    const connection = await imaps.connect(imapConfig);
    console.log("ğŸ“¦ ConexiÃ³n IMAP establecida correctamente.");

    await connection.openBox("INBOX");
    console.log("ğŸ“¨ Bot de email listo. Escuchando correos cada 15s...");

    setInterval(async () => {
      try {
        const searchCriteria = ["UNSEEN"];
        const fetchOptions = {
          bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE)", "TEXT"],
          struct: true,
        };

        const messages = await connection.search(searchCriteria, fetchOptions);
        console.log(`ğŸ“¬ Correos no leÃ­dos encontrados: ${messages.length}`);

        for (const message of messages) {
                   
          console.log("ğŸ”================= MENSAJE RECIBIDO =================");
          console.dir(message, { depth: null });
          console.log("ğŸ”====================================================");
          console.log("ğŸ“¦ message.parts:", message.parts);

          const parts = imaps.getParts(message.attributes.struct);
          const part = parts.find((p: any) => p.type === "text");
          if (!part) continue;

          const raw = await connection.getPartData(message, part);

          const headerPart = message.parts.find((part: any) =>
            part.which?.toLowerCase().includes("header")
          );

          const rawFrom = Array.isArray(headerPart?.body?.from)
            ? headerPart.body.from[0]
            : undefined;
        
          
          const parsed = await simpleParser(raw);

          // Asegurar que htmlRaw sea string
          const htmlRaw = typeof parsed.html === "string"
            ? parsed.html
            : (typeof parsed.html === "object" && Buffer.isBuffer(parsed.html))
              ? parsed.html.toString("utf-8")
              : "";

          const htmlClean = htmlRaw.replace(/<[^>]+>/g, "").trim();

          console.log("ğŸ” headerLines:", parsed.headerLines);

          const text =
            parsed.text?.trim() ||
            htmlClean ||
            parsed.headerLines?.map((h: { key: string; line: string }) => h.line).join("\n").trim();

          const from =
            parsed.from?.text ||
            rawFrom ||
            parsed.headerLines?.find((h: { key: string; line: string }) =>
              h.line.includes("@")
            )?.line;

          

          if (text && from) {
            console.log(`ğŸ“§ Email recibido de ${from}:`, text);

            const response = await agentGraph.invoke({
              messages: [new HumanMessage(text)],
            });

            const reply = response.messages.at(-1)?.content;

            if (typeof reply === "string") {
              await transporter.sendMail({
                from: EMAIL_USER,
                to: from,
                subject: "Re: " + (parsed.subject || "Consulta recibida"),
                text: reply,
              });

              console.log(`ğŸ“¤ Respuesta enviada a ${from}`);
            }
          } else {
            console.warn("âš ï¸ Email sin texto o sin remitente vÃ¡lido (tras fallback):", { from, text, parsed });
          }
        }
      } catch (intervalErr) {
        console.error("â›” Error en el chequeo de correos:", intervalErr);
      }
    }, 15000);
  } catch (startupErr) {
    console.error("ğŸ’¥ Error crÃ­tico en startEmailBot:\n", startupErr);
    throw startupErr;
  }
}

---------------------------------


ğŸ”¹ Archivo: ./lib/services/whatsapp.ts
---------------------------------
// lib/services/whatsapp.ts

import { Message } from "whatsapp-web.js";
import { whatsappClient as client } from "./whatsappClient";
import { agentGraph } from "../agents";
import { HumanMessage } from "@langchain/core/messages";
import qrcode from "qrcode-terminal";

export function startWhatsappBot() {
  client.on("qr", (qr) => {
    console.log("âš¡ EscaneÃ¡ este cÃ³digo QR para conectar WhatsApp:");
    qrcode.generate(qr, { small: true }); // Renderiza el QR como imagen en consola
  });

  client.on("ready", () => {
    console.log("âœ… Bot de WhatsApp listo!");
  });

  client.on("message", async (message: Message) => {
    try {
      console.log(`ğŸ“© Recibido: ${message.body}`);

      const response = await agentGraph.invoke({
        messages: [new HumanMessage(message.body)],
      });

      const reply = response.messages.at(-1)?.content;
      if (typeof reply === "string" && reply.trim()) {
        await message.reply(reply);
        console.log(`ğŸ“¤ Enviado: ${reply}`);
      } else {
        console.warn("âš ï¸ Formato inesperado:", response.messages.at(-1));
      }
    } catch (error) {
      console.error("â›” Error procesando mensaje:", error);
      await message.reply("âš ï¸ OcurriÃ³ un error procesando tu solicitud.");
    }
  });

  client.initialize();
}

---------------------------------


ğŸ”¹ Archivo: ./lib/services/whatsappClient.ts
---------------------------------
import { Client } from "whatsapp-web.js";
import puppeteer from "puppeteer";

export const whatsappClient = new Client({
  puppeteer: {
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    executablePath: puppeteer.executablePath(), // ğŸ‘ˆ Esto es lo clave
  },
});

---------------------------------


ğŸ”¹ Archivo: ./lib/classifier/index.ts
---------------------------------
// ğŸ“ lib/classifier/index.ts

import { ChatOpenAI } from "@langchain/openai";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";

export type Classification = {
  category: string;
  promptKey?: string | null;
};

const classifierModel = new ChatOpenAI({
  modelName: "gpt-3.5-turbo",
  temperature: 0,
});

export async function classifyQuery(question: string): Promise<Classification> {
  const allowedCategories = Object.keys(promptMetadata).join(", ");
  const allPromptKeys = Object.entries(promptMetadata)
    .flatMap(([_, keys]) => keys)
    .filter(Boolean);

  const prompt = `
Dada la siguiente consulta del usuario, responde solo con un JSON vÃ¡lido con dos campos:

- "category": una de las siguientes: ${allowedCategories}
- "promptKey": si la categorÃ­a necesita un prompt curado especial, elige una de: [${allPromptKeys.join(", ")}]; si no, pon null.

Ejemplo de respuesta:
{
  "category": "retrieval_based",
  "promptKey": "room_info"
}

Consulta:
"${question}"
`.trim();

  const res = await classifierModel.invoke([{ role: "user", content: prompt }]);

  try {
    const parsed = JSON.parse(res.content as string);

    const category = parsed.category;
    const promptKey = parsed.promptKey;

    if (!promptMetadata[category]) {
      throw new Error(`âŒ CategorÃ­a invÃ¡lida detectada: ${category}`);
    }

    const isValidPrompt =
      promptKey === null || promptMetadata[category].includes(promptKey);

    if (!isValidPrompt) {
      throw new Error(`âŒ Prompt key invÃ¡lido: ${promptKey} para categorÃ­a: ${category}`);
    }

    debugLog("ğŸ§  ClasificaciÃ³n final:", { category, promptKey });
    return { category, promptKey };
  } catch (e) {
    console.error("âŒ Error al parsear o validar respuesta del clasificador:", res.content);
    return { category: "retrieval_based", promptKey: null };
  }
}

---------------------------------


ğŸ”¹ Archivo: ./lib/pms/index.ts
---------------------------------
export type ReservationStatus = "confirmed" | "cancelled";

export interface Reservation {
  guest: string;
  roomType: string;
  checkIn: string;
  checkOut: string;
  status: ReservationStatus;
}

export class PMS {
  private reservations: Record<string, Reservation> = {}; // ğŸ”¥ Reemplazamos `any` por `Reservation`

  createReservation(guest: string, roomType: string, checkIn: string, checkOut: string): Reservation & { id: string } {
    const id = `res-${Date.now()}`;
    this.reservations[id] = { guest, roomType, checkIn, checkOut, status: "confirmed" };
    return { id, ...this.reservations[id] };
  }

  getReservation(id: string): Reservation | null {
    return this.reservations[id] || null;
  }

  cancelReservation(id: string): Reservation | null {
    if (this.reservations[id]) {
      this.reservations[id].status = "cancelled";
      return this.reservations[id];
    }
    return null;
  }
}

export const pms = new PMS();

---------------------------------


ğŸ”¹ Archivo: ./lib/prompts/promptMetadata.ts
---------------------------------
// lib/prompts/promptMetadata.ts

/**
 * Define quÃ© promptKeys son vÃ¡lidas para cada categorÃ­a.
 * Esto evita que el clasificador invente claves y permite escalar de forma controlada.
 */
export const promptMetadata: Record<string, string[]> = {
    retrieval_based: ["room_info"],
    reservation: [],
    cancellation: [],
    billing: [],
    support: [],
  };
  
  
---------------------------------


ğŸ”¹ Archivo: ./lib/prompts/index.ts
---------------------------------
// lib/prompts/index.ts

// ğŸ§  Prompt genÃ©rico
export const defaultPrompt = `
Responde la siguiente consulta usando exclusivamente la informaciÃ³n proporcionada.

- SÃ© claro y profesional.
- Si no hay suficiente informaciÃ³n, responde con cortesÃ­a sin inventar.

InformaciÃ³n disponible:

{{retrieved}}

Consulta del usuario: "{{query}}"
`.trim();

// ğŸ¨ Prompts curados por clave
export const curatedPrompts: Record<string, string> = {
  room_info: `
Usa la siguiente informaciÃ³n del hotel para responder de manera clara y bien estructurada.

**Formato requerido:**
- Usa **Markdown** con listas y tablas para alineaciÃ³n.
- La tabla **sin lÃ­neas de separaciÃ³n entre filas**.
- Usa tÃ­tulos en **negrita** con el emoji ğŸ¨ antes del nombre de la habitaciÃ³n.
- **AÃ±ade un doble salto de lÃ­nea entre cada tipo de habitaciÃ³n.**
- **Finaliza con una invitaciÃ³n a reservar.**

Ejemplo de formato esperado:
\`\`\`md
**ğŸ¨ HabitaciÃ³n Doble**  

| ğŸ›ï¸  1 cama doble      | ğŸ“ Ãrea de 17 metros cuadrados |  
| ğŸš¿ BaÃ±o privado       | ğŸ“ TelÃ©fono                    |  
| ğŸ“º TV LCD             | ğŸ’‡â€â™€ï¸ Secador de pelo             |  
| â„ï¸ Aire acondicionado | ğŸ“¶ WiFi gratis                 |  
| ğŸ”’ Caja fuerte        | ğŸš­ No fumadores                |  
| ğŸ› Toallas            | ğŸ”¥ CalefacciÃ³n                 |  

<br><br>

**ğŸ¨ HabitaciÃ³n Triple**  

| ğŸ›ï¸  1 cama doble y 1 simple   | ğŸ“ Ãrea de 23 metros cuadrados |  
| ğŸš¿ BaÃ±o privado               | ğŸ“ TelÃ©fono                    |  
| ğŸ“º TV LCD                     | ğŸ’‡â€â™€ï¸ Secador de pelo             |  
| â„ï¸ Aire acondicionado         | ğŸ“¶ WiFi gratis                 |  
| ğŸ”’ Caja fuerte                | ğŸš­ No fumadores                |  
| ğŸ› Toallas                    | ğŸ”¥ CalefacciÃ³n                 |  

<br><br>

ğŸ“… **Â¡Reserva ahora para obtener el mejor precio!** ğŸ’°  
ğŸ”— [Haz clic aquÃ­ para reservar](https://booking.bedzzle.com/desktop/?&apikey=6177b98dc5c442893dd76be7da149008&lang=es)
\`\`\`

**AquÃ­ estÃ¡ la informaciÃ³n relevante del hotel:**  

{{retrieved}}

**AsegÃºrate de seguir estrictamente este formato.**
`, 
};

---------------------------------


ğŸ”¹ Archivo: ./lib/retrieval/index.ts
---------------------------------
import { cache } from "react";
import { Document } from "@langchain/core/documents";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import { OpenAIEmbeddings } from "@langchain/openai";
import { MemoryVectorStore } from "langchain/vectorstores/memory";
import { translationModel } from "../../app/lib/translation";
import puppeteer from "puppeteer-extra";
import dotenv from "dotenv";
import { debugLog } from "../utils/debugLog";

dotenv.config();

const urls = ["https://www.hoteldemo.com/en/index.php"];

async function fetchPageWithPuppeteer(url: string): Promise<string | null> {
  debugLog("ğŸ–¥ Cargando pÃ¡gina con Puppeteer:", url);
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });

  const page = await browser.newPage();

  try {
    await page.goto(url, { waitUntil: "networkidle2", timeout: 120000 });
    await page.waitForSelector("body", { timeout: 120000 });
    return await page.evaluate(() => document.body.innerText);
  } catch (error) {
    debugLog("âŒ Error en Puppeteer:", error);
    return null;
  } finally {
    await browser.close();
  }
}

export async function translateText(text: string) {
  try {
    const lang = process.env.SYSTEM_NATIVE_LANGUAGE;
    if (!lang) throw new Error("SYSTEM_NATIVE_LANGUAGE is not defined in .env");

    const translated = await translationModel(text, lang);
    return typeof translated.content === "string"
      ? translated.content
      : JSON.stringify(translated.content);
  } catch (error) {
    debugLog("â›” Error en traducciÃ³n:", error);
    return text;
  }
}

export const loadDocuments: () => Promise<MemoryVectorStore> = cache(async () => {
  debugLog("ğŸ“¦ Cargando e indexando documentos...");

  const docs = await Promise.all(
    urls.map(async (url) => {
      const html = await fetchPageWithPuppeteer(url);
      if (!html) return null;

      const translated = await translateText(html);
      return new Document({
        pageContent: translated,
        metadata: { source: url },
      });
    })
  );

  const validDocs = docs.filter(
    (d): d is NonNullable<typeof d> => d !== null
  );

  const splitter = new RecursiveCharacterTextSplitter({
    chunkSize: 500,
    chunkOverlap: 50,
  });

  const chunks = await splitter.splitDocuments(validDocs);

  return await MemoryVectorStore.fromDocuments(chunks, new OpenAIEmbeddings());
});

---------------------------------


ğŸ”¹ Archivo: ./lib/config.ts
---------------------------------
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  email: {
    host: process.env.EMAIL_HOST || 'smtp.gmail.com',
    port: parseInt(process.env.EMAIL_PORT || '587'),
    secure: process.env.EMAIL_SECURE === 'true',
    user: process.env.EMAIL_USER || '',
    password: process.env.EMAIL_PASSWORD || '',
    from: process.env.EMAIL_FROM || '',
  },
  // ... otras configuraciones existentes
}; 
---------------------------------


ğŸ”¹ Archivo: ./lib/entrypoints/all.ts
---------------------------------
// lib/entrypoints/all.ts
import dotenv from "dotenv";
dotenv.config();

process.on("uncaughtException", (err) => {
  console.error("ğŸ’¥ ExcepciÃ³n no capturada:", err);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("ğŸ’¥ Promesa rechazada sin catch:", reason);
});

console.log("ğŸš€ Iniciando todos los canales del asistente...");

const promises: Promise<void>[] = [];

if (process.env.ENABLE_WEB !== "false") {
  console.log("ğŸŒ Iniciando canal Web...");
  const { startWebBot } = await import("../services/web");
  promises.push(startWebBot());
}

if (process.env.ENABLE_WHATSAPP === "true") {
  console.log("ğŸ“± Iniciando canal WhatsApp...");
  const { startWhatsappBot } = await import("../services/whatsapp");
  promises.push(startWhatsappBot());
}

if (process.env.ENABLE_EMAIL !== "false") {
  console.log("ğŸ“§ Iniciando canal Email...");
  const { startEmailBot } = await import("../services/email");
  promises.push(startEmailBot());
}

console.log("ğŸ”— Iniciando canal Channel Manager...");
async function startChannelManagerBot() {
  console.log("ğŸ“¡ Simulando conexiÃ³n con Channel Manager...");

  setInterval(() => {
    const dummyReservation = {
      source: "Booking.com",
      guestName: "Juan PÃ©rez",
      dates: "2025-04-10 al 2025-04-15",
    };
    console.log("ğŸ“¥ Reserva recibida desde Channel Manager:", dummyReservation);
    // AquÃ­ mÃ¡s adelante se podrÃ­a hacer un `agentGraph.invoke()` o enviar al sistema
  }, 30000);
}

promises.push(startChannelManagerBot());

await Promise.all(promises);

---------------------------------


ğŸ”¹ Archivo: ./lib/entrypoints/email.ts
---------------------------------
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

console.log("ğŸŸ¢ Entrando a email.ts");

process.on("uncaughtException", (err) => {
  console.error("ğŸ’¥ ExcepciÃ³n no capturada:");
  console.error("Tipo:", typeof err);
  console.error("Contenido:", err);
  console.error("InspecciÃ³n profunda:", require("util").inspect(err, { depth: null, colors: true }));
});

process.on("unhandledRejection", (reason) => {
  console.error("ğŸ’¥ Promesa rechazada sin catch:");
  console.error("Tipo:", typeof reason);
  console.error("Contenido:", reason);
  console.error("InspecciÃ³n profunda:", require("util").inspect(reason, { depth: null, colors: true }));
});

console.log("ğŸ› ï¸ Iniciando entrypoint email.ts");

import { startEmailBot } from "../../lib/services/email";

console.log("ğŸ“¥ startEmailBot importado");
(async () => {
  try {
    console.log("ğŸš€ Iniciando bot de email...");
    await startEmailBot();
  } catch (error) {
    console.error("â›” Error en el bot de email:", error instanceof Error ? error.message : error);
    console.error(error); // ğŸ‘ˆ esto imprime el stack completo
  }
})();
---------------------------------


ğŸ”¹ Archivo: ./lib/entrypoints/whatsapp.ts
---------------------------------
// lib/entrypoints/whatsapp.ts
import dotenv from "dotenv";
dotenv.config();

import { startWhatsappBot } from "../services/whatsapp";

console.log("ğŸš€ Iniciando bot de WhatsApp...");
startWhatsappBot();

---------------------------------


ğŸ”¹ Archivo: ./lib/agents/retrieval_based.ts
---------------------------------
// ğŸ“ lib/agents/room_info.ts

import { ChatOpenAI } from "@langchain/openai";
import { GraphState, model, vectorStore } from "./index";
import { AIMessage, HumanMessage } from "@langchain/core/messages";
import { defaultPrompt, curatedPrompts } from "../prompts";
import { debugLog } from "../utils/debugLog";

const translationModel = new ChatOpenAI({ model: "gpt-4o" });

// ğŸŒ TraducciÃ³n de respuesta al idioma original
async function translateResponseBack(originalLang: string, content: string): Promise<string> {
  if (originalLang === process.env.SYSTEM_NATIVE_LANGUAGE) return content;

  const translated = await translationModel.invoke([
    {
      role: "system",
      content: `Traduce el siguiente contenido al idioma '${originalLang}' manteniendo emojis y formato Markdown.`,
    },
    {
      role: "user",
      content,
    },
  ]);

  return typeof translated.content === "string" ? translated.content : content;
}

// ğŸ” BÃºsqueda semÃ¡ntica de informaciÃ³n
export async function retrieve_hotel_info(query: string, lang: string) {
  const translatedQuery =
    lang === process.env.SYSTEM_NATIVE_LANGUAGE
      ? { content: query }
      : await translationModel.invoke([
          {
            role: "system",
            content: `Solo responde con la traducciÃ³n literal de la siguiente consulta al idioma '${process.env.SYSTEM_NATIVE_LANGUAGE}'. No aÃ±adas ningÃºn comentario ni explicaciÃ³n.`,
          },
          {
            role: "user",
            content: query,
          },
        ]);

  const searchQuery =
    typeof translatedQuery.content === "string"
      ? translatedQuery.content
      : JSON.stringify(translatedQuery.content);

  const results = await vectorStore.similaritySearch(searchQuery, 5);

  debugLog("ğŸ” Resultados de bÃºsqueda:", results.map(r => r.pageContent.slice(0, 100)));

  return results.map((doc) => doc.pageContent).join("\n\n");
}

// ğŸ” Nodo principal para manejo genÃ©rico con recuperaciÃ³n
export async function retrievalBased(state: typeof GraphState.State) {
  const lastUserMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const userQuery =
    typeof lastUserMessage?.content === "string" ? lastUserMessage.content.trim() : "";
  const lang = state.detectedLanguage ?? process.env.SYSTEM_NATIVE_LANGUAGE;
  const promptKey = state.promptKey;

  if (!userQuery.trim()) {
    return { messages: [new AIMessage("Consulta vacÃ­a o invÃ¡lida.")] };
  }

  const retrievedInfo = await retrieve_hotel_info(userQuery, lang);

  if (!retrievedInfo.trim()) {
    debugLog("âš ï¸ No se encontrÃ³ informaciÃ³n relevante en los documentos.");
    const response = await model.invoke(state.messages);
    const responseText = typeof response.content === "string" ? response.content.trim() : "";
    return {
      messages: [
        new AIMessage(responseText || "Lo siento, no encontrÃ© informaciÃ³n."),
      ],
    };
  }

  const promptTemplate = (promptKey && curatedPrompts[promptKey]) || defaultPrompt;
  const finalPrompt = promptTemplate
    .replace("{{retrieved}}", retrievedInfo)
    .replace("{{query}}", userQuery);

  const response = await model.invoke([
    { role: "system", content: finalPrompt },
    { role: "user", content: userQuery },
  ]);

  const responseText = typeof response.content === "string" ? response.content.trim() : "";
  const finalResponse =
    lang === process.env.SYSTEM_NATIVE_LANGUAGE
      ? responseText
      : await translateResponseBack(lang, responseText);

  return {
    ...state,
    messages: [
      ...state.messages,
      new AIMessage(finalResponse || "Lo siento, no encontrÃ© informaciÃ³n sobre habitaciones."),
    ],
  };
}

---------------------------------


ğŸ”¹ Archivo: ./lib/agents/billing.ts
---------------------------------
// app/agents/billings.ts
import { AIMessage } from "@langchain/core/messages";
export function handleBilling() {
    return { messages: [new AIMessage("Handling billings query")] };
}

---------------------------------


ğŸ”¹ Archivo: ./lib/agents/defaultResponse.ts
---------------------------------
// app/agents/defaultResponse.ts
import { AIMessage } from "@langchain/core/messages";
export function defaultResponse() {
    return { messages: [new AIMessage("Handling default respponse query")] };
}

---------------------------------


ğŸ”¹ Archivo: ./lib/agents/reservations.ts
---------------------------------
import { pms } from "lib/pms";

export async function handleReservation(state: { messages: { content: string }[] }) {
  const userMessage = state.messages[0].content; // Extraer el mensaje del usuario
  console.log(`User request: ${userMessage}`); // Se usa para evitar el error de variable no utilizada

  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [`Reservation confirmed: ${response.id}`] };
}

---------------------------------


ğŸ”¹ Archivo: ./lib/agents/services.ts
---------------------------------
// app/agents/services.ts
import { AIMessage } from "@langchain/core/messages";
export function handleServices() {
    return { messages: [new AIMessage("Handling services query")] };
}
---------------------------------


ğŸ”¹ Archivo: ./lib/agents/internal_support.ts
---------------------------------
// app/agents/internal_support.ts
import { AIMessage } from "@langchain/core/messages";
export function handleSupport() {
    return { messages: [new AIMessage("Handling support query")] };
}


---------------------------------


ğŸ”¹ Archivo: ./lib/agents/index.ts
---------------------------------
// ğŸ“ lib/agents/index.ts

import { StateGraph } from "@langchain/langgraph";
import { classifyQuery } from "../classifier";
import { AIMessage, HumanMessage, BaseMessage } from "@langchain/core/messages";
import { pms } from "../pms";
import { loadDocuments } from "../retrieval/index";
import { ChatOpenAI } from "@langchain/openai";
import { createRetrieverTool } from "langchain/tools/retriever";
import { Annotation } from "@langchain/langgraph";
import { retrievalBased } from "./retrieval_based";
import { franc } from "franc";
import { promptMetadata } from "../prompts/promptMetadata";
import { debugLog } from "../utils/debugLog";

console.log("ğŸ”§ Compilando grafo conversacional...");

// ğŸ§  Estado global del grafo
export const GraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),
    default: () => [] as BaseMessage[],
  }),
  category: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "other",
  }),
  detectedLanguage: Annotation<string>({
    reducer: (x, y) => y,
    default: () => "en",
  }),
  promptKey: Annotation<string | null>({
    reducer: (x, y) => y,
    default: () => null,
  }),
});

// ğŸ“š Cargar documentos y herramientas de recuperaciÃ³n
export const vectorStore = await loadDocuments();
const retriever = createRetrieverTool(vectorStore.asRetriever(), {
  name: "retrieve_hotel_info",
  description: "Search hotel FAQs and policies.",
});
export const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 }).bindTools([retriever]);

// ğŸ” Nodo: Clasificador de intenciÃ³n + detecciÃ³n de idioma
export async function classifyNode(state: typeof GraphState.State) {
  const lastUserMessage = state.messages.findLast((m) => m instanceof HumanMessage);
  const question = typeof lastUserMessage?.content === "string" ? lastUserMessage.content.trim() : "";

  if (!question) {
    return {
      ...state,
      category: "retrieval_based",
      promptKey: null,
      messages: [
        ...state.messages,
        new AIMessage("Consulta vacÃ­a o no vÃ¡lida. Intenta reformular tu pregunta."),
      ],
    };
  }

  const detectedLang = franc(question, { minLength: 3 });

  let classification;
  try {
    classification = await classifyQuery(question);
  } catch (e) {
    console.error("âŒ Error clasificando la consulta:", e);
    classification = { category: "retrieval_based", promptKey: null };
  }

  const { category, promptKey } = classification;

  // ValidaciÃ³n defensiva (promptKey debe estar autorizado para esa categorÃ­a)
  const validPromptKeys = promptMetadata[category] || [];
  const finalPromptKey = validPromptKeys.includes(promptKey || "") ? promptKey : null;

  debugLog("ğŸ§  ClasificaciÃ³n final:", { category, promptKey: finalPromptKey });

  return {
    ...state,
    category,
    promptKey: finalPromptKey,
    detectedLanguage: detectedLang || process.env.SYSTEM_NATIVE_LANGUAGE,
    messages: [
      ...state.messages,
      new AIMessage(`Consulta clasificada como: ${category}${finalPromptKey ? ` (ğŸ§  promptKey: ${finalPromptKey})` : ""}`),
    ],
  };
}

// ğŸ“… Nodo: GestiÃ³n de reservas (tambiÃ©n maneja cancelaciones)
async function handleReservationNode() {
  const response = pms.createReservation("John Doe", "Deluxe", "2024-06-01", "2024-06-05");
  return { messages: [new AIMessage(`Reserva confirmada: ${response.id}`)] };
}

// ğŸ’³ Nodo: FacturaciÃ³n
async function handleBillingNode() {
  return { messages: [new AIMessage("AquÃ­ estÃ¡n los detalles de facturaciÃ³n.")] };
}

// ğŸ›Ÿ Nodo: Soporte
async function handleSupportNode() {
  return { messages: [new AIMessage("Â¿En quÃ© puedo ayudarte? Nuestro equipo estÃ¡ disponible para asistirte.")] };
}

// ğŸ¤– Nodo: IA + recuperaciÃ³n de contexto
async function retrievalBasedNode(state: typeof GraphState.State) {
  return await retrievalBased(state);
}

// ğŸ•¸ï¸ ConstrucciÃ³n del grafo de estados
const graph = new StateGraph(GraphState)
  .addNode("classify", classifyNode)
  .addNode("handle_reservation", handleReservationNode)
  .addNode("handle_cancellation", handleReservationNode)
  .addNode("handle_billing", handleBillingNode)
  .addNode("handle_support", handleSupportNode)
  .addNode("handle_retrieval_based", retrievalBasedNode)

  // ğŸ” Transiciones
  .addEdge("__start__", "classify")
  .addConditionalEdges("classify", (state) => state.category, {
    reservation: "handle_reservation",
    cancellation: "handle_cancellation",
    billing: "handle_billing",
    support: "handle_support",
    retrieval_based: "handle_retrieval_based",
  })

  // ğŸ”š Finales
  .addEdge("handle_reservation", "__end__")
  .addEdge("handle_cancellation", "__end__")
  .addEdge("handle_billing", "__end__")
  .addEdge("handle_support", "__end__")
  .addEdge("handle_retrieval_based", "__end__");

console.log("âœ… Grafo compilado con Ã©xito.");

// ğŸš€ Exportar grafo compilado
export const agentGraph = graph.compile();

---------------------------------


ğŸ”¹ Archivo: ./lib/utils/debugLog.ts
---------------------------------
// lib/utils/debugLog.ts

export function debugLog(...args: any[]) {
    if (process.env.DEBUG === "true") {
      console.log(...args);
    }
  }
  
---------------------------------


ğŸ”¹ Archivo: ./test/agents.test.ts
---------------------------------
import { test, expect, vi, describe } from "vitest";
import 'openai/shims/node';

// ğŸ›‘ Mock de OpenAI para evitar llamadas reales
vi.mock("@langchain/openai", () => ({
  ChatOpenAI: vi.fn(() => ({
    invoke: vi.fn(() =>
      Promise.resolve({ content: "SÃ­, las habitaciones tienen WiFi gratis." })
    ),
  })),
}));

// ğŸ›‘ Mock de retrieve_hotel_info para evitar acceso a la base de datos
vi.mock("@/agents/room_info", () => ({
  retrieve_hotel_info: vi.fn(() => Promise.resolve("ğŸ“¶ WiFi gratis")),
}));

// ğŸ”„ Ahora importamos despuÃ©s de los mocks
import { ChatOpenAI } from "@langchain/openai";
import * as Agents from "lib/agents/retrieval_based";

describe("Agente de hotel - Pruebas con respuestas mockeadas", () => {
  test("El modelo usa correctamente la base vectorial", async () => {
    const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 });
    const query = "Â¿Las habitaciones tienen WiFi gratis?";
    const lang = process.env.SYSTEM_NATIVE_LANGUAGE || 'es';
    const vectorResponse = await Agents.retrieve_hotel_info("Â¿QuÃ© tipos de habitaciones tienen?", lang);
    const aiResponse = await model.invoke([{ role: "user", content: query }]);

    console.log("ğŸ“Œ Respuesta del modelo:", aiResponse);
    console.log("ğŸ“Œ Tipo de aiResponse:", typeof aiResponse);

    expect(aiResponse.content).toContain("WiFi gratis");
    expect(vectorResponse).toContain("ğŸ“¶ WiFi gratis");
  });
});

---------------------------------


ğŸ”¹ Archivo: ./test/presentacion.test.ts
---------------------------------
import { test, expect } from "vitest";
import { retrievalBased } from "../lib/agents/retrieval_based";
import { GraphState } from "../lib/agents"; // importa el GraphState para armar el estado
import { HumanMessage } from "@langchain/core/messages";

test("El formato contiene Markdown visual con emojis", async () => {
  const testQuery = "Â¿QuÃ© tipos de habitaciones tienen?";

  // ğŸ§  Simular estado del grafo como si viniera del flujo real
  const testState: typeof GraphState.State = {
    messages: [new HumanMessage(testQuery)],
    category: "room_info",
    detectedLanguage: "es",
    promptKey: null
  };

  // âœ… Invocar el nodo como lo harÃ­a LangGraph
  const result = await retrievalBased(testState);

  // ğŸ§¾ Extraer respuesta
  const response = result.messages[0].content;

  // ğŸ§ª Aserciones sobre el formato visual
  expect(response).toMatch(/ğŸ¨/); // emoji tÃ­tulo
  expect(response).toMatch(/\| ğŸ›ï¸/); // tabla
  expect(response).toMatch(/\*\*Â¡Reserva ahora.*\*\*/); // llamado final en negrita
});

---------------------------------


ğŸ”¹ Archivo: ./test/retrieval.test.ts
---------------------------------
import { test, expect } from "vitest";

import { retrieve_hotel_info } from "../lib/agents/retrieval_based.ts";

test("Recupera informaciÃ³n sobre habitaciones correctamente", async () => {
  const query = "Â¿QuÃ© tipos de habitaciones tienen?";
  const response = await retrieve_hotel_info(query, "es");
  console.log("ğŸ“Œ Respuesta obtenida:", response);

  expect(response).toContain("HabitaciÃ³n");
  expect(response).toContain("Ã¡rea de");
  expect(response).toContain("BaÃ±o privado");
});



---------------------------------


ğŸ”¹ Archivo: ./test/chat.test.ts
---------------------------------
import "openai/shims/node"; // Para arreglar el fetch de OpenAI
import request from "supertest";
import { createServer } from "http";
import { POST } from "../app/api/chat/route.ts";
import { test, expect, beforeAll, afterAll } from "vitest";

// ğŸ“Œ Servidor de pruebas
let server: any;

beforeAll(() => {
  server = createServer(async (req, res) => {
    try {
      let data = "";
      req.on("data", (chunk) => (data += chunk));
      req.on("end", async () => {
        try {
          const body = JSON.parse(data);

          // âœ… Aseguramos que la URL sea absoluta
          const fullUrl = new URL(req.url ?? "/api/chat", "http://localhost:3001");

          const nextReq = new Request(fullUrl.toString(), {
            method: req.method ?? "POST",
            headers: req.headers as HeadersInit,
            body: JSON.stringify(body),
          });

          // Ejecutar la funciÃ³n POST de Next.js
          const response = await POST(nextReq);
          const responseData = await response.json();

          // Responder con el contenido de Next.js
          res.writeHead(response.status, { "Content-Type": "application/json" });
          res.end(JSON.stringify(responseData));
        } catch (error) {
          console.error("âŒ Error al parsear JSON:", error);
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Solicitud invÃ¡lida" }));
        }
      });
    } catch (error) {
      console.error("âŒ Error en el servidor de pruebas:", error);
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Error interno en el servidor" }));
    }
  });

  server.listen(3001, () => {
    console.log("ğŸš€ Servidor de pruebas en ejecuciÃ³n en el puerto 3001");
  });
});

afterAll(() => {
  server.close();
  console.log("ğŸ›‘ Servidor de pruebas detenido.");
});

// ğŸ”¥ Test para validar la API de chat
test("Debe responder con un mensaje vÃ¡lido del bot", async () => {
  const response = await request(server)
    .post("/api/chat")
    .send({ query: "Â¿QuÃ© tipos de habitaciones tienen?" });

  console.log("ğŸ“Œ Respuesta del servidor:", response.body);

  expect(response.status).toBe(200);
  expect(response.body).toBeDefined();
  expect(response.body.response).toBeDefined();
  expect(response.body.response.length).toBeGreaterThan(0);
});

---------------------------------


ğŸ”¹ Archivo: ./test/ui.test.tsx
---------------------------------
import { test, expect } from "vitest";
import "@testing-library/jest-dom"; // ğŸ‘ˆ Agregar esto

import React from "react";
import { render, screen } from "@testing-library/react";
import { describe, it} from "vitest";
import ReactMarkdown from "react-markdown";
import rehypeRaw from "rehype-raw";

describe("ReactMarkdown", () => {
  it("Renderiza un enlace en ReactMarkdown", () => {
    render(
      <ReactMarkdown rehypePlugins={[rehypeRaw]}>
        {"[Reserva aquÃ­](https://booking.bedzzle.com/desktop/?&apikey=123&lang=es)"}
      </ReactMarkdown>
    );

    const linkElement = screen.getByText("Reserva aquÃ­");
    expect(linkElement).toBeInTheDocument(); // âœ… Ahora funcionarÃ¡
  });
});

---------------------------------


ğŸ”¹ Archivo: ./app/lib/translation.ts
---------------------------------
import { ChatOpenAI } from "@langchain/openai";

const model = new ChatOpenAI({ model: "gpt-4o", temperature: 0 });

export async function translationModel(text: string, targetLanguage: string) {
  return await model.invoke([{ role: "system", content: `Translate this to ${targetLanguage}: ${text}` }]);
}

---------------------------------


ğŸ”¹ Archivo: ./app/globals.css
---------------------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}
a {
  color: #2563eb;
  text-decoration: underline;
}

a:hover {
  color: #1e40af;
}



---------------------------------


ğŸ”¹ Archivo: ./app/layout.tsx
---------------------------------

import { Metadata } from "next";
import localFont from "next/font/local"; // âœ… ImportaciÃ³n correcta


import "./globals.css";

const inter = localFont({
  src: "../public/fonts/geist-latin.woff2", // âœ… Ruta corregida
  variable: "--font-inter",
});

const robotoMono = localFont({
  src: "../public/fonts/geist-mono-latin.woff2", // âœ… Ruta corregida
  variable: "--font-roboto-mono",
});


export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${inter.variable} ${robotoMono.variable} antialiased`}>
        {children}
      </body>
    </html>
  );
}

---------------------------------


ğŸ”¹ Archivo: ./app/page.tsx
---------------------------------
"use client";

import { useState } from "react";
import ReactMarkdown from "react-markdown"; // Importa react-markdown
// import remarkGfm from "remark-gfm";

export default function ChatPage() {
  const [query, setQuery] = useState("");
  const [response, setResponse] = useState("");
  const [loading, setLoading] = useState(false);

  const sendQuery = async () => {
    if (!query.trim()) return;
  
    setLoading(true);
    setResponse(""); 
  
    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ query }),
      });
  
      const data = await res.json();
      
      // Verifica que la respuesta sea un string antes de actualizar el estado
      const responseText = typeof data.response === "string" 
        ? data.response 
        : JSON.stringify(data.response, null, 2); // Convierte a string para depurar
  
      setResponse(responseText);
    } catch (error) {
      console.error("Error en la consulta:", error);
      setResponse("Error al obtener respuesta.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-gray-200 p-6">
      <h1 className="text-3xl font-bold mb-4 text-white">ğŸ’¬ Chat con IA</h1>
      <div className="w-full max-w-lg bg-gray-800 p-4 shadow-md rounded-lg">
        <textarea
          className="w-full border border-gray-700 bg-gray-900 text-gray-200 p-2 rounded-md focus:ring-2 focus:ring-blue-500 outline-none"
          rows={3}
          placeholder="Escribe tu pregunta..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
        />

        <button
          className="w-full bg-blue-600 text-white p-2 mt-3 rounded-md hover:bg-blue-700 transition"
          onClick={sendQuery}
          disabled={loading}
        >
          {loading ? "Pensando..." : "Preguntar"}
        </button>
      </div>

      {response && (
        <div className="w-full max-w-lg bg-gray-800 p-4 mt-4 shadow-md rounded-lg">
          <h2 className="text-lg font-semibold text-white">ğŸ¤– Respuesta:</h2>
          <div className="mt-2 text-gray-300">
          <ReactMarkdown
            components={{
              a: ({ ...props }) => (
                <a className="text-blue-500 underline hover:text-blue-700" {...props} />
              )
            }}
          >
            {response}
          </ReactMarkdown>
          </div>
        </div>
      )}

    </div>
  );
}

---------------------------------


ğŸ”¹ Archivo: ./app/api/whatsapp/route.ts
---------------------------------
// app/api/whatsapp/route.ts

import { NextResponse } from "next/server";

export async function GET() {
  return NextResponse.json({ status: "ğŸŸ¢ WhatsApp bot is running." });
}

export async function POST() {
  return NextResponse.json({ status: "ğŸŸ¢ WhatsApp bot is running independently and does not require webhooks." });
}

---------------------------------


ğŸ”¹ Archivo: ./app/api/chat/route.ts
---------------------------------
// /root/begasist/app/api/chat/route.ts

import { NextResponse } from "next/server";
import { agentGraph } from "/../lib/agents/index.ts";
import { HumanMessage, AIMessage } from "@langchain/core/messages";
import { debugLog } from "../../../lib/utils/debugLog";

export async function POST(req: Request) {
  try {
    const { query } = await req.json();
    debugLog("ğŸ” Consulta recibida:", query);

    const response = await agentGraph.invoke({
      messages: [new HumanMessage(query)],
    });

    // Buscar el Ãºltimo mensaje que sea un AIMessage y obtener su contenido
    const aiMessage = response.messages.findLast(
      (msg) => msg instanceof AIMessage
    ) as AIMessage | undefined;

    const responseText = aiMessage?.content || "No se encontrÃ³ una respuesta.";

    debugLog("ğŸ“Œ Respuesta enviada:", responseText);

    return NextResponse.json({ response: responseText });
  } catch (error) {
    console.error("â›” Error en la API /api/chat:", error);
    return NextResponse.json(
      { response: "OcurriÃ³ un error al procesar la solicitud." },
      { status: 500 }
    );
  }
}

---------------------------------

